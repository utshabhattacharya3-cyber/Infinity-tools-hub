<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinity Tool Hub</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
  <style>
    /* --- FONT IMPORTS --- */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Poppins:wght@600;700&display=swap');

    /* --- CSS RESET & DEFAULTS --- */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* --- THEME DEFINITIONS --- */
    :root {
      /* Typography */
      --font-primary: 'Inter', sans-serif;
      --font-display: 'Poppins', sans-serif;

      /* Spacing */
      --space-unit: 4px;
      --space-xs: calc(2 * var(--space-unit));  /* 8px */
      --space-sm: calc(3 * var(--space-unit));  /* 12px */
      --space-md: calc(4 * var(--space-unit));  /* 16px */
      --space-lg: calc(6 * var(--space-unit));  /* 24px */
      --space-xl: calc(8 * var(--space-unit));  /* 32px */
      
      /* Radii */
      --radius-md: 12px;
      --radius-lg: 16px;
      
      /* Transitions */
      --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-med: 0.3s cubic-bezier(0.4, 0, 0.2, 1);

      /* Heights */
      --header-height: 60px;
      --mobile-nav-height: 60px;
    }

    .theme-neon-nights {
      --color-primary: #00D4FF;
      --color-secondary: #8B5CF6;
      --color-accent: #EC4899;
      --color-bg-primary: #0A0A1A;
      --color-bg-secondary: #1E1E2E;
      --color-text-primary: #E2E8F0;
      --color-text-secondary: #94A3B8;
      --color-border: rgba(255, 255, 255, 0.1);
      --color-glass-bg: rgba(30, 30, 46, 0.7);
      --glow-primary: 0 0 12px rgba(0, 212, 255, 0.6);
      --glow-primary-intense: 0 0 20px rgba(0, 212, 255, 0.4);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
      --logo-color-start: var(--color-primary);
      --logo-color-stop: var(--color-secondary);
      --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
      --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(139, 92, 246, 0.15), transparent 50%),
                     radial-gradient(ellipse 50% 50% at 95% 10%, rgba(0, 212, 255, 0.15), transparent 40%),
                     var(--color-bg-primary);
    }

    .theme-royal-violet {
      --color-primary: #9D4EDD;
      --color-secondary: #7B2CBF;
      --color-accent: #C77DFF;
      --color-bg-primary: #10002B;
      --color-bg-secondary: #240046;
      --color-text-primary: #E2E0FF;
      --color-text-secondary: #B8B5FF;
      --color-border: rgba(225, 190, 231, 0.15);
      --color-glass-bg: rgba(36, 0, 70, 0.7);
      --glow-primary: 0 0 12px rgba(157, 78, 221, 0.6);
      --glow-primary-intense: 0 0 20px rgba(157, 78, 221, 0.4);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
      --logo-color-start: var(--color-primary);
      --logo-color-stop: var(--color-secondary);
      --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
      --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(123, 44, 191, 0.15), transparent 50%),
                     radial-gradient(ellipse 50% 50% at 95% 10%, rgba(157, 78, 221, 0.15), transparent 40%),
                     var(--color-bg-primary);
    }

    .theme-solar-flare {
      --color-primary: #FF8C00;
      --color-secondary: #FF4D00;
      --color-accent: #FFD700;
      --color-bg-primary: #1A0A0A;
      --color-bg-secondary: #2E1E1E;
      --color-text-primary: #F0E2E2;
      --color-text-secondary: #B8A394;
      --color-border: rgba(255, 220, 200, 0.1);
      --color-glass-bg: rgba(46, 30, 30, 0.7);
      --glow-primary: 0 0 12px rgba(255, 140, 0, 0.6);
      --glow-primary-intense: 0 0 20px rgba(255, 140, 0, 0.4);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
      --logo-color-start: var(--color-primary);
      --logo-color-stop: var(--color-secondary);
      --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
      --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(255, 77, 0, 0.15), transparent 50%),
                     radial-gradient(ellipse 50% 50% at 95% 10%, rgba(255, 140, 0, 0.15), transparent 40%),
                     var(--color-bg-primary);
    }

    .theme-arctic-aurora {
      --color-primary: #00F5D4;
      --color-secondary: #00B4D8;
      --color-accent: #90E0EF;
      --color-bg-primary: #0A1A1A;
      --color-bg-secondary: #1E2E2E;
      --color-text-primary: #E2F0F0;
      --color-text-secondary: #94B8B8;
      --color-border: rgba(200, 255, 255, 0.1);
      --color-glass-bg: rgba(30, 46, 46, 0.7);
      --glow-primary: 0 0 12px rgba(0, 245, 212, 0.6);
      --glow-primary-intense: 0 0 20px rgba(0, 245, 212, 0.4);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
      --logo-color-start: var(--color-primary);
      --logo-color-stop: var(--color-secondary);
      --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
      --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(0, 180, 216, 0.15), transparent 50%),
                     radial-gradient(ellipse 50% 50% at 95% 10%, rgba(0, 245, 212, 0.15), transparent 40%),
                     var(--color-bg-primary);
    }

    .theme-cyberpunk-city {
        --color-primary: #FF00AA;
        --color-secondary: #FFEA00;
        --color-accent: #00FFEE;
        --color-bg-primary: #1A0A1A;
        --color-bg-secondary: #2E1E2E;
        --color-text-primary: #F0E2F0;
        --color-text-secondary: #B894B8;
        --color-border: rgba(255, 200, 255, 0.1);
        --color-glass-bg: rgba(46, 30, 46, 0.7);
        --glow-primary: 0 0 12px rgba(255, 0, 170, 0.6);
        --glow-primary-intense: 0 0 20px rgba(255, 0, 170, 0.4);
        --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
        --logo-color-start: var(--color-primary);
        --logo-color-stop: var(--color-accent);
        --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-accent) 100%);
        --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(255, 234, 0, 0.15), transparent 50%),
                       radial-gradient(ellipse 50% 50% at 95% 10%, rgba(255, 0, 170, 0.15), transparent 40%),
                       var(--color-bg-primary);
    }

    .theme-matrix-green {
        --color-primary: #00FF66;
        --color-secondary: #00CC99;
        --color-accent: #00FFAA;
        --color-bg-primary: #000F0A;
        --color-bg-secondary: #1E2E1E;
        --color-text-primary: #E2F0E2;
        --color-text-secondary: #94B894;
        --color-border: rgba(200, 255, 200, 0.1);
        --color-glass-bg: rgba(30, 46, 30, 0.7);
        --glow-primary: 0 0 12px rgba(0, 255, 102, 0.6);
        --glow-primary-intense: 0 0 20px rgba(0, 255, 102, 0.4);
        --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.3);
        --logo-color-start: var(--color-primary);
        --logo-color-stop: var(--color-secondary);
        --gradient-primary: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
        --gradient-bg: radial-gradient(ellipse 80% 80% at 5% 95%, rgba(0, 204, 153, 0.15), transparent 50%),
                       radial-gradient(ellipse 50% 50% at 95% 10%, rgba(0, 255, 102, 0.15), transparent 40%),
                       var(--color-bg-primary);
    }

    /* --- GENERAL STYLES --- */
    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      background-color: var(--color-bg-primary);
      background-image: var(--gradient-bg);
      color: var(--color-text-primary);
      font-family: var(--font-primary);
      transition: background-color var(--transition-med);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* --- BACKGROUND CANVAS --- */
    #particle-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.7;
    }

    /* --- LAYOUT --- */
    .app-header {
      height: var(--header-height);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-lg);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      background: rgba(10, 10, 26, 0.5);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--color-border);
    }

    .logo {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      text-decoration: none;
    }

    .logo-svg {
        width: 32px;
        height: 32px;
    }

    .logo-text {
        font-family: var(--font-display);
        font-size: 1.5rem;
        color: var(--color-text-primary);
        font-weight: 600;
    }

    .main-content {
      flex-grow: 1;
      overflow-y: auto;
      padding: var(--space-lg);
      padding-top: calc(var(--header-height) + var(--space-lg));
      padding-bottom: calc(var(--mobile-nav-height) + var(--space-lg));
    }

    .view {
      display: none;
    }
    .view.active {
      display: block;
      animation: slideFadeIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slideFadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* --- THEME SWITCHER --- */
    #theme-select {
      background-color: var(--color-bg-secondary);
      color: var(--color-text-primary);
      border: 1px solid var(--color-border);
      border-radius: var(--space-xs);
      padding: var(--space-xs);
      font-family: var(--font-primary);
      transition: all var(--transition-fast);
    }
    #theme-select:hover {
        border-color: var(--color-primary);
    }

    /* --- NAVIGATION --- */
    .mobile-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--mobile-nav-height);
      background: rgba(10, 10, 26, 0.5);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--color-border);
      display: flex;
      justify-content: space-around;
      align-items: center;
      z-index: 20;
    }

    .desktop-nav {
      display: none;
    }

    .nav-link {
      background: none;
      border: none;
      color: var(--color-text-secondary);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-unit);
      font-size: 0.75rem;
      cursor: pointer;
      transition: color var(--transition-fast), transform var(--transition-fast);
      padding: var(--space-xs);
      text-decoration: none;
    }

    .nav-link:hover {
      color: var(--color-primary);
      transform: translateY(-2px);
    }

    .nav-link.active {
      color: var(--color-primary);
    }

    .nav-link svg {
      width: 24px;
      height: 24px;
    }
     .nav-link span {
        display: none;
     }

    /* --- DASHBOARD & TOOL GRID --- */
    .dashboard-header {
      margin-bottom: var(--space-lg);
    }

    .search-container {
      position: relative;
    }

    #search-input {
      width: 100%;
      padding: var(--space-sm) var(--space-md);
      padding-left: 40px;
      background-color: rgba(30, 30, 46, 0.5);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: 1rem;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    #search-input:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: var(--glow-primary);
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      color: var(--color-text-secondary);
    }
        
    .category-filters {
      display: flex;
      gap: var(--space-sm);
      overflow-x: auto;
      padding: var(--space-sm) 0;
      margin-top: var(--space-md);
      scrollbar-width: none; /* Firefox */
    }
    .category-filters::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    .category-filter-btn {
      flex-shrink: 0;
      padding: var(--space-xs) var(--space-md);
      border: 1px solid var(--color-border);
      background-color: transparent;
      color: var(--color-text-secondary);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
    }
        
    .category-filter-btn:hover {
        color: var(--color-primary);
        border-color: var(--color-primary);
    }

    .category-filter-btn.active {
      color: var(--color-bg-primary);
      background: var(--gradient-primary);
      border-color: transparent;
      box-shadow: var(--glow-primary);
      font-weight: 500;
    }

    .category-container {
      margin-top: var(--space-lg);
    }

    .category-title {
      font-family: var(--font-display);
      font-size: 1.75rem;
      margin-bottom: var(--space-md);
      color: var(--color-primary);
      border-bottom: 1px solid var(--color-border);
      padding-bottom: var(--space-sm);
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-sm);
    }

    .tool-card {
      background: var(--color-glass-bg);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-lg);
      padding: var(--space-sm);
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      cursor: pointer;
      transition: transform var(--transition-med), box-shadow var(--transition-med), border-color var(--transition-med);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-lg);
      position: relative;
    }

    .tool-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--glow-primary-intense);
      border-color: var(--color-primary);
    }

    .tool-card .tool-icon {
      width: 32px;
      height: 32px;
      margin-bottom: var(--space-xs);
      color: var(--color-primary);
      transition: color var(--transition-fast);
    }

    .tool-card h3 {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 2px;
      line-height: 1.2;
    }

    .tool-card p {
      font-size: 0.75rem;
      color: var(--color-text-secondary);
      flex-grow: 1;
    }
    
    .favorite-btn {
      position: absolute;
      top: var(--space-sm);
      right: var(--space-sm);
      background: none;
      border: none;
      color: var(--color-text-secondary);
      cursor: pointer;
      padding: var(--space-xs);
      transition: color var(--transition-fast), transform var(--transition-fast), opacity var(--transition-fast);
      z-index: 2;
      opacity: 0.6;
    }
    
    .tool-card:hover .favorite-btn, .favorite-btn:hover, .favorite-btn.favorited {
        opacity: 1;
    }

    .favorite-btn:hover {
        color: #FFD700;
        transform: scale(1.2);
    }
    .favorite-btn.favorited {
        color: #FFD700;
    }
    
    .favorite-btn svg {
        width: 22px;
        height: 22px;
        fill: currentColor;
        pointer-events: none; /* Ensure clicks go to the button */
    }

    /* --- TOOL VIEW --- */
    .back-button {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      background: transparent;
      border: 1px solid var(--color-border);
      color: var(--color-text-secondary);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-md);
      cursor: pointer;
      margin-bottom: var(--space-lg);
      transition: all var(--transition-fast);
    }
    .back-button:hover {
      color: var(--color-primary);
      border-color: var(--color-primary);
      background: rgba(30, 30, 46, 0.5);
    }
    .back-button svg {
      width: 20px;
      height: 20px;
    }

    #tool-container {
        background: var(--color-glass-bg);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-lg);
        backdrop-filter: blur(20px);
        transition: all var(--transition-med);
        display: flex;
        flex-direction: column;
    }
        
    .tool-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-sm) var(--space-lg);
        border-bottom: 1px solid var(--color-border);
    }

    .tool-header h2 {
        font-family: var(--font-display);
        color: var(--color-primary);
        font-size: 1.25rem;
    }

    .tool-controls button {
        background: none;
        border: none;
        color: var(--color-text-secondary);
        cursor: pointer;
        padding: var(--space-xs);
        transition: color var(--transition-fast);
    }
    .tool-controls button:hover {
        color: var(--color-primary);
    }
    .tool-controls svg {
        width: 20px;
        height: 20px;
        fill: currentColor;
    }

    .tool-content {
      padding: var(--space-lg);
    }

    /* Fullscreen mode for tool */
    .collapse-icon {
        display: none;
    }

    body.tool-fullscreen .app-header,
    body.tool-fullscreen .desktop-nav,
    body.tool-fullscreen .mobile-nav,
    body.tool-fullscreen #back-to-dashboard {
        display: none;
    }
    
    body.tool-fullscreen .main-content {
        padding: 0;
        overflow: hidden;
    }

    body.tool-fullscreen #tool-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        border-radius: 0;
    }

    body.tool-fullscreen #tool-container .tool-content {
        flex-grow: 1;
        overflow-y: auto;
    }

    body.tool-fullscreen #tool-expand-btn .expand-icon {
        display: none;
    }

    body.tool-fullscreen #tool-expand-btn .collapse-icon {
        display: block;
    }

    /* --- SHARED TOOL STYLES --- */
    .tool-input-group {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }
    .tool-input-group label {
      color: var(--color-text-secondary);
      font-size: 0.9rem;
    }
    .tool-input, .tool-select, .tool-textarea {
      width: 100%;
      padding: var(--space-sm);
      background-color: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: 1rem;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
      font-family: var(--font-primary);
    }
    .tool-textarea {
        resize: vertical;
        min-height: 120px;
    }
    .tool-input:focus, .tool-select:focus, .tool-textarea:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: var(--glow-primary);
    }
    /* Hide number input spinners */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none;
        margin: 0;
    }
    input[type=number] {
        -moz-appearance: textfield;
    }
    
    .tool-button {
      padding: var(--space-sm) var(--space-md);
      border: 1px solid var(--color-primary);
      background: var(--color-primary);
      color: var(--color-bg-primary);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      font-weight: 500;
      font-size: 1rem;
    }
    .tool-button:hover {
      background: transparent;
      color: var(--color-primary);
      box-shadow: 0 0 8px var(--color-primary);
    }
    .tool-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .tool-button-secondary {
        background: transparent;
        border-color: var(--color-border);
        color: var(--color-text-secondary);
    }
    .tool-button-secondary:hover {
        border-color: var(--color-primary);
        color: var(--color-primary);
        box-shadow: none;
    }
    .tool-button.active {
      color: var(--color-bg-primary);
      background: var(--gradient-primary);
      border-color: transparent;
    }
    .tool-controls-grid {
        display: flex;
        gap: var(--space-sm);
        justify-content: center;
        flex-wrap: wrap;
    }
    .tool-output {
      margin-top: var(--space-lg);
      padding: var(--space-md);
      background: var(--color-bg-secondary);
      border-radius: var(--radius-md);
      text-align: center;
      font-size: 1.25rem;
    }
    .tool-output .value {
        color: var(--color-primary);
        font-weight: 700;
        font-family: var(--font-display);
    }
    .tool-output .label {
        color: var(--color-text-secondary);
        font-size: 0.9rem;
        margin-top: var(--space-xs);
    }
    .tool-output-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: var(--space-md);
    }
    .tool-output-grid .item .label { font-size: 0.8rem; }
    .tool-output-grid .item .value { font-size: 1.1rem; }

    .tool-tabs {
        display: flex;
        gap: var(--space-xs);
        margin-bottom: var(--space-md);
    }
    .tool-tab-btn {
        flex-grow: 1;
    }
    .tool-grid-2col {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-lg);
    }
    .disclaimer {
        font-size: 0.8rem;
        text-align: center;
        color: var(--color-text-secondary);
        margin-top: var(--space-md);
    }

    /* --- TOOL: DIGITAL CLOCK --- */
    .digital-clock {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-md);
      padding: var(--space-lg) 0;
    }
    .digital-clock .time {
      font-family: var(--font-display);
      font-size: 3rem;
      font-weight: 700;
      color: var(--color-primary);
      text-shadow: var(--glow-primary);
      letter-spacing: 4px;
    }
    .digital-clock .date {
      font-size: 1.25rem;
      color: var(--color-text-secondary);
    }

    /* --- TOOL: WORD COUNTER --- */
    .word-counter {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }
    .word-counter-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: var(--space-md);
    }
    .stat-item {
      background: var(--color-bg-secondary);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-md);
      text-align: center;
    }
    .stat-item .value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-primary);
    }
    .stat-item .label {
      font-size: 0.875rem;
      color: var(--color-text-secondary);
    }

    /* --- TOOL: WORLD CLOCK --- */
    .world-clock-adder {
        display: flex;
        gap: var(--space-sm);
        margin-bottom: var(--space-lg);
    }
    #world-clock-list {
        display: grid;
        gap: var(--space-md);
    }
    .world-clock-card {
        background-color: var(--color-bg-secondary);
        border-radius: var(--radius-md);
        padding: var(--space-md);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--space-md);
    }
    .world-clock-card .info .city {
        font-size: 1.2rem;
        font-weight: 500;
    }
    .world-clock-card .info .date {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
    }
    .world-clock-card .time {
        font-family: var(--font-display);
        font-size: 1.75rem;
        color: var(--color-primary);
    }
    .world-clock-card .remove-btn {
        background: none;
        border: none;
        color: var(--color-text-secondary);
        cursor: pointer;
        opacity: 0.5;
        transition: all var(--transition-fast);
        font-size: 1.5rem;
        padding: 0 var(--space-xs);
    }
    .world-clock-card:hover .remove-btn {
        opacity: 1;
    }
    .world-clock-card .remove-btn:hover {
        color: var(--color-accent);
    }

    /* --- TOOL: COUNTDOWN / STOPWATCH / POMODORO --- */
    .timer-display {
        text-align: center;
        font-family: var(--font-display);
        font-weight: 700;
        color: var(--color-primary);
        text-shadow: var(--glow-primary);
        margin: var(--space-lg) 0;
    }
    .countdown-display {
        display: flex;
        justify-content: center;
        gap: var(--space-md);
    }
    .countdown-display .unit {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: var(--color-bg-secondary);
        padding: var(--space-sm);
        border-radius: var(--radius-md);
        min-width: 70px;
    }
    .countdown-display .value {
        font-size: 2rem;
    }
    .countdown-display .label {
        font-size: 0.8rem;
        color: var(--color-text-secondary);
        font-family: var(--font-primary);
    }
    .stopwatch-display {
        font-size: 3rem;
        letter-spacing: 2px;
    }
    .stopwatch-laps {
        margin-top: var(--space-lg);
        max-height: 200px;
        overflow-y: auto;
        background: var(--color-bg-secondary);
        border-radius: var(--radius-md);
    }
    .stopwatch-laps table {
        width: 100%;
        border-collapse: collapse;
    }
    .stopwatch-laps th, .stopwatch-laps td {
        padding: var(--space-sm);
        text-align: left;
    }
    .stopwatch-laps th {
        color: var(--color-text-secondary);
        position: sticky;
        top: 0;
        background: var(--color-bg-secondary);
        border-bottom: 1px solid var(--color-border);
    }
    .pomodoro-timer .status {
        text-align: center;
        font-size: 1.2rem;
        margin-bottom: var(--space-sm);
    }
    .pomodoro-timer .timer-display {
        font-size: 4rem;
    }
    .pomodoro-timer .config {
        display: flex;
        gap: var(--space-sm);
        justify-content: center;
        margin-top: var(--space-lg);
        flex-wrap: wrap;
    }
    .pomodoro-timer .config label {
        display: flex;
        align-items: center;
        gap: var(--space-xs);
        color: var(--color-text-secondary);
    }
    .pomodoro-timer .config input {
        width: 60px;
        padding: var(--space-xs);
        background: var(--color-bg-primary);
    }

    /* --- TOOL: CONVERTERS --- */
    .converter-ui {
        display: flex;
        flex-direction: column;
        gap: var(--space-lg);
    }
    .converter-row {
        display: grid;
        grid-template-columns: 1fr;
        gap: var(--space-md);
        align-items: center;
    }
    .converter-input-group {
        display: flex;
        flex-direction: column;
        gap: var(--space-xs);
    }
    .converter-input-group .tool-input {
        font-size: 1.5rem;
        font-weight: 500;
    }
    .converter-swap-btn {
        justify-self: center;
        background: none;
        border: 1px solid var(--color-border);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--color-text-secondary);
        transition: all var(--transition-fast);
    }
    .converter-swap-btn:hover {
        color: var(--color-primary);
        border-color: var(--color-primary);
        transform: rotate(180deg);
    }

    /* --- TOOL: CALENDAR --- */
    .calendar-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--space-md);
    }
    .calendar-controls h3 {
        font-family: var(--font-display);
        color: var(--color-primary);
        font-size: 1.5rem;
        text-align: center;
        flex-grow: 1;
    }
    .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: var(--space-xs);
    }
    .calendar-grid div {
        text-align: center;
        padding: var(--space-sm);
        border-radius: var(--radius-md);
    }
    .calendar-header {
        font-weight: bold;
        color: var(--color-text-secondary);
    }
    .calendar-day {
        background-color: var(--color-bg-secondary);
    }
    .calendar-day.today {
        background: var(--gradient-primary);
        color: var(--color-bg-primary);
        font-weight: bold;
    }

    /* --- TOOL: CALCULATORS (SHARED) --- */
     .calculator-container {
        max-width: 400px;
        margin: 0 auto;
    }
    .calculator-display-container {
        background: var(--color-bg-secondary);
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        text-align: right;
        font-family: var(--font-display);
        margin-bottom: var(--space-md);
        position: relative;
    }
    .calculator-display-expression {
        color: var(--color-text-secondary);
        font-size: 1rem;
        min-height: 24px;
        overflow-x: auto;
        white-space: nowrap;
    }
     .calculator-display-main {
        font-size: 2.5rem;
        color: var(--color-text-primary);
        word-break: break-all;
        min-height: 48px;
    }
     .calculator-btn {
        padding: var(--space-md) var(--space-xs);
        font-size: 1.1rem;
        border-radius: var(--radius-md);
        border: 1px solid var(--color-border);
        background: var(--color-glass-bg);
        color: var(--color-text-primary);
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 50px;
    }
    .calculator-btn:hover {
        background: var(--color-bg-secondary);
        border-color: var(--color-primary);
    }
    .calculator-btn.operator { color: var(--color-primary); }
    .calculator-btn.function { color: var(--color-accent); }
    .calculator-btn.equals {
        grid-column: span 2;
        background: var(--gradient-primary);
        border-color: transparent;
        color: var(--color-bg-primary);
        font-size: 1.5rem;
    }
    .calculator-btn.active {
      color: var(--color-bg-primary);
      background-color: var(--color-accent);
      border-color: var(--color-accent);
    }
    .calculator-btn.span-2 { grid-column: span 2; }


    /* --- TOOL: NORMAL CALCULATOR --- */
    .normal-calculator-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: var(--space-sm);
    }
    
    /* --- TOOL: SCIENTIFIC CALCULATOR --- */
    .scientific-calculator-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: var(--space-sm);
    }
    .calculator-mode-indicator {
      position: absolute;
      top: var(--space-xs);
      left: var(--space-sm);
      font-size: 0.8rem;
      color: var(--color-accent);
    }

    /* --- TOOL: FINANCIAL CALCULATORS --- */
    .finance-results {
        background-color: var(--color-bg-secondary);
        border-radius: var(--radius-md);
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
    }
    .finance-result-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
    }
    .finance-result-row .label {
        color: var(--color-text-secondary);
    }
    .finance-result-row .value {
        font-size: 1.75rem;
        font-weight: 700;
        color: var(--color-primary);
        font-family: var(--font-display);
    }
    .finance-result-row .sub-value {
        font-size: 1rem;
        color: var(--color-text-primary);
    }
    /* Loan Calculator Chart */
    .loan-chart-container {
        margin-top: var(--space-md);
    }
    .loan-chart-bar {
        width: 100%;
        height: 30px;
        background-color: var(--color-bg-primary);
        border-radius: var(--radius-md);
        display: flex;
        overflow: hidden;
    }
    .loan-chart-principal { background: var(--color-primary); }
    .loan-chart-interest { background: var(--color-accent); }
    .loan-chart-legend {
        margin-top: var(--space-sm);
        display: flex;
        justify-content: center;
        gap: var(--space-md);
        font-size: 0.8rem;
    }
    .loan-chart-legend span {
        display: flex;
        align-items: center;
        gap: var(--space-xs);
    }
    .loan-chart-legend span::before {
        content: '';
        width: 12px;
        height: 12px;
        border-radius: 50%;
    }
    .loan-chart-legend .legend-principal::before { background: var(--color-primary); }
    .loan-chart-legend .legend-interest::before { background: var(--color-accent); }


    /* --- TOOL: BMI CALCULATOR --- */
    .bmi-calculator .unit-toggle {
        display: flex;
        justify-content: center;
        margin-bottom: var(--space-lg);
    }
    .bmi-calculator .tool-input-row {
        display: flex;
        gap: var(--space-sm);
    }
    
    /* --- TOOL: PASSWORD GENERATOR --- */
    .password-display {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }
    .password-display input {
      font-family: var(--font-display);
      font-size: 1.2rem;
    }
    .password-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }
    .password-option {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }
    .password-strength-meter {
        width: 100%;
        height: 8px;
        background-color: var(--color-bg-secondary);
        border-radius: 4px;
        margin-top: var(--space-xs);
        overflow: hidden;
    }
    .password-strength-bar {
        height: 100%;
        width: 0;
        border-radius: 4px;
        transition: width 0.3s, background-color 0.3s;
    }
    .password-strength-bar.strength-1 { width: 25%; background-color: #ef4444; } /* red */
    .password-strength-bar.strength-2 { width: 50%; background-color: #f97316; } /* orange */
    .password-strength-bar.strength-3 { width: 75%; background-color: #eab308; } /* yellow */
    .password-strength-bar.strength-4 { width: 100%; background-color: #22c55e; } /* green */

    /* --- TOOL: MARKDOWN PREVIEWER --- */
    .markdown-previewer {
        height: 500px;
    }
    .markdown-previewer textarea, .markdown-previewer .preview-output {
        width: 100%;
        height: 100%;
        padding: var(--space-md);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        background: var(--color-bg-secondary);
    }
     .markdown-previewer .preview-output {
        overflow-y: auto;
    }
    .preview-output h1, .preview-output h2, .preview-output h3 { margin: 0.5em 0; color: var(--color-primary); }
    .preview-output p { margin-bottom: 0.5em; }
    .preview-output strong { font-weight: bold; }
    .preview-output em { font-style: italic; }
    .preview-output a { color: var(--color-accent); text-decoration: none; }
    .preview-output a:hover { text-decoration: underline; }
    .preview-output ul, .preview-output ol { margin-left: 1.5em; margin-bottom: 0.5em; }
    .preview-output code { background: var(--color-bg-primary); padding: 2px 4px; border-radius: 4px; }
    .preview-output blockquote { border-left: 3px solid var(--color-border); padding-left: 1em; margin-left: 0; color: var(--color-text-secondary); }

    /* --- TOOL: PING TOOL --- */
    .terminal-output {
        background: var(--color-bg-primary);
        color: var(--color-text-primary);
        font-family: monospace;
        padding: var(--space-md);
        border-radius: var(--radius-md);
        height: 200px;
        overflow-y: auto;
        border: 1px solid var(--color-border);
    }
    .terminal-output .line.success { color: #22c55e; }
    .terminal-output .line.error { color: #ef4444; }
    
    /* --- TOOL: WHOIS --- */
    #whois-output {
        white-space: pre-wrap;
        word-break: break-all;
    }

    /* --- TOOL: MORSE CODE --- */
    #morse-audio-btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
    }

    /* --- TOOL: BATTERY STATUS --- */
    .battery-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        gap: var(--space-lg);
    }
    .battery-visual {
        width: 100px;
        height: 200px;
        border: 4px solid var(--color-text-secondary);
        border-radius: var(--radius-md);
        position: relative;
        padding: 4px;
    }
    .battery-visual::after {
        content: '';
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 30px;
        height: 8px;
        background: var(--color-text-secondary);
        border-radius: 4px 4px 0 0;
    }
    .battery-level {
        position: absolute;
        bottom: 4px;
        left: 4px;
        right: 4px;
        background: var(--gradient-primary);
        border-radius: 6px;
        transition: height var(--transition-med);
    }
    .battery-charging-icon {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        color: rgba(255,255,255,0.8);
        display: none;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .battery-charging .battery-charging-icon { display: block; }
    .battery-info { text-align: center; }
    .battery-percent { font-size: 2.5rem; font-family: var(--font-display); color: var(--color-primary); }
    .battery-status-text { color: var(--color-text-secondary); }

    /* --- TOOL: NOTES & TODO --- */
    .list-app-container {
      display: flex;
      gap: var(--space-md);
      height: 60vh;
    }
    .list-sidebar {
      width: 150px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
    }
    .list-items {
      flex-grow: 1;
      overflow-y: auto;
      background: var(--color-bg-secondary);
      border-radius: var(--radius-md);
    }
    .list-item {
      padding: var(--space-sm);
      border-bottom: 1px solid var(--color-border);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .list-item:hover { background: var(--color-glass-bg); }
    .list-item.active { color: var(--color-primary); font-weight: 500; }
    .list-item-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .list-delete-btn { font-size: 1.2rem; opacity: 0.5; }
    .list-delete-btn:hover { color: var(--color-accent); opacity: 1; }
    .editor-main { flex-grow: 1; }
    .editor-main textarea { height: 100%; }
    .todo-list-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
      background: var(--color-bg-secondary);
      border-radius: var(--radius-md);
    }
    .todo-list-item input[type="checkbox"] { flex-shrink: 0; }
    .todo-list-item span { flex-grow: 1; }
    .todo-list-item.completed span { text-decoration: line-through; color: var(--color-text-secondary); }
    .todo-controls { margin-top: var(--space-md); }

    /* --- TOOL: WEATHER --- */
    .weather-card {
        background: var(--color-glass-bg);
        border-radius: var(--radius-lg);
        padding: var(--space-lg);
        text-align: center;
    }
    .weather-location { font-size: 1.5rem; }
    .weather-main { display: flex; align-items: center; justify-content: center; margin: var(--space-md) 0; }
    .weather-icon { font-size: 4rem; margin-right: var(--space-md); }
    .weather-temp { font-size: 3.5rem; font-family: var(--font-display); color: var(--color-primary); }
    .weather-desc { text-transform: capitalize; }
    .weather-details { display: flex; justify-content: space-around; margin-top: var(--space-lg); }

    /* --- TOOL: SOUND METER --- */
    .sound-meter-container { text-align: center; }
    #sound-meter-gauge { width: 100%; max-width: 300px; height: 150px; }
    #sound-meter-db { font-size: 3rem; font-family: var(--font-display); color: var(--color-primary); }

    /* --- TOOL: COMPASS --- */
    .compass {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: var(--space-lg);
    }
    .compass-dial {
      width: 200px;
      height: 200px;
      border: 5px solid var(--color-primary);
      border-radius: 50%;
      position: relative;
      background: var(--color-bg-secondary);
      transition: transform 0.2s linear;
    }
    .compass-dial::before {
      content: 'N';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      color: var(--color-accent);
    }
    .compass-pointer {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 20px solid var(--color-primary);
    }
    .compass-heading { font-size: 2rem; font-family: var(--font-display); }
    
    /* --- TOOL: SCREEN LIGHT --- */
    .screen-light-active {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: white;
        z-index: 9999;
    }

    /* --- DEVICE TOOLS & PUZZLE GAMES STYLES --- */
    .device-info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--space-md);
        margin-bottom: var(--space-lg);
    }
    .device-info-item {
        background: var(--color-bg-secondary);
        padding: var(--space-md);
        border-radius: var(--radius-md);
        text-align: center;
    }
    .device-info-item .value {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--color-primary);
        margin-bottom: var(--space-xs);
    }
    .device-info-item .label {
        font-size: 0.9rem;
        color: var(--color-text-secondary);
    }

    .screen-ruler {
        position: relative;
        background: var(--color-bg-secondary);
        border-radius: var(--radius-md);
        padding: var(--space-md);
        overflow: hidden;
    }
    .ruler-line {
        position: absolute;
        background: var(--color-primary);
        z-index: 10;
        pointer-events: none;
    }
    .ruler-horizontal {
        height: 2px;
        width: 100%;
        top: 50%;
        left: 0;
    }
    .ruler-vertical {
        width: 2px;
        height: 100%;
        left: 50%;
        top: 0;
    }

    .color-picker-container {
        text-align: center;
    }
    .color-preview {
        width: 200px;
        height: 200px;
        border-radius: var(--radius-md);
        margin: var(--space-lg) auto;
        border: 2px solid var(--color-border);
        cursor: pointer;
        transition: transform var(--transition-fast);
    }
    .color-preview:hover {
        transform: scale(1.05);
    }
    .color-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: var(--space-md);
        margin-top: var(--space-lg);
    }
    .color-info-item {
        background: var(--color-bg-secondary);
        padding: var(--space-md);
        border-radius: var(--radius-md);
        text-align: center;
    }

    .puzzle-container {
        max-width: 600px;
        margin: 0 auto;
    }
    .sudoku-grid {
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        gap: 1px;
        background: var(--color-border);
        border: 2px solid var(--color-border);
        margin-bottom: var(--space-lg);
    }
    .sudoku-cell {
        aspect-ratio: 1;
        background: var(--color-bg-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        border: none;
        color: var(--color-text-primary);
        transition: background-color var(--transition-fast);
    }
    .sudoku-cell:hover {
        background: var(--color-glass-bg);
    }
    .sudoku-cell.given {
        background: var(--color-primary);
        color: var(--color-bg-primary);
        cursor: default;
    }
    .sudoku-cell.conflict {
        background: var(--color-accent) !important;
        color: white !important;
    }

    .word-search-grid {
        display: grid;
        gap: 2px;
        background: var(--color-border);
        border: 2px solid var(--color-border);
        margin-bottom: var(--space-lg);
        font-family: monospace;
        font-size: 1.1rem;
    }
    .word-search-cell {
        aspect-ratio: 1;
        background: var(--color-bg-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        cursor: pointer;
        border: none;
        color: var(--color-text-primary);
        transition: background-color var(--transition-fast);
        user-select: none;
    }
    .word-search-cell:hover {
        background: var(--color-glass-bg);
    }
    .word-search-cell.found {
        background: var(--color-primary);
        color: var(--color-bg-primary);
    }
    .word-search-cell.selecting {
        background: var(--color-accent);
        color: white;
    }

    .memory-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: var(--space-sm);
        max-width: 400px;
        margin: 0 auto var(--space-lg);
    }
    .memory-card {
        aspect-ratio: 1;
        background: var(--color-bg-secondary);
        border: 2px solid var(--color-border);
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        cursor: pointer;
        transition: all var(--transition-fast);
        position: relative;
        overflow: hidden;
    }
    .memory-card:hover {
        transform: scale(1.05);
    }
    .memory-card.flipped {
        background: var(--color-primary);
        color: var(--color-bg-primary);
        transform: rotateY(180deg);
    }
    .memory-card.matched {
        background: var(--color-secondary);
        cursor: default;
        opacity: 0.7;
    }

    .quiz-question {
        background: var(--color-bg-secondary);
        padding: var(--space-lg);
        border-radius: var(--radius-md);
        margin-bottom: var(--space-lg);
        text-align: center;
    }
    .quiz-question h3 {
        font-size: 1.5rem;
        margin-bottom: var(--space-md);
        color: var(--color-primary);
    }
    .quiz-answers {
        display: grid;
        grid-template-columns: 1fr;
        gap: var(--space-sm);
        max-width: 400px;
        margin: 0 auto;
    }
    .quiz-answer {
        padding: var(--space-md);
        background: var(--color-glass-bg);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-fast);
        text-align: left;
    }
    .quiz-answer:hover {
        border-color: var(--color-primary);
        transform: translateX(5px);
    }
    .quiz-answer.correct {
        background: var(--color-secondary);
        border-color: var(--color-secondary);
        color: var(--color-bg-primary);
    }
    .quiz-answer.incorrect {
        background: var(--color-accent);
        border-color: var(--color-accent);
        color: white;
    }

    .hangman-display {
        text-align: center;
        margin-bottom: var(--space-lg);
    }
    .hangman-word {
        font-family: var(--font-display);
        font-size: 2.5rem;
        letter-spacing: 0.5rem;
        margin: var(--space-lg) 0;
        color: var(--color-primary);
    }
    .hangman-letters {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: var(--space-xs);
        max-width: 400px;
        margin: 0 auto;
    }
    .hangman-letter {
        aspect-ratio: 1;
        background: var(--color-bg-secondary);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        cursor: pointer;
        transition: all var(--transition-fast);
    }
    .hangman-letter:hover {
        background: var(--color-glass-bg);
        transform: scale(1.1);
    }
    .hangman-letter.guessed {
        opacity: 0.3;
        cursor: default;
    }
    .hangman-letter.correct {
        background: var(--color-secondary);
        color: var(--color-bg-primary);
    }
    .hangman-letter.incorrect {
        background: var(--color-accent);
        color: white;
    }

    .typing-test-area {
        background: var(--color-bg-secondary);
        border-radius: var(--radius-md);
        padding: var(--space-lg);
        margin-bottom: var(--space-lg);
    }
    .typing-text {
        font-size: 1.2rem;
        line-height: 1.6;
        margin-bottom: var(--space-md);
        font-family: monospace;
    }
    .typing-text .char.correct {
        background: var(--color-secondary);
        color: var(--color-bg-primary);
    }
    .typing-text .char.incorrect {
        background: var(--color-accent);
        color: white;
    }
    .typing-text .char.current {
        background: var(--color-primary);
        color: var(--color-bg-primary);
        animation: blink 1s infinite;
    }
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
    .typing-input {
        width: 100%;
        font-size: 1.2rem;
        font-family: monospace;
    }
    .typing-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: var(--space-md);
        margin-top: var(--space-lg);
    }

    /* --- RESPONSIVE DESIGN --- */
    @media (min-width: 768px) {
      #app {
        flex-direction: row;
      }
      
      .mobile-nav {
        display: none;
      }

      .desktop-nav {
        display: flex;
        flex-direction: column;
        width: 220px;
        padding: var(--space-lg);
        padding-top: calc(var(--header-height) + var(--space-lg));
        border-right: 1px solid var(--color-border);
        overflow-y: auto;
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        height: 100vh;
        z-index: 5;
      }

      .desktop-nav .nav-link {
        flex-direction: row;
        justify-content: flex-start;
        gap: var(--space-sm);
        padding: var(--space-sm);
        width: 100%;
        font-size: 1rem;
        border-radius: var(--radius-md);
      }

      .desktop-nav .nav-link:hover {
        background: var(--color-glass-bg);
        transform: translateY(0);
      }
       .desktop-nav .nav-link.active {
        background: var(--color-glass-bg);
        color: var(--color-primary);
      }

      .desktop-nav .nav-link span {
        display: block;
      }
      
      .app-header {
        width: calc(100% - 220px);
        left: 220px;
      }

      .main-content {
        padding-bottom: var(--space-lg);
        margin-left: 220px;
      }
      
      .tool-grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      }
      
      .digital-clock .time {
        font-size: 5rem;
      }
      
      .converter-row {
          grid-template-columns: 1fr auto 1fr;
      }
      .converter-swap-btn {
          margin: 0 var(--space-lg);
      }
      .tool-grid-2col {
          grid-template-columns: 1fr 1fr;
          align-items: start;
      }
      
      .markdown-previewer {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--space-lg);
        height: 60vh;
      }

      .memory-grid {
        grid-template-columns: repeat(6, 1fr);
        max-width: 600px;
      }

      .word-search-grid {
        font-size: 1.2rem;
      }

      .hangman-letters {
        grid-template-columns: repeat(8, 1fr);
        max-width: 600px;
      }
    }
  </style>
</head>
<body class="theme-neon-nights">
  <div id="app">
    <canvas id="particle-canvas"></canvas>
    <header class="app-header">
      <a href="#" class="logo" id="logo-link">
          <svg class="logo-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:var(--logo-color-start);"/>
                <stop offset="100%" style="stop-color:var(--logo-color-stop);"/>
              </linearGradient>
            </defs>
            <path d="M35.2,50c0,8.1,6.6,14.8,14.8,14.8s14.8-6.6,14.8-14.8c0-8.1-6.6-14.8-14.8-14.8S35.2,41.9,35.2,50z M50,25 C26.4,25,16.2,43.4,21.5,56.5C26.7,69.6,40,75,50,75c13.8,0,25-11.2,25-25c0-13.8-11.2-25-25-25V25z M50,25 C73.6,25,83.8,43.4,78.5,56.5C73.3,69.6,60,75,50,75c-13.8,0-25-11.2-25-25C25,36.2,36.2,25,50,25V25z" fill="none" stroke="url(#logoGradient)" stroke-width="5" transform="rotate(45 50 50)"/>
            <circle cx="20" cy="20" r="3" fill="url(#logoGradient)"/>
            <circle cx="80" cy="80" r="3" fill="url(#logoGradient)"/>
            <circle cx="20" cy="80" r="3" fill="url(#logoGradient)"/>
            <circle cx="80" cy="20" r="3" fill="url(#logoGradient)"/>
          </svg>
          <h1 class="logo-text">Infinity</h1>
      </a>
      <div class="theme-switcher">
        <label for="theme-select" class="sr-only">Select Theme</label>
        <select id="theme-select" aria-label="Select Theme">
          <option value="theme-neon-nights">Neon Nights</option>
          <option value="theme-royal-violet">Royal Violet</option>
          <option value="theme-solar-flare">Solar Flare</option>
          <option value="theme-arctic-aurora">Arctic Aurora</option>
          <option value="theme-cyberpunk-city">Cyberpunk City</option>
          <option value="theme-matrix-green">Matrix Green</option>
        </select>
      </div>
    </header>

    <nav id="desktop-nav" class="desktop-nav" aria-label="Desktop Navigation">
      <!-- Desktop navigation links will be populated by JS -->
    </nav>

    <main id="main-content" class="main-content">
      <div id="dashboard-view" class="view active">
        <div class="dashboard-header">
          <div class="search-container">
            <input type="search" id="search-input" placeholder="Search for any tool..." aria-label="Search for a tool">
            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
          </div>
          <div id="category-filters" class="category-filters">
            <!-- Category filter buttons populated by JS -->
          </div>
        </div>
        <div id="tool-grid-container">
          <!-- Tool categories and cards will be populated by JS -->
        </div>
      </div>
      <div id="tool-view" class="view">
        <button id="back-to-dashboard" class="back-button" aria-label="Back to dashboard">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
          <span>Back</span>
        </button>
        <div id="tool-container">
            <div id="tool-header" class="tool-header">
                <h2 id="tool-title">Tool Name</h2>
                <div class="tool-controls">
                    <button id="tool-expand-btn" aria-label="Expand/Collapse tool">
                        <svg class="expand-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 2h-2v3h-3v2h5v-5zm-2-4V5h-3v2h3v3h2V5h-2z"/></svg>
                        <svg class="collapse-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>
                    </button>
                </div>
            </div>
            <div id="tool-content" class="tool-content">
                <!-- Individual tool content will be rendered here -->
            </div>
        </div>
      </div>
    </main>

    <nav id="mobile-nav" class="mobile-nav" aria-label="Mobile Navigation">
       <!-- Mobile navigation links will be populated by JS -->
    </nav>
  </div>
  <script type="module">
    /**
     * @license
     * SPDX-License-Identifier: Apache-2.0
     */

    // --- DATA: TOOL DEFINITIONS ---
    const tools = [
      // Time & Date
      { id: 'digital-clock', name: 'Digital Clock', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>', description: 'Real-time digital clock display.' },
      { id: 'world-clock', name: 'World Clock', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>', description: 'Time across different timezones.' },
      { id: 'countdown-timer', name: 'Countdown', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 12h6l2-3 2 6 2-3h6"/></svg>', description: 'Set a timer to count down to an event.' },
      { id: 'stopwatch', name: 'Stopwatch', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="13" r="8"></circle><line x1="12" y1="5" x2="12" y2="8"></line><line x1="10" y1="1" x2="14" y2="1"></line></svg>', description: 'Measure elapsed time with lap functionality.' },
      { id: 'pomodoro-timer', name: 'Pomodoro', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><path d="M12 8v4l2 2"></path><path d="M18 2l4 4h-4v-4z"></path></svg>', description: 'Boost productivity with the Pomodoro technique.' },
      { id: 'age-calculator', name: 'Age Calculator', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 22V14a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v8"></path><path d="M2 18h20"></path><path d="M12 10a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"></path></svg>', description: 'Calculate precise age from a birthdate.' },
      { id: 'date-difference', name: 'Date Difference', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line><line x1="12" y1="14" x2="12" y2="18"></line><line x1="9" y1="16" x2="15" y2="16"></line></svg>', description: 'Calculate time between two dates.' },
      { id: 'calendar-generator', name: 'Calendar', category: 'Time & Date', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>', description: 'View a monthly calendar.' },
      
      // Conversion
      { id: 'length-converter', name: 'Length', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 6H3"/><path d="M21 12H3"/><path d="M21 18H3"/><path d="M6 3v18"/></svg>', description: 'Convert various units of length.' },
      { id: 'weight-converter', name: 'Weight', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8v12c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V8H6z"/><circle cx="12" cy="15" r="3"/><path d="M19 5L5 5"/></svg>', description: 'Convert various units of weight.' },
      { id: 'temp-converter', name: 'Temperature', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 4h-4v10.5a4 4 0 1 0 4 0V4z"/><path d="M10 4h4"/><circle cx="12" cy="18" r="1"/></svg>', description: 'Convert C, F, and K.' },
      { id: 'currency-converter', name: 'Currency', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1v22"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>', description: 'Convert world currencies.' },
      { id: 'volume-converter', name: 'Volume', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 8V4a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v4"/><path d="M3 10v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V10"/><path d="M3 10h18"/></svg>', description: 'Convert various units of volume.' },
      { id: 'speed-converter', name: 'Speed', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V2l-4 4 4 4z"/><path d="M12 16v6l4-4-4-4z"/><path d="M8 12H2l4-4-4-4z"/><path d="M16 12h6l-4 4 4 4z"/></svg>', description: 'Convert various units of speed.' },
      { id: 'area-converter', name: 'Area', category: 'Conversion', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3z"/><path d="M3 9h18"/><path d="M9 3v18"/></svg>', description: 'Convert various units of area.' },
      
      // Math & Finance
      { id: 'calculator', name: 'Calculator', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="8" y1="6" x2="16" y2="6"></line><line x1="8" y1="10" x2="16" y2="10"></line><line x1="8" y1="14" x2="16" y2="14"></line><line x1="8" y1="18" x2="16" y2="18"></line></svg>', description: 'Basic arithmetic calculations.' },
      { id: 'scientific-calculator', name: 'Scientific Calc', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"/><path d="M8 6h8"/><path d="M8 10h8"/><path d="M8 14h3"/><path d="M8 18h3"/><path d="M13 14h3"/><path d="M13 18h3"/></svg>', description: 'Advanced scientific calculations.' },
      { id: 'loan-calculator', name: 'Loan Calculator', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"/><circle cx="12" cy="12" r="3"/><path d="M12 5V2"/><path d="M12 22v-3"/><path d="M17 7l2-2"/><path d="M5 19l2-2"/></svg>', description: 'Calculate loan & mortgage payments.' },
      { id: 'compound-interest-calculator', name: 'Compound Int.', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/><path d="M12 1v4"/><path d="M12 18v4"/></svg>', description: 'Calculate compound interest growth.' },
      { id: 'savings-calculator', name: 'Savings Calc', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h3M18 12h3M12 3v3M12 18v3"/><circle cx="12" cy="12" r="7"/><path d="M9 12h6"/></svg>', description: 'Plan your savings goals.' },
      { id: 'roi-calculator', name: 'ROI Calculator', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M12 12l4-4M12 12l-4 4"/></svg>', description: 'Calculate Return on Investment.' },
      { id: 'tip-calculator', name: 'Tip Calculator', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2H7C5.9 2 5 2.9 5 4v16c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/><path d="M12 18h.01"/><path d="M7 6h10"/><path d="M7 10h10"/><path d="M7 14h5"/></svg>', description: 'Calculate tips & split bills easily.' },
      { id: 'percentage-calculator', name: 'Percentage Calc', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle></svg>', description: 'Quickly calculate percentages.' },
      { id: 'number-base-converter', name: 'Number Base', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 17l5-5-5-5M4 17h17"/></svg>', description: 'Convert DEC, BIN, HEX, OCT.' },
      { id: 'bmi-calculator', name: 'BMI Calculator', category: 'Math & Finance', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M12 12l4-4"/><path d="M8 12l4 4"/></svg>', description: 'Calculate Body Mass Index.' },
      
      // Text & Writing
      { id: 'word-counter', name: 'Word Counter', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 5H7a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"></path><path d="M9 9h6v6H9z"></path></svg>', description: 'Count words, characters, and sentences.' },
      { id: 'qr-code-generator', name: 'QR Generator', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect></svg>', description: 'Create custom QR codes.' },
      { id: 'password-generator', name: 'Password Gen', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>', description: 'Generate secure, random passwords.' },
      { id: 'markdown-previewer', name: 'Markdown Preview', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>', description: 'Live preview for Markdown text.' },
      { id: 'case-converter', name: 'Case Converter', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/><path d="M12 9v6"/><path d="M9 12h6"/></svg>', description: 'Convert text case (upper, lower, etc.).' },
      { id: 'lorem-ipsum-generator', name: 'Lorem Ipsum', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>', description: 'Generate placeholder text.' },
      { id: 'text-reverser', name: 'Text Reverser', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v2h6v10h2V9h6V7H3z"/><path d="M17 17l4-4-4-4"/></svg>', description: 'Reverse any string of text.' },
      { id: 'text-sorter', name: 'Text Sorter', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 15v-6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v6"/><path d="M21 15l-3-3-3 3"/><path d="M3 9l3 3 3-3"/></svg>', description: 'Sort lines of text alphabetically.' },
      { id: 'base64-coder', name: 'Base64 Coder', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"/></svg>', description: 'Encode/decode Base64 strings.' },
      { id: 'url-coder', name: 'URL Coder', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>', description: 'Encode/decode URL components.' },
      { id: 'slugify-text', name: 'Slugify Text', category: 'Text & Writing', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>', description: 'Convert text into a URL-friendly slug.' },

      // Internet & Networking
      { id: 'ip-finder', name: 'IP Finder', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M2 12h20"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>', description: 'Find your public IP and location.' },
      { id: 'ping-tool', name: 'Ping Tool', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.59 13.41l-1.17-1.17a2 2 0 0 0-2.83 0L12 17.83l-5.59-5.59a2 2 0 0 0-2.83 0L2.41 13.4a2 2 0 0 0 0 2.83l9.19 9.19a2 2 0 0 0 2.83 0l9.19-9.19a2 2 0 0 0 0-2.83z"/><path d="M12 2L2 7l10 5 10-5-10-5z"/></svg>', description: 'Measure latency to a host (simulation).' },
      { id: 'port-scanner', name: 'Port Scanner', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/><path d="M12 12h.01"/></svg>', description: 'Check common ports (simulation).' },
      { id: 'whois-lookup', name: 'WHOIS Lookup', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M1.05 12H7"/><path d="M17.01 12h5.95"/><path d="M12 1.05V7"/><path d="M12 17.01v5.95"/></svg>', description: 'Get domain registration info.' },
      { id: 'url-shortener', name: 'URL Tools', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"/></svg>', description: 'Shorten or expand URLs.' },
      { id: 'base32-coder', name: 'Base32 Coder', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg>', description: 'Encode/decode Base32 strings.' },
      { id: 'morse-code', name: 'Morse Code', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18" cy="12" r="1"/><path d="M4 12h1m4 0h2m4 0h1"/></svg>', description: 'Translate and play Morse code.' },
      { id: 'text-encrypt', name: 'Encrypt/Decrypt', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>', description: 'Secure text with AES encryption.' },
      { id: 'hash-generator', name: 'Hash Generator', category: 'Internet & Networking', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>', description: 'Generate cryptographic hashes.' },

      // Utilities
      { id: 'unit-converter-hub', name: 'Converter Hub', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12h-4"/><path d="M4 12h4"/><path d="M12 20v-4"/><path d="M12 4v4"/><circle cx="12" cy="12" r="8"/></svg>', description: 'Convert a value to multiple units.' },
      { id: 'battery-status', name: 'Battery Status', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"/><path d="M9 14h6"/><path d="M9 18h6"/><path d="M18 6h2v12h-2z"/></svg>', description: 'Check device battery status.' },
      { id: 'clipboard-manager', name: 'Clipboard', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>', description: 'View and manage clipboard history.' },
      { id: 'notes-app', name: 'Notes', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>', description: 'Simple, persistent notepad.' },
      { id: 'todo-list', name: 'To-Do List', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>', description: 'Track your tasks.' },
      { id: 'reminder-app', name: 'Reminder', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>', description: 'Set browser notifications.' },
      { id: 'weather-app', name: 'Weather', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 17a5 5 0 0 0-10 0"/><path d="M12 5a5 5 0 0 0-10 0"/><path d="M2 12h20"/><path d="M12 2v20"/></svg>', description: 'Get current weather conditions.' },
      { id: 'sound-meter', name: 'Sound Meter', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v8m4-4H8"/><path d="M20 12a8 8 0 1 1-16 0 8 8 0 0 1 16 0z"/></svg>', description: 'Measure real-time sound levels.' },
      { id: 'compass', name: 'Compass', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polygon points="12 2 15 12 12 22 9 12 12 2"/></svg>', description: 'Find your heading.' },
      { id: 'screen-light', name: 'Screen Light', category: 'Utilities', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>', description: 'Use your screen as a light source.' },

      // Device Tools
      { id: 'device-info-viewer', name: 'Device Info', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12" y2="18"/></svg>', description: 'View detailed device information and specs.' },
      { id: 'storage-check', name: 'Storage Check', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>', description: 'Check available storage space and usage.' },
      { id: 'speed-test', name: 'Speed Test', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="6" x2="12" y2="16"/></svg>', description: 'Test your internet connection speed.' },
      { id: 'screen-ruler', name: 'Screen Ruler', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 3H3v18h18V3z"/><path d="M3 9h18"/><path d="M9 3v18"/></svg>', description: 'Measure distances and elements on screen.' },
      { id: 'color-picker', name: 'Color Picker', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3 6 6 3-3 6-6 3-3-6-6-3 3-6 6-3z"/><circle cx="12" cy="12" r="3"/></svg>', description: 'Pick colors and get color codes.' },
      { id: 'screen-splitter', name: 'Screen Splitter', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="12" y1="3" x2="12" y2="21"/></svg>', description: 'Split screen view for productivity.' },
      { id: 'clipboard-viewer', name: 'Clipboard Viewer', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>', description: 'Monitor clipboard content in real-time.' },
      { id: 'theme-detector', name: 'Theme Detector', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>', description: 'Detect system theme and preferences.' },
      { id: 'mic-tester', name: 'Mic Tester', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>', description: 'Test microphone input and levels.' },
      { id: 'camera-preview', name: 'Camera Preview', category: 'Device Tools', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>', description: 'Preview camera feed and test functionality.' },

      // Puzzle Games
      { id: 'sudoku', name: 'Sudoku', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/></svg>', description: 'Classic number puzzle with difficulty levels.' },
      { id: 'crossword', name: 'Crossword', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>', description: 'Word puzzle with clues and hints.' },
      { id: 'word-search', name: 'Word Search', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/><rect x="8" y="8" width="6" height="6"/></svg>', description: 'Find hidden words in letter grid.' },
      { id: 'math-quiz', name: 'Math Quiz', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>', description: 'Test your math skills with timed quizzes.' },
      { id: 'memory-match', name: 'Memory Match', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.29 1.51 4.04 3 5.5l7 7Z"/></svg>', description: 'Match pairs of cards to test memory.' },
      { id: 'pattern-lock-puzzle', name: 'Pattern Lock', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><circle cx="12" cy="16" r="1"/></svg>', description: 'Create and solve pattern lock puzzles.' },
      { id: 'logic-riddles', name: 'Logic Riddles', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>', description: 'Solve challenging logic puzzles and riddles.' },
      { id: 'hangman', name: 'Hangman', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>', description: 'Classic word guessing game.' },
      { id: 'typing-test', name: 'Typing Test', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"/><circle cx="12" cy="12" r="2"/><path d="M6 12h.01M18 12h.01"/></svg>', description: 'Test and improve typing speed and accuracy.' },
      { id: 'spelling-bee', name: 'Spelling Bee', category: 'Puzzle Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>', description: 'Spell words correctly to advance levels.' },

      // Mini Games
      { id: 'snake-classic', name: 'Snake Classic', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/><circle cx="12" cy="12" r="2"/></svg>', description: 'Classic snake game with neon effects and levels.' },
      { id: 'neon-flappy', name: 'Neon Flappy', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2z"/><path d="M8 12l4-4 4 4"/></svg>', description: 'Flappy bird with cyberpunk graphics and obstacles.' },
      { id: '2048-fusion', name: '2048 Fusion', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>', description: 'Merge tiles to reach 2048 with glowing effects.' },
      { id: 'laser-breaker', name: 'Laser Breaker', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="4" height="2"/><rect x="8" y="2" width="4" height="2"/><rect x="14" y="2" width="4" height="2"/><rect x="20" y="2" width="2" height="2"/><path d="M12 22v-8"/><path d="M8 14h8"/></svg>', description: 'Break bricks with power-ups and boss levels.' },
      { id: 'cosmic-defender', name: 'Cosmic Defender', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2 7h7l-5.5 4.5 2 7L12 16l-5.5 4.5 2-7L3 9h7z"/></svg>', description: 'Space shooter with weapon upgrades and bosses.' },
      { id: 'pixel-sweeper', name: 'Pixel Sweeper', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 9h.01M15 9h.01M9 15h.01M15 15h.01M12 12h.01"/></svg>', description: 'Minesweeper with neon aesthetics and challenges.' },
      { id: 'pacman-neon', name: 'Pac-Man Neon', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 12l8-5"/><path d="M12 12l8 5"/></svg>', description: 'Classic Pac-Man with glowing maze and ghosts.' },
      { id: 'tetris-dimension', name: 'Tetris Dimension', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="4" height="4"/><rect x="4" y="6" width="4" height="4"/><rect x="8" y="6" width="4" height="4"/><rect x="8" y="10" width="4" height="4"/></svg>', description: 'Tetris with multiple modes and ghost pieces.' },
      { id: 'pong-evolution', name: 'Pong Evolution', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="2" height="10"/><rect x="20" y="7" width="2" height="10"/><circle cx="12" cy="12" r="2"/></svg>', description: 'Pong with power-ups and AI difficulty levels.' },
      { id: 'fruit-slash', name: 'Fruit Slash', category: 'Mini Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20M2 12h20"/><circle cx="12" cy="12" r="3"/></svg>', description: 'Slice flying fruits with multiple game modes.' },

      // Board Games
      { id: 'quantum-chess', name: 'Quantum Chess', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3h8M9 3v2M15 3v2M5 6h14M6 8h12v12H6z"/><path d="M9 11h6M9 14h6"/></svg>', description: 'Holographic chess with AI opponents and temporal view.' },
      { id: 'neon-checkers', name: 'Neon Checkers', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8" cy="8" r="2"/><circle cx="16" cy="16" r="2"/><path d="M8 16l8-8"/></svg>', description: 'Vibrant checkers with multi-jump combos and AI levels.' },
      { id: 'ludo-legacy', name: 'Ludo Legacy', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="1"/><rect x="13" y="2" width="9" height="9" rx="1"/><rect x="2" y="13" width="9" height="9" rx="1"/><rect x="13" y="13" width="9" height="9" rx="1"/><circle cx="12" cy="12" r="3"/></svg>', description: 'Cosmic ludo with spacecraft tokens and AI opponents.' },
      { id: 'backgammon-masters', name: 'Backgammon Masters', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3z"/><path d="M12 3v18M3 8l9-5M21 8l-9-5M3 16l9 5M21 16l-9 5"/></svg>', description: 'Luxury backgammon with doubling cube and ranked ladder.' },
      { id: 'reversi-strategy', name: 'Reversi Strategy', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="9" cy="9" r="2" fill="currentColor"/><circle cx="15" cy="15" r="2"/></svg>', description: 'Minimalist Othello with wave flip animations.' },
      { id: 'connect-four', name: '4-in-a-Row Challenge', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8" cy="8" r="1.5"/><circle cx="12" cy="8" r="1.5"/><circle cx="16" cy="8" r="1.5"/><circle cx="8" cy="12" r="1.5"/><circle cx="12" cy="12" r="1.5"/><circle cx="16" cy="12" r="1.5"/><circle cx="8" cy="16" r="1.5"/><circle cx="12" cy="16" r="1.5"/><circle cx="16" cy="16" r="1.5"/></svg>', description: 'Connect four with perfect AI and special disc powers.' },
      { id: 'go-ancient', name: 'Go - The Ancient Game', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="1"/><line x1="6" y1="2" x2="6" y2="22"/><line x1="10" y1="2" x2="10" y2="22"/><line x1="14" y1="2" x2="14" y2="22"/><line x1="18" y1="2" x2="18" y2="22"/><line x1="2" y1="6" x2="22" y2="6"/><line x1="2" y1="10" x2="22" y2="10"/><line x1="2" y1="14" x2="22" y2="14"/><line x1="2" y1="18" x2="22" y2="18"/><circle cx="6" cy="10" r="1.5" fill="currentColor"/><circle cx="18" cy="14" r="1.5"/></svg>', description: 'Traditional Go with Zen aesthetics and Kyu/Dan ranks.' },
      { id: 'scrabble-master', name: 'Scrabble Master', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><text x="12" y="16" text-anchor="middle" font-size="10" fill="currentColor">A</text></svg>', description: 'Word game with vast AI vocabulary and tile themes.' },
      { id: 'mahjong-deluxe', name: 'Mahjong Solitaire Deluxe', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="5" height="7" rx="1"/><rect x="9.5" y="6" width="5" height="7" rx="1"/><rect x="16" y="6" width="5" height="7" rx="1"/><rect x="6" y="11" width="5" height="7" rx="1"/><rect x="12.5" y="11" width="5" height="7" rx="1"/></svg>', description: 'Stunning 3D tile sets with 100+ layouts.' },
      { id: 'battleship-command', name: 'Battleship Fleet Command', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h20M2 8h20M2 16h20"/><path d="M8 4l4 4 4-4"/><circle cx="12" cy="12" r="1" fill="currentColor"/></svg>', description: 'Naval warfare with tactical display and campaign mode.' },
      { id: 'catan-universe', name: 'Catan Universe', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l9.5 5.5v11L12 24l-9.5-6.5v-11z"/><path d="M12 2v8m0 6v8M2.5 7.5l9.5 5.5m0 0l9.5-5.5M12 13l-9.5 5.5M12 13l9.5 5.5"/></svg>', description: 'Living island board with resource trading and settlements.' },
      { id: 'ticket-to-ride', name: 'Ticket to Ride', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="8" width="20" height="8" rx="2"/><circle cx="7" cy="16" r="2"/><circle cx="17" cy="16" r="2"/><path d="M2 10h20M2 14h20"/></svg>', description: 'Build train routes across beautiful vintage maps.' },
      { id: 'uno-quantum', name: 'Uno: Quantum Shift', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/><path d="M4 12h16M12 4v16"/><circle cx="8" cy="8" r="1.5" fill="currentColor"/><circle cx="16" cy="16" r="1.5" fill="currentColor"/></svg>', description: 'Dynamic color-shifting card game with action effects.' },
      { id: 'clue-mansion', name: 'Clue: Mystery Mansion', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><path d="M9 22V12h6v10"/></svg>', description: '3D Victorian mansion mystery with deductive gameplay.' },
      { id: 'stratego-tactical', name: 'Stratego: Tactical Command', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="1"/><path d="M9 3v18M15 3v18M3 9h18M3 15h18"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>', description: 'Strategic battlefield with hidden army formations.' },
      { id: 'chinese-checkers', name: 'Chinese Checkers: Starlight', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.4 7.2h7.6l-6 4.8 2.4 7.2-6-4.8-6 4.8 2.4-7.2-6-4.8h7.6z"/></svg>', description: 'Constellation board with nebula marbles in space.' },
      { id: 'abalone-force', name: 'Abalone: Force & Strategy', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>', description: 'Marble pushing tactics on luxurious hex board.' },
      { id: 'nine-mens-morris', name: '9 Men\'s Morris: Ancient Stones', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18"/><rect x="7" y="7" width="10" height="10"/><rect x="11" y="11" width="2" height="2"/><path d="M12 3v8m0 2v8M3 12h8m2 0h8"/></svg>', description: 'Celtic stone board with mystical mill formations.' },
      { id: 'the-duke', name: 'The Duke: Dynamic Warfare', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3h8M9 3v2M15 3v2M5 6h14M6 8h12v12H6z"/><path d="M10 12h4M12 10v4"/></svg>', description: 'Dual-sided military units with flip mechanics.' },
      { id: 'hive-empire', name: 'Hive: Insect Empire', category: 'Board Games', svgIcon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/><circle cx="12" cy="12" r="2"/></svg>', description: 'Hexagonal insect pieces building organic hives.' }
    ];

    const categoryOrder = [ 'Favorites', 'Time & Date', 'Conversion', 'Math & Finance', 'Text & Writing', 'Internet & Networking', 'Utilities', 'Device Tools', 'Puzzle Games', 'Mini Games', 'Board Games' ];
    
    const categories = [...new Set(tools.map(t => t.category))];

    // --- DOM ELEMENT SELECTORS ---
    const a = {
      body: document.body,
      app: document.getElementById('app'),
      themeSelect: document.getElementById('theme-select'),
      searchInput: document.getElementById('search-input'),
      toolGridContainer: document.getElementById('tool-grid-container'),
      dashboardView: document.getElementById('dashboard-view'),
      toolView: document.getElementById('tool-view'),
      toolContainer: document.getElementById('tool-container'),
      toolContent: document.getElementById('tool-content'),
      toolTitle: document.getElementById('tool-title'),
      backButton: document.getElementById('back-to-dashboard'),
      desktopNav: document.getElementById('desktop-nav'),
      mobileNav: document.getElementById('mobile-nav'),
      particleCanvas: document.getElementById('particle-canvas'),
      categoryFilters: document.getElementById('category-filters'),
      toolExpandBtn: document.getElementById('tool-expand-btn'),
      logoLink: document.getElementById('logo-link'),
    };

    // --- STATE MANAGEMENT ---
    let currentToolInterval = null;
    let audioContext = null;
    let soundMeter = { analyser: null, stream: null, animationFrameId: null };

    let state = {
      textFilter: '',
      categoryFilter: 'All',
      clockFormat24: true,
      favorites: [],
    };

    // --- RENDER FUNCTIONS ---
    function renderDashboard() {
      if (!a.toolGridContainer) return;
      a.toolGridContainer.innerHTML = '';
      const { textFilter, categoryFilter, favorites } = state;
      const normalizedFilter = textFilter.toLowerCase();

      const filteredTools = tools.filter(tool => {
          const matchesCategory = categoryFilter === 'All' || tool.category === categoryFilter;
          const matchesText = normalizedFilter === '' ||
            tool.name.toLowerCase().includes(normalizedFilter) ||
            tool.category.toLowerCase().includes(normalizedFilter) ||
            tool.description.toLowerCase().includes(normalizedFilter);
          return matchesCategory && matchesText;
      });

      const toolsByCategory = filteredTools.reduce((acc, tool) => {
        if (!acc[tool.category]) {
          acc[tool.category] = [];
        }
        acc[tool.category].push(tool);
        return acc;
      }, {});

      // Add favorites category if it exists
      const favoriteTools = tools.filter(t => favorites.includes(t.id) && filteredTools.includes(t));
      if (favoriteTools.length > 0 && (categoryFilter === 'All' || categoryFilter === 'Favorites') && textFilter === '') {
        toolsByCategory['Favorites'] = favoriteTools;
      }


      for (const category of categoryOrder) {
        if (toolsByCategory[category]) {
          const categoryContainer = document.createElement('div');
          categoryContainer.className = 'category-container';
          categoryContainer.innerHTML = `<h2 class="category-title">${category}</h2>`;

          const grid = document.createElement('div');
          grid.className = 'tool-grid';

          toolsByCategory[category].forEach(tool => {
            const isFavorited = favorites.includes(tool.id);
            const card = document.createElement('div');
            card.className = 'tool-card';
            card.dataset.toolId = tool.id;
            card.innerHTML = `
              <button class="favorite-btn ${isFavorited ? 'favorited' : ''}" aria-label="Toggle Favorite">
                  <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
              </button>
              <div class="tool-icon" aria-hidden="true">${tool.svgIcon}</div>
              <h3>${tool.name}</h3>
              <p>${tool.description}</p>
            `;
            card.querySelector('.favorite-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFavorite(tool.id);
            });
            card.addEventListener('click', () => openTool(tool.id));
            grid.appendChild(card);
          });
          categoryContainer.appendChild(grid);
          a.toolGridContainer.appendChild(categoryContainer);
        }
      }
    }

    function renderCategoryFilters() {
        if (!a.categoryFilters) return;
        a.categoryFilters.innerHTML = '';
        ['All', 'Favorites', ...categories].forEach(category => {
            const btn = document.createElement('button');
            btn.className = 'category-filter-btn';
            btn.textContent = category;
            if (category === state.categoryFilter) {
                btn.classList.add('active');
            }
            btn.addEventListener('click', () => {
                state.categoryFilter = category;
                document.querySelector('.category-filter-btn.active')?.classList.remove('active');
                btn.classList.add('active');
                renderDashboard();
            });
            a.categoryFilters.appendChild(btn);
        });
    }

    function renderNavigation() {
        if (!a.desktopNav || !a.mobileNav) return;
        a.desktopNav.innerHTML = '';
        a.mobileNav.innerHTML = '';
        
        const navCategories = categoryOrder.filter(c => c !== 'Favorites');

        navCategories.forEach(category => {
            const tool = tools.find(t => t.category === category); // Get first tool for icon
            const button = document.createElement('a');
            button.href = '#';
            button.className = 'nav-link';
            button.dataset.category = category;
            button.innerHTML = `
                ${tool ? tool.svgIcon : ''}
                <span>${category}</span>
            `;
            
            const eventListener = (e) => {
                e.preventDefault();
                showDashboard();
                state.categoryFilter = category;
                renderCategoryFilters();
                renderDashboard();
                setTimeout(() => {
                    const matchingTitle = Array.from(document.querySelectorAll('.category-title')).find(el => el.textContent === category);
                    matchingTitle?.scrollIntoView({ behavior: 'smooth' });
                }, 100);
            };

            const desktopButton = button.cloneNode(true);
            desktopButton.addEventListener('click', eventListener);
            a.desktopNav.appendChild(desktopButton);

            const mobileButton = button.cloneNode(true);
            mobileButton.addEventListener('click', eventListener);
            a.mobileNav.appendChild(mobileButton);
        });
    }

    function toggleFavorite(toolId) {
        const index = state.favorites.indexOf(toolId);
        if (index > -1) {
            state.favorites.splice(index, 1);
        } else {
            state.favorites.push(toolId);
        }
        localStorage.setItem('infinity-tool-hub-favorites', JSON.stringify(state.favorites));
        renderDashboard();
    }


    // --- =============================== ---
    // --- TOOL IMPLEMENTATIONS START HERE ---
    // --- =============================== ---

    // --- TIME & DATE TOOLS ---

    function renderDigitalClock() {
      if (!a.toolContent) return;
      a.toolContent.innerHTML = `
        <div class="digital-clock">
          <div id="clock-time" class="time"></div>
          <div id="clock-date" class="date"></div>
          <div class="tool-controls-grid">
            <button id="clock-format-toggle" class="tool-button tool-button-secondary"></button>
          </div>
        </div>
      `;
      const timeEl = document.getElementById('clock-time');
      const dateEl = document.getElementById('clock-date');
      const toggleBtn = document.getElementById('clock-format-toggle');

      function updateClock() {
        const now = new Date();
        const timeOptions = {
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: !state.clockFormat24
        };
        const timeString = now.toLocaleTimeString([], timeOptions);
        const dateString = now.toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        if(timeEl) timeEl.textContent = timeString;
        if(dateEl) dateEl.textContent = dateString;
      }

      function updateButtonText() {
        if (toggleBtn) toggleBtn.textContent = `Switch to ${state.clockFormat24 ? '12-Hour' : '24-Hour'}`;
      }
      
      toggleBtn?.addEventListener('click', () => {
          state.clockFormat24 = !state.clockFormat24;
          updateButtonText();
          updateClock();
      });
      
      updateButtonText();
      updateClock();
      currentToolInterval = setInterval(updateClock, 1000);
    }
    
    function renderWorldClock() {
        const timezones = {
            'New York': 'America/New_York', 'London': 'Europe/London', 'Paris': 'Europe/Paris',
            'Tokyo': 'Asia/Tokyo', 'Sydney': 'Australia/Sydney', 'Dubai': 'Asia/Dubai',
            'Moscow': 'Europe/Moscow', 'Los Angeles': 'America/Los_Angeles'
        };
        let displayedClocks = ['New York', 'London', 'Tokyo'];

        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="world-clock-adder">
                <select id="city-select" class="tool-select" aria-label="Select a city"></select>
                <button id="add-city-btn" class="tool-button">Add Clock</button>
            </div>
            <div id="world-clock-list"></div>
        `;

        const select = document.getElementById('city-select');
        const list = document.getElementById('world-clock-list');
        
        function updateClocks() {
            if (!list) return;
            list.innerHTML = '';
            displayedClocks.forEach(city => {
                const tz = timezones[city];
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', { timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: true });
                const dateString = now.toLocaleDateString('en-US', { timeZone: tz, weekday: 'short', month: 'short', day: 'numeric' });

                const card = document.createElement('div');
                card.className = 'world-clock-card';
                card.innerHTML = `
                    <div class="info">
                        <div class="city">${city}</div>
                        <div class="date">${dateString}</div>
                    </div>
                    <div class="time">${timeString}</div>
                    <button class="remove-btn" data-city="${city}" aria-label="Remove ${city}"></button>
                `;
                list.appendChild(card);
            });
            
            list.querySelectorAll('.remove-btn').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   const cityToRemove = e.currentTarget.dataset.city;
                   displayedClocks = displayedClocks.filter(c => c !== cityToRemove);
                   updateClocks();
               });
            });
        }

        Object.keys(timezones).forEach(city => {
            const option = document.createElement('option');
            option.value = city;
            option.textContent = city;
            select?.appendChild(option);
        });

        document.getElementById('add-city-btn')?.addEventListener('click', () => {
            if (!select) return;
            const selectedCity = select.value;
            if (!displayedClocks.includes(selectedCity)) {
                displayedClocks.push(selectedCity);
                updateClocks();
            }
        });

        updateClocks();
        currentToolInterval = setInterval(updateClocks, 1000 * 30);
    }

    function renderCountdownTimer() {
        let targetDate;
        let paused = false;
        
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label for="countdown-datetime">Set Target Date & Time</label>
                <input type="datetime-local" id="countdown-datetime" class="tool-input">
            </div>
            <div id="countdown-display" class="timer-display countdown-display"></div>
            <div class="tool-controls-grid">
                <button id="countdown-start" class="tool-button">Start</button>
                <button id="countdown-pause" class="tool-button tool-button-secondary">Pause</button>
                <button id="countdown-reset" class="tool-button tool-button-secondary">Reset</button>
            </div>
        `;
        
        const display = document.getElementById('countdown-display');
        const input = document.getElementById('countdown-datetime');

        function updateDisplay() {
            if (!targetDate || paused || !display) return;
            const distance = targetDate.getTime() - new Date().getTime();

            if (distance <= 0) {
                display.innerHTML = `<div class="unit"><span class="value"></span><span class="label">Finished!</span></div>`;
                if (currentToolInterval) clearInterval(currentToolInterval);
                currentToolInterval = null;
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            display.innerHTML = `
                <div class="unit"><span class="value">${days}</span><span class="label">Days</span></div>
                <div class="unit"><span class="value">${hours}</span><span class="label">Hours</span></div>
                <div class="unit"><span class="value">${minutes}</span><span class="label">Mins</span></div>
                <div class="unit"><span class="value">${seconds}</span><span class="label">Secs</span></div>
            `;
        }

        document.getElementById('countdown-start')?.addEventListener('click', () => {
            if (!input?.value) return alert('Please select a target date and time.');
            targetDate = new Date(input.value);
            paused = false;
            if (currentToolInterval) clearInterval(currentToolInterval);
            currentToolInterval = setInterval(updateDisplay, 1000);
        });
        
        document.getElementById('countdown-pause')?.addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('countdown-reset')?.addEventListener('click', () => {
            if (currentToolInterval) clearInterval(currentToolInterval);
            currentToolInterval = null;
            targetDate = null;
            paused = false;
            if (input) input.value = '';
            if (display) display.innerHTML = '';
        });
    }

    function renderStopwatch() {
        let startTime = 0, elapsedTime = 0, lapStartTime = 0, lapCount = 0;
        let running = false;
        let animationFrameId = null;
        
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div id="stopwatch-display" class="timer-display stopwatch-display">00:00:00.000</div>
            <div class="tool-controls-grid">
                <button id="stopwatch-start" class="tool-button">Start</button>
                <button id="stopwatch-lap" class="tool-button tool-button-secondary">Lap</button>
                <button id="stopwatch-reset" class="tool-button tool-button-secondary">Reset</button>
            </div>
            <div class="stopwatch-laps">
                <table id="laps-table"></table>
            </div>
        `;
        
        const display = document.getElementById('stopwatch-display');
        const startBtn = document.getElementById('stopwatch-start');
        const lapsTable = document.getElementById('laps-table');
        
        function formatTime(ms) {
            const date = new Date(ms);
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            const seconds = date.getUTCSeconds().toString().padStart(2, '0');
            const milliseconds = date.getUTCMilliseconds().toString().padStart(3, '0');
            return `${minutes}:${seconds}.${milliseconds}`;
        }

        function update() {
            if (!running || !display) return;
            elapsedTime = Date.now() - startTime;
            display.textContent = formatTime(elapsedTime);
            animationFrameId = requestAnimationFrame(update);
        }

        startBtn?.addEventListener('click', () => {
            running = !running;
            if (running) {
                startTime = Date.now() - elapsedTime;
                if (!lapStartTime) lapStartTime = startTime;
                startBtn.textContent = 'Stop';
                startBtn.classList.remove('tool-button-secondary');
                animationFrameId = requestAnimationFrame(update);
            } else {
                startBtn.textContent = 'Start';
                startBtn.classList.add('tool-button-secondary');
                cancelAnimationFrame(animationFrameId);
            }
        });

        document.getElementById('stopwatch-reset')?.addEventListener('click', () => {
            running = false;
            cancelAnimationFrame(animationFrameId);
            elapsedTime = 0;
            lapCount = 0;
            lapStartTime = 0;
            if (display) display.textContent = formatTime(0);
            if (startBtn) startBtn.textContent = 'Start';
            if (lapsTable) lapsTable.innerHTML = '';
        });

        document.getElementById('stopwatch-lap')?.addEventListener('click', () => {
            if (!running || !lapsTable) return;
            lapCount++;
            const now = Date.now();
            const lapTime = now - lapStartTime;
            lapStartTime = now;
            const row = lapsTable.insertRow(0);
            row.innerHTML = `<td>Lap ${lapCount}</td><td>${formatTime(lapTime)}</td>`;
            if (lapsTable.rows.length === 1) {
                 const header = lapsTable.createTHead();
                 header.insertRow(0).innerHTML = `<th>Lap</th><th>Time</th>`;
            }
        });
    }

    function renderPomodoroTimer() {
        let pomodoroState = {
            mode: 'work', timeLeft: 25 * 60, running: false, sessions: 0,
            durations: { work: 25, short: 5, long: 15 }
        };

        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="pomodoro-timer">
                <div id="pomodoro-status" class="status">Time to Work!</div>
                <div id="pomodoro-display" class="timer-display">25:00</div>
                <div class="tool-controls-grid">
                    <button id="pomodoro-start" class="tool-button">Start</button>
                    <button id="pomodoro-reset" class="tool-button tool-button-secondary">Reset</button>
                </div>
                <div class="config">
                    <label>Work: <input type="number" id="work-duration" class="tool-input" value="25" min="1"> mins</label>
                    <label>Short Break: <input type="number" id="short-duration" class="tool-input" value="5" min="1"> mins</label>
                    <label>Long Break: <input type="number" id="long-duration" class="tool-input" value="15" min="1"> mins</label>
                </div>
            </div>
        `;
        
        const display = document.getElementById('pomodoro-display');
        const statusEl = document.getElementById('pomodoro-status');
        const startBtn = document.getElementById('pomodoro-start');

        function updateDisplay() {
            if (!display) return;
            const minutes = Math.floor(pomodoroState.timeLeft / 60).toString().padStart(2, '0');
            const seconds = (pomodoroState.timeLeft % 60).toString().padStart(2, '0');
            display.textContent = `${minutes}:${seconds}`;
        }
        
        function switchMode() {
            if (!startBtn || !statusEl) return;
            pomodoroState.running = false;
            startBtn.textContent = 'Start';
            if (pomodoroState.mode === 'work') {
                pomodoroState.sessions++;
                pomodoroState.mode = (pomodoroState.sessions % 4 === 0) ? 'long' : 'short';
                statusEl.textContent = (pomodoroState.mode === 'long') ? 'Time for a Long Break!' : 'Time for a Short Break!';
            } else {
                pomodoroState.mode = 'work';
                statusEl.textContent = 'Time to Work!';
            }
            pomodoroState.timeLeft = pomodoroState.durations[pomodoroState.mode] * 60;
            updateDisplay();
        }
        
        function tick() {
            if (!pomodoroState.running) return;
            pomodoroState.timeLeft--;
            updateDisplay();
            if (pomodoroState.timeLeft <= 0) {
                switchMode();
            }
        }

        startBtn?.addEventListener('click', () => {
            pomodoroState.running = !pomodoroState.running;
            startBtn.textContent = pomodoroState.running ? 'Pause' : 'Start';
            if (pomodoroState.running && !currentToolInterval) {
                currentToolInterval = setInterval(tick, 1000);
            } else if (!pomodoroState.running && currentToolInterval) {
                clearInterval(currentToolInterval);
                currentToolInterval = null;
            }
        });
        
        document.getElementById('pomodoro-reset')?.addEventListener('click', () => {
            if (currentToolInterval) clearInterval(currentToolInterval);
            currentToolInterval = null;
            pomodoroState.running = false;
            pomodoroState.mode = 'work';
            pomodoroState.timeLeft = pomodoroState.durations.work * 60;
            if (startBtn) startBtn.textContent = 'Start';
            if (statusEl) statusEl.textContent = 'Time to Work!';
            updateDisplay();
        });
        
        ['work', 'short', 'long'].forEach(d => {
            document.getElementById(`${d}-duration`)?.addEventListener('change', (e) => {
                pomodoroState.durations[d] = parseInt(e.target.value);
                if (pomodoroState.mode === d && !pomodoroState.running) {
                    pomodoroState.timeLeft = pomodoroState.durations[d] * 60;
                    updateDisplay();
                }
            });
        });
        updateDisplay();
    }

    function renderDateDifference() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label for="daycounter-start">Start Date</label>
                <input type="date" id="daycounter-start" class="tool-input">
            </div>
            <div class="tool-input-group">
                <label for="daycounter-end">End Date</label>
                <input type="date" id="daycounter-end" class="tool-input">
            </div>
            <div id="daycounter-output" class="tool-output" style="display: none;"></div>
        `;
        const startInput = document.getElementById('daycounter-start');
        const endInput = document.getElementById('daycounter-end');
        const output = document.getElementById('daycounter-output');

        function calculate() {
            if (!startInput?.value || !endInput?.value || !output) {
                if (output) output.style.display = 'none';
                return;
            }
            const startDate = new Date(startInput.value);
            const endDate = new Date(endInput.value);
            const diffTime = Math.abs(endDate.getTime() - startDate.getTime());
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            output.innerHTML = `<div class="value">${diffDays}</div> <div class="label">Days Between Dates</div>`;
            output.style.display = 'block';
        }
        
        startInput?.addEventListener('change', calculate);
        endInput?.addEventListener('change', calculate);
    }

    function renderAgeCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label for="birthdate-input">Enter Your Birthdate</label>
                <input type="date" id="birthdate-input" class="tool-input">
            </div>
            <div id="age-output" class="tool-output" style="display: none;"></div>
        `;
        const input = document.getElementById('birthdate-input');
        const output = document.getElementById('age-output');

        input?.addEventListener('change', () => {
            if (!input?.value || !output) return (output.style.display = 'none');
            const birthDate = new Date(input.value);
            const today = new Date();
            let years = today.getFullYear() - birthDate.getFullYear();
            let months = today.getMonth() - birthDate.getMonth();
            let days = today.getDate() - birthDate.getDate();

            if (days < 0) {
                months--;
                days += new Date(today.getFullYear(), today.getMonth(), 0).getDate();
            }
            if (months < 0) {
                years--;
                months += 12;
            }
            
            output.innerHTML = `<div class="value">${years} years, ${months} months, ${days} days</div> <div class="label">Your Precise Age</div>`;
            output.style.display = 'block';
        });
    }

    function renderCalendarGenerator() {
        let currentDate = new Date();
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="calendar-controls">
                <button id="prev-month" class="tool-button tool-button-secondary">&lt;</button>
                <h3 id="month-year"></h3>
                <button id="next-month" class="tool-button tool-button-secondary">&gt;</button>
            </div>
            <div id="calendar-grid" class="calendar-grid"></div>
        `;
        
        const monthYearEl = document.getElementById('month-year');
        const grid = document.getElementById('calendar-grid');

        function generateCalendar() {
            if (!grid || !monthYearEl) return;
            grid.innerHTML = '';
            const year = currentDate.getFullYear(), month = currentDate.getMonth();
            monthYearEl.textContent = currentDate.toLocaleDateString([], { month: 'long', year: 'numeric' });
            
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => grid.innerHTML += `<div class="calendar-header">${day}</div>`);
            for (let i = 0; i < firstDay; i++) grid.innerHTML += `<div></div>`;
            for (let day = 1; day <= daysInMonth; day++) {
                const isToday = new Date().toDateString() === new Date(year, month, day).toDateString();
                grid.innerHTML += `<div class="calendar-day ${isToday ? 'today' : ''}">${day}</div>`;
            }
        }
        
        document.getElementById('prev-month')?.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() - 1); generateCalendar(); });
        document.getElementById('next-month')?.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() + 1); generateCalendar(); });
        generateCalendar();
    }


    // --- CONVERSION TOOLS ---

    const converterData = {
        length: { units: { m: 1, km: 1000, cm: 0.01, mm: 0.001, mi: 1609.34, yd: 0.9144, ft: 0.3048, in: 0.0254 }, default: ['m', 'ft'] },
        weight: { units: { kg: 1, g: 0.001, mg: 1e-6, lb: 0.453592, oz: 0.0283495 }, default: ['kg', 'lb'] },
        speed: { units: { 'm/s': 1, 'km/h': 0.277778, mph: 0.44704, knot: 0.514444 }, default: ['km/h', 'mph'] },
        area: { units: { sqm: 1, sqkm: 1e6, sqmi: 2.59e6, acre: 4046.86, sqft: 0.092903 }, default: ['sqm', 'sqft'] },
        volume: { units: { l: 1, ml: 0.001, gal: 3.78541, pint: 0.473176, cup: 0.24 }, default: ['l', 'gal'] },
        temp: { toBase: { C: v => v, F: v => (v - 32) * 5/9, K: v => v - 273.15 }, fromBase: { C: v => v, F: v => (v * 9/5) + 32, K: v => v + 273.15 }, default: ['C', 'F'] },
        currency: { units: { USD: 1, EUR: 0.92, GBP: 0.79, JPY: 157, CAD: 1.37, AUD: 1.5 }, default: ['USD', 'EUR'], disclaimer: 'Rates are for demonstration and not real-time.' }
    };

    function renderGenericConverter(type) {
        const data = converterData[type];
        const unitKeys = Object.keys(data.units || data.toBase);
        let optionsHtml = unitKeys.map(u => `<option value="${u}">${u}</option>`).join('');

        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="converter-ui">
                <div class="converter-row">
                    <div class="converter-input-group">
                        <select id="unit1" class="tool-select">${optionsHtml}</select>
                        <input type="number" id="input1" class="tool-input" value="1">
                    </div>
                    <button id="swap-btn" class="converter-swap-btn" aria-label="Swap units">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"></path></svg>
                    </button>
                     <div class="converter-input-group">
                        <select id="unit2" class="tool-select">${optionsHtml}</select>
                        <input type="number" id="input2" class="tool-input">
                    </div>
                </div>
                ${data.disclaimer ? `<p class="disclaimer">${data.disclaimer}</p>` : ''}
            </div>
        `;

        const inputs = [document.getElementById('input1'), document.getElementById('input2')];
        const units = [document.getElementById('unit1'), document.getElementById('unit2')];
        units[0].value = data.default[0];
        units[1].value = data.default[1];

        function calculate(sourceIndex) {
            const targetIndex = sourceIndex === 0 ? 1 : 0;
            const sourceValue = parseFloat(inputs[sourceIndex].value);
            if (isNaN(sourceValue)) return (inputs[targetIndex].value = '');
            
            const sourceUnit = units[sourceIndex].value;
            const targetUnit = units[targetIndex].value;
            
            let baseValue;
            if (data.toBase) { // Special case for temp
                 baseValue = data.toBase[sourceUnit](sourceValue);
            } else { // Standard linear conversion
                baseValue = sourceValue * data.units[sourceUnit];
            }

            let targetValue;
            if (data.fromBase) { // Special case for temp
                targetValue = data.fromBase[targetUnit](baseValue);
            } else { // Standard linear conversion
                 targetValue = baseValue / data.units[targetUnit];
            }

            inputs[targetIndex].value = parseFloat(targetValue.toPrecision(6)).toString();
        }
        
        inputs.forEach((input, i) => input?.addEventListener('input', () => calculate(i)));
        units.forEach((unit, i) => unit?.addEventListener('change', () => calculate(i)));
        document.getElementById('swap-btn')?.addEventListener('click', () => {
            [units[0].value, units[1].value] = [units[1].value, units[0].value];
            calculate(0);
        });
        calculate(0);
    }

    // --- MATH & FINANCE ---
    
    function renderNormalCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="calculator-container">
                <div class="calculator-display-container">
                    <div id="calculator-display-expression" class="calculator-display-expression"></div>
                    <div id="calculator-display-main" class="calculator-display-main">0</div>
                </div>
                <div id="calculator-grid" class="normal-calculator-grid">
                    <button class="calculator-btn function" data-key="clear">AC</button>
                    <button class="calculator-btn function" data-key="sign">+/-</button>
                    <button class="calculator-btn function" data-key="%">%</button>
                    <button class="calculator-btn operator" data-key="/"></button>
                    <button class="calculator-btn" data-key="7">7</button>
                    <button class="calculator-btn" data-key="8">8</button>
                    <button class="calculator-btn" data-key="9">9</button>
                    <button class="calculator-btn operator" data-key="*"></button>
                    <button class="calculator-btn" data-key="4">4</button>
                    <button class="calculator-btn" data-key="5">5</button>
                    <button class="calculator-btn" data-key="6">6</button>
                    <button class="calculator-btn operator" data-key="-">-</button>
                    <button class="calculator-btn" data-key="1">1</button>
                    <button class="calculator-btn" data-key="2">2</button>
                    <button class="calculator-btn" data-key="3">3</button>
                    <button class="calculator-btn operator" data-key="+">+</button>
                    <button class="calculator-btn span-2" data-key="0">0</button>
                    <button class="calculator-btn" data-key=".">.</button>
                    <button class="calculator-btn equals" data-key="=">=</button>
                </div>
            </div>
        `;
        
        const mainDisplay = document.getElementById('calculator-display-main');
        const expressionDisplay = document.getElementById('calculator-display-expression');
        let state = {
            currentOperand: '0',
            previousOperand: null,
            operation: null,
            overwrite: true,
        };

        const updateDisplay = () => {
            mainDisplay.textContent = state.currentOperand;
            if(state.operation != null) {
                expressionDisplay.textContent = `${state.previousOperand} ${state.operation}`;
            } else {
                expressionDisplay.textContent = '';
            }
        };

        const calculate = () => {
            const prev = parseFloat(state.previousOperand);
            const current = parseFloat(state.currentOperand);
            if (isNaN(prev) || isNaN(current)) return;
            let result = 0;
            switch(state.operation) {
                case '+': result = prev + current; break;
                case '-': result = prev - current; break;
                case '': result = prev * current; break;
                case '': result = prev / current; break;
                default: return;
            }
            state.currentOperand = String(result);
            state.operation = null;
            state.previousOperand = null;
        };
        
        document.getElementById('calculator-grid').addEventListener('click', e => {
            const btn = e.target.closest('.calculator-btn');
            if (!btn) return;
            const key = btn.dataset.key;
            const keyText = btn.textContent;

            if (/\d/.test(key)) {
                if (state.currentOperand === '0' || state.overwrite) {
                    state.currentOperand = key;
                    state.overwrite = false;
                } else {
                    state.currentOperand += key;
                }
            } else if (key === '.') {
                if (state.overwrite) {
                    state.currentOperand = '0.';
                    state.overwrite = false;
                } else if (!state.currentOperand.includes('.')) {
                    state.currentOperand += '.';
                }
            } else if ('/*-+/'.includes(keyText)) {
                if (state.operation != null) calculate();
                state.operation = keyText;
                state.previousOperand = state.currentOperand;
                state.overwrite = true;
            } else if (key === '=') {
                if (state.operation == null || state.previousOperand == null) return;
                calculate();
                state.overwrite = true;
            } else if (key === 'clear') {
                state.currentOperand = '0';
                state.previousOperand = null;
                state.operation = null;
                state.overwrite = true;
            } else if (key === 'sign') {
                state.currentOperand = String(parseFloat(state.currentOperand) * -1);
            } else if (key === '%') {
                state.currentOperand = String(parseFloat(state.currentOperand) / 100);
            }
            updateDisplay();
        });
    }

    function renderScientificCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="calculator-container">
                <div class="calculator-display-container">
                    <div id="calculator-mode-indicator" class="calculator-mode-indicator">DEG</div>
                    <div id="calculator-display-expression" class="calculator-display-expression"></div>
                    <div id="calculator-display-main" class="calculator-display-main">0</div>
                </div>
                <div id="calculator-grid" class="scientific-calculator-grid">
                    <button class="calculator-btn function" data-key="2nd">2nd</button>
                    <button class="calculator-btn function" data-key="deg">DEG</button>
                    <button class="calculator-btn function" data-key="(">(</button>
                    <button class="calculator-btn function" data-key=")">)</button>
                    <button class="calculator-btn operator" data-key="del">DEL</button>
                    
                    <button class="calculator-btn function" data-key="x2">x</button>
                    <button class="calculator-btn function" data-key="sqrt"></button>
                    <button class="calculator-btn function" data-key="^">x<sup>y</sup></button>
                    <button class="calculator-btn function" data-key="log">log</button>
                    <button class="calculator-btn function" data-key="ln">ln</button>

                    <button class="calculator-btn function" data-key="sin">sin</button>
                    <button class="calculator-btn function" data-key="cos">cos</button>
                    <button class="calculator-btn function" data-key="tan">tan</button>
                    <button class="calculator-btn function" data-key="pi"></button>
                    <button class="calculator-btn function" data-key="e">e</button>

                    <button class="calculator-btn" data-key="7">7</button>
                    <button class="calculator-btn" data-key="8">8</button>
                    <button class="calculator-btn" data-key="9">9</button>
                    <button class="calculator-btn operator" data-key="clear">AC</button>
                    <button class="calculator-btn operator" data-key="/"></button>
                    
                    <button class="calculator-btn" data-key="4">4</button>
                    <button class="calculator-btn" data-key="5">5</button>
                    <button class="calculator-btn" data-key="6">6</button>
                    <button class="calculator-btn operator" data-key="+">+</button>
                    <button class="calculator-btn operator" data-key="-">-</button>

                    <button class="calculator-btn" data-key="1">1</button>
                    <button class="calculator-btn" data-key="2">2</button>
                    <button class="calculator-btn" data-key="3">3</button>
                    <button class="calculator-btn operator" data-key="*"></button>
                    <button class="calculator-btn equals" data-key="=">=</button>
                    
                    <button class="calculator-btn span-2" data-key="0">0</button>
                    <button class="calculator-btn" data-key=".">.</button>
                </div>
            </div>
        `;
        
        const mainDisplay = document.getElementById('calculator-display-main');
        const expressionDisplay = document.getElementById('calculator-display-expression');
        const grid = document.getElementById('calculator-grid');
        const modeIndicator = document.getElementById('calculator-mode-indicator');

        let state = {
            expression: '',
            isRad: false,
            is2nd: false,
            justEvaluated: false,
        };

        const updateDisplay = () => {
            expressionDisplay.textContent = state.expression.replace(/\*/g, '').replace(/\//g, '');
            expressionDisplay.scrollLeft = expressionDisplay.scrollWidth;
        };

        const evaluate = () => {
             try {
                // This is a robust evaluator using Shunting-yard algorithm
                const precedence = { '+': 1, '-': 1, '*': 2, '/': 2, '^': 3 };
                const functions = { sin: Math.sin, cos: Math.cos, tan: Math.tan, asin: Math.asin, acos: Math.acos, atan: Math.atan, log: Math.log10, ln: Math.log, sqrt: Math.sqrt };
                
                let expr = state.expression
                    .replace(//g, 'Math.PI')
                    .replace(/e/g, 'Math.E')
                    .replace(/ans/g, mainDisplay.textContent);

                const tokens = expr.match(/([0-9.]+)|(Math\.PI|Math\.E)|(\+|-|\*|\/|\^|\(|\))|([a-z]+)/g);
                
                const outputQueue = [];
                const operatorStack = [];

                tokens.forEach(token => {
                    if (!isNaN(parseFloat(token)) || token === 'Math.PI' || token === 'Math.E') {
                        outputQueue.push(token);
                    } else if (functions[token]) {
                        operatorStack.push(token);
                    } else if (precedence[token]) {
                        while (operatorStack.length > 0 && precedence[operatorStack[operatorStack.length-1]] >= precedence[token]) {
                            outputQueue.push(operatorStack.pop());
                        }
                        operatorStack.push(token);
                    } else if (token === '(') {
                        operatorStack.push(token);
                    } else if (token === ')') {
                        while(operatorStack[operatorStack.length-1] !== '(') {
                            outputQueue.push(operatorStack.pop());
                        }
                        operatorStack.pop(); // Pop '('
                        if (functions[operatorStack[operatorStack.length-1]]) {
                            outputQueue.push(operatorStack.pop());
                        }
                    }
                });

                while (operatorStack.length > 0) {
                    outputQueue.push(operatorStack.pop());
                }

                // Evaluate RPN
                const evalStack = [];
                outputQueue.forEach(token => {
                    if (!isNaN(parseFloat(token))) {
                        evalStack.push(parseFloat(token));
                    } else if (token === 'Math.PI' || token === 'Math.E') {
                        evalStack.push(eval(token));
                    } else if (functions[token]) {
                        let arg = evalStack.pop();
                        if (['sin', 'cos', 'tan', 'asin', 'acos', 'atan'].includes(token) && !state.isRad) {
                           if (['sin', 'cos', 'tan'].includes(token)) arg = arg * Math.PI / 180;
                           let result = functions[token](arg);
                           if (['asin', 'acos', 'atan'].includes(token)) result = result * 180 / Math.PI;
                           evalStack.push(result);
                        } else {
                           evalStack.push(functions[token](arg));
                        }
                    } else { // Operator
                        const b = evalStack.pop();
                        const a = evalStack.pop();
                        if (token === '+') evalStack.push(a + b);
                        else if (token === '-') evalStack.push(a - b);
                        else if (token === '*') evalStack.push(a * b);
                        else if (token === '/') evalStack.push(a / b);
                        else if (token === '^') evalStack.push(Math.pow(a, b));
                    }
                });
                
                const result = evalStack[0];
                if (isFinite(result)) {
                    mainDisplay.textContent = parseFloat(result.toPrecision(12));
                    state.justEvaluated = true;
                } else {
                    mainDisplay.textContent = 'Error';
                }

            } catch (error) {
                mainDisplay.textContent = 'Error';
                state.justEvaluated = true;
            }
        };

        const clear = () => {
            state.expression = '';
            mainDisplay.textContent = '0';
            updateDisplay();
        };
        
        const handleKey = (key) => {
            if (state.justEvaluated && !'/*-+^'.includes(key) && key !== '=') {
                state.expression = '';
            } else if (state.justEvaluated && '/*-+^'.includes(key)) {
                state.expression = 'ans' + key;
            }
            state.justEvaluated = false;

            if (/\d/.test(key) || key === '.' || key === 'pi' || key === 'e') {
                state.expression += key === 'pi' ? '' : key === 'e' ? 'e' : key;
            } else if ('/*-+^'.includes(key)) {
                state.expression += key;
            } else if (key === '=') {
                evaluate();
            } else if (key === 'clear') {
                clear();
            } else if (key === 'del') {
                state.expression = state.expression.slice(0, -1);
            } else if (key === '(' || key === ')') {
                state.expression += key;
            } else if (key === 'x2') {
                state.expression += '^2';
            } else { // Functions
                state.expression += `${key}(`;
            }
            updateDisplay();
        };
        
        grid.addEventListener('click', e => {
            const btn = e.target.closest('.calculator-btn');
            if (!btn) return;
            let key = btn.dataset.key;

            if (key === 'deg') {
                state.isRad = !state.isRad;
                btn.textContent = state.isRad ? 'RAD' : 'DEG';
                modeIndicator.textContent = state.isRad ? 'RAD' : 'DEG';
                if(state.isRad) btn.classList.add('active'); else btn.classList.remove('active');
            } else if (key === '2nd') {
                state.is2nd = !state.is2nd;
                btn.classList.toggle('active');
                grid.querySelector('[data-key="sin"]').innerHTML = state.is2nd ? 'sin<sup>-1</sup>' : 'sin';
                grid.querySelector('[data-key="cos"]').innerHTML = state.is2nd ? 'cos<sup>-1</sup>' : 'cos';
                grid.querySelector('[data-key="tan"]').innerHTML = state.is2nd ? 'tan<sup>-1</sup>' : 'tan';
                grid.querySelector('[data-key="log"]').innerHTML = state.is2nd ? '10<sup>x</sup>' : 'log';
                grid.querySelector('[data-key="ln"]').innerHTML = state.is2nd ? 'e<sup>x</sup>' : 'ln';
            } else {
                 if (state.is2nd) {
                     if (key === 'sin') key = 'asin';
                     else if (key === 'cos') key = 'acos';
                     else if (key === 'tan') key = 'atan';
                     else if (key === 'log') key = '10^';
                     else if (key === 'ln') key = 'e^';
                 }
                 handleKey(key);
            }
        });
    }

    function renderLoanCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-grid-2col">
                <div>
                    <div class="tool-input-group">
                        <label for="loan-amount">Loan Amount</label>
                        <input type="number" id="loan-amount" class="tool-input" value="100000">
                    </div>
                    <div class="tool-input-group">
                        <label for="loan-rate">Interest Rate (%)</label>
                        <input type="number" id="loan-rate" class="tool-input" value="5">
                    </div>
                    <div class="tool-input-group">
                        <label for="loan-term">Loan Term (Years)</label>
                        <input type="number" id="loan-term" class="tool-input" value="30">
                    </div>
                    <button id="loan-calculate" class="tool-button" style="width:100%">Calculate</button>
                </div>
                <div id="loan-results" class="finance-results" style="display:none;">
                    <div class="finance-result-row">
                        <span class="label">Monthly Payment</span>
                        <span id="monthly-payment" class="value">$0.00</span>
                    </div>
                     <div class="finance-result-row">
                        <span class="label">Total Principal</span>
                        <span id="total-principal" class="sub-value">$0.00</span>
                    </div>
                    <div class="finance-result-row">
                        <span class="label">Total Interest</span>
                        <span id="total-interest" class="sub-value">$0.00</span>
                    </div>
                    <div class="loan-chart-container">
                        <div class="loan-chart-bar">
                            <div id="chart-principal" class="loan-chart-principal"></div>
                            <div id="chart-interest" class="loan-chart-interest"></div>
                        </div>
                        <div class="loan-chart-legend">
                            <span class="legend-principal">Principal</span>
                            <span class="legend-interest">Interest</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        const calculate = () => {
            const amount = parseFloat(document.getElementById('loan-amount').value);
            const rate = parseFloat(document.getElementById('loan-rate').value) / 100 / 12;
            const term = parseFloat(document.getElementById('loan-term').value) * 12;

            if(amount > 0 && rate > 0 && term > 0) {
                const monthlyPayment = amount * rate * Math.pow(1 + rate, term) / (Math.pow(1 + rate, term) - 1);
                const totalInterest = (monthlyPayment * term) - amount;

                document.getElementById('monthly-payment').textContent = `$${monthlyPayment.toFixed(2)}`;
                document.getElementById('total-principal').textContent = `$${amount.toFixed(2)}`;
                document.getElementById('total-interest').textContent = `$${totalInterest.toFixed(2)}`;
                
                const principalPercent = (amount / (amount + totalInterest)) * 100;
                document.getElementById('chart-principal').style.width = `${principalPercent}%`;
                document.getElementById('chart-interest').style.width = `${100 - principalPercent}%`;

                document.getElementById('loan-results').style.display = 'flex';
            }
        };
        document.getElementById('loan-calculate').addEventListener('click', calculate);
        calculate();
    }
    
    function renderCompoundInterestCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-grid-2col">
                <div>
                    <div class="tool-input-group"><label>Principal Amount</label><input type="number" id="ci-principal" class="tool-input" value="1000"></div>
                    <div class="tool-input-group"><label>Annual Interest Rate (%)</label><input type="number" id="ci-rate" class="tool-input" value="5"></div>
                    <div class="tool-input-group"><label>Years</label><input type="number" id="ci-years" class="tool-input" value="10"></div>
                    <div class="tool-input-group"><label>Compound Frequency</label><select id="ci-frequency" class="tool-select"><option value="1">Annually</option><option value="4">Quarterly</option><option value="12" selected>Monthly</option></select></div>
                    <button id="ci-calculate" class="tool-button" style="width:100%">Calculate</button>
                </div>
                <div id="ci-results" class="finance-results" style="display:none;">
                    <div class="finance-result-row"><span class="label">Future Value</span><span id="ci-future-value" class="value">$0.00</span></div>
                    <div class="finance-result-row"><span class="label">Total Interest</span><span id="ci-total-interest" class="sub-value">$0.00</span></div>
                </div>
            </div>
        `;
        const calculate = () => {
            const p = parseFloat(document.getElementById('ci-principal').value);
            const r = parseFloat(document.getElementById('ci-rate').value) / 100;
            const t = parseFloat(document.getElementById('ci-years').value);
            const n = parseFloat(document.getElementById('ci-frequency').value);
            if (p > 0 && r > 0 && t > 0 && n > 0) {
                const amount = p * Math.pow(1 + (r / n), n * t);
                const interest = amount - p;
                document.getElementById('ci-future-value').textContent = `$${amount.toFixed(2)}`;
                document.getElementById('ci-total-interest').textContent = `$${interest.toFixed(2)}`;
                document.getElementById('ci-results').style.display = 'flex';
            }
        };
        document.getElementById('ci-calculate').addEventListener('click', calculate);
        calculate();
    }

    function renderSavingsCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Savings Goal</label><input type="number" class="tool-input" id="sg-goal" value="10000"></div>
            <div class="tool-input-group"><label>Time to Save (Years)</label><input type="number" class="tool-input" id="sg-years" value="5"></div>
            <button id="sg-calculate" class="tool-button" style="width:100%">Calculate</button>
            <div id="sg-output" class="tool-output" style="display:none;"></div>
        `;
        const calculate = () => {
            const goal = parseFloat(document.getElementById('sg-goal').value);
            const years = parseFloat(document.getElementById('sg-years').value);
            if(goal > 0 && years > 0) {
                const monthly = goal / (years * 12);
                document.getElementById('sg-output').innerHTML = `<div class="value">$${monthly.toFixed(2)}</div><div class="label">Monthly Savings Required</div>`;
                document.getElementById('sg-output').style.display = 'block';
            }
        };
        document.getElementById('sg-calculate').addEventListener('click', calculate);
        calculate();
    }
    
    function renderRoiCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Initial Investment</label><input type="number" class="tool-input" id="roi-initial" value="1000"></div>
            <div class="tool-input-group"><label>Final Value</label><input type="number" class="tool-input" id="roi-final" value="1500"></div>
            <button id="roi-calculate" class="tool-button" style="width:100%">Calculate</button>
            <div id="roi-output" class="tool-output" style="display:none;"></div>
        `;
        const calculate = () => {
            const initial = parseFloat(document.getElementById('roi-initial').value);
            const final = parseFloat(document.getElementById('roi-final').value);
            if(initial > 0 && final > 0) {
                const roi = ((final - initial) / initial) * 100;
                document.getElementById('roi-output').innerHTML = `<div class="value">${roi.toFixed(2)}%</div><div class="label">Return on Investment (ROI)</div>`;
                document.getElementById('roi-output').style.display = 'block';
            }
        };
        document.getElementById('roi-calculate').addEventListener('click', calculate);
        calculate();
    }
    
    function renderNumberBaseConverter() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Decimal</label><input type="text" class="tool-input" id="nb-dec" data-base="10"></div>
            <div class="tool-input-group"><label>Binary</label><input type="text" class="tool-input" id="nb-bin" data-base="2"></div>
            <div class="tool-input-group"><label>Hexadecimal</label><input type="text" class="tool-input" id="nb-hex" data-base="16"></div>
            <div class="tool-input-group"><label>Octal</label><input type="text" class="tool-input" id="nb-oct" data-base="8"></div>
        `;
        const inputs = ['dec', 'bin', 'hex', 'oct'].map(id => document.getElementById(`nb-${id}`));
        inputs.forEach(input => {
            input.addEventListener('input', e => {
                const sourceBase = parseInt(e.target.dataset.base);
                const value = e.target.value;
                if(value === '') { // Clear all if one is cleared
                    inputs.forEach(inp => { if (inp !== e.target) inp.value = ''; });
                    return;
                }
                const decimalValue = parseInt(value, sourceBase);
                if (isNaN(decimalValue)) return;
                
                inputs.forEach(inp => {
                    if (inp !== e.target) {
                        const targetBase = parseInt(inp.dataset.base);
                        inp.value = decimalValue.toString(targetBase).toUpperCase();
                    }
                });
            });
        });
    }

    function renderTipCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="tool-grid-2col">
                <div class="tip-inputs">
                    <div class="tool-input-group">
                        <label for="bill-amount">Bill Amount</label>
                        <input type="number" id="bill-amount" class="tool-input" placeholder="0.00">
                    </div>
                    <div class="tool-input-group">
                        <label>Select Tip %</label>
                        <div class="tip-options" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--space-sm);">
                            <button class="tool-button tool-button-secondary" data-tip="15">15%</button>
                            <button class="tool-button tool-button-secondary" data-tip="18">18%</button>
                            <button class="tool-button tool-button-secondary" data-tip="20">20%</button>
                        </div>
                        <input type="number" id="custom-tip" class="tool-input" placeholder="Custom Tip">
                    </div>
                    <div class="tool-input-group">
                        <label for="num-people">Number of People</label>
                        <input type="number" id="num-people" class="tool-input" value="1">
                    </div>
                </div>
                <div class="finance-results">
                    <div class="finance-result-row">
                        <span class="label">Tip Amount</span>
                        <span id="tip-amount" class="value">$0.00</span>
                    </div>
                    <div class="finance-result-row">
                        <span class="label">Total Per Person</span>
                        <span id="total-per-person" class="value">$0.00</span>
                    </div>
                    <button id="tip-reset" class="tool-button">Reset</button>
                </div>
            </div>
        `;

        const billInput = document.getElementById('bill-amount');
        const customTipInput = document.getElementById('custom-tip');
        const peopleInput = document.getElementById('num-people');
        const tipAmountEl = document.getElementById('tip-amount');
        const totalPerPersonEl = document.getElementById('total-per-person');
        let tipPercent = 0;

        function calculate() {
            const bill = parseFloat(billInput.value) || 0;
            const people = parseInt(peopleInput.value) || 1;

            if (bill > 0) {
                const tip = bill * (tipPercent / 100);
                const total = bill + tip;
                const perPerson = total / people;
                
                tipAmountEl.textContent = `$${tip.toFixed(2)}`;
                totalPerPersonEl.textContent = `$${perPerson.toFixed(2)}`;
            } else {
                tipAmountEl.textContent = `$0.00`;
                totalPerPersonEl.textContent = `$0.00`;
            }
        }
        
        document.querySelector('.tip-options').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                document.querySelectorAll('.tip-options button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                tipPercent = parseFloat(e.target.dataset.tip);
                customTipInput.value = '';
                calculate();
            }
        });

        customTipInput.addEventListener('input', () => {
             document.querySelectorAll('.tip-options button').forEach(b => b.classList.remove('active'));
             tipPercent = parseFloat(customTipInput.value) || 0;
             calculate();
        });
        
        [billInput, peopleInput].forEach(el => el.addEventListener('input', calculate));
        
        document.getElementById('tip-reset').addEventListener('click', () => {
            billInput.value = '';
            customTipInput.value = '';
            peopleInput.value = '1';
            tipPercent = 0;
            document.querySelectorAll('.tip-options button').forEach(b => b.classList.remove('active'));
            calculate();
        });
    }

    function renderPercentageCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="percentage-calculator">
                <div class="tool-tabs">
                    <button class="tool-tab-btn tool-button active" data-mode="mode1">X% of Y</button>
                    <button class="tool-tab-btn tool-button tool-button-secondary" data-mode="mode2">X is what % of Y</button>
                </div>
                <div id="percentage-content"></div>
                <div id="percentage-output" class="tool-output" style="display:none;"></div>
            </div>
        `;

        const content = document.getElementById('percentage-content');
        const output = document.getElementById('percentage-output');
        
        function renderMode(mode) {
            output.style.display = 'none';
            if (mode === 'mode1') {
                content.innerHTML = `
                    <div class="tool-input-group"><label>What is</label><input type="number" id="p1_percent" class="tool-input" placeholder="%"></div>
                    <div class="tool-input-group"><label>of</label><input type="number" id="p1_value" class="tool-input" placeholder="value"></div>
                `;
                document.getElementById('p1_percent').addEventListener('input', calculate);
                document.getElementById('p1_value').addEventListener('input', calculate);
            } else {
                content.innerHTML = `
                    <div class="tool-input-group"><label>Value</label><input type="number" id="p2_val1" class="tool-input" placeholder="X"></div>
                    <div class="tool-input-group"><label>is what percent of</label><input type="number" id="p2_val2" class="tool-input" placeholder="Y"></div>
                `;
                 document.getElementById('p2_val1').addEventListener('input', calculate);
                 document.getElementById('p2_val2').addEventListener('input', calculate);
            }
            calculate();
        }

        function calculate() {
            const activeMode = document.querySelector('.tool-tab-btn.active').dataset.mode;
            let result = '';
            if (activeMode === 'mode1') {
                const percent = parseFloat(document.getElementById('p1_percent').value);
                const value = parseFloat(document.getElementById('p1_value').value);
                if (!isNaN(percent) && !isNaN(value)) {
                    result = (percent / 100) * value;
                }
            } else {
                const val1 = parseFloat(document.getElementById('p2_val1').value);
                const val2 = parseFloat(document.getElementById('p2_val2').value);
                if (!isNaN(val1) && !isNaN(val2) && val2 !== 0) {
                    result = `${((val1 / val2) * 100).toFixed(2)}%`;
                }
            }
            if (result !== '' && !isNaN(result)) {
                output.innerHTML = `<div class="value">${result}</div>`;
                output.style.display = 'block';
            } else if (typeof result === 'string' && result.includes('%')) {
                output.innerHTML = `<div class="value">${result}</div>`;
                output.style.display = 'block';
            } else {
                output.style.display = 'none';
            }
        }
        
        document.querySelector('.tool-tabs').addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                 document.querySelectorAll('.tool-tab-btn').forEach(b => b.classList.replace('active', 'tool-button-secondary'));
                 e.target.classList.replace('tool-button-secondary', 'active');
                 renderMode(e.target.dataset.mode);
            }
        });

        renderMode('mode1');
    }
    
    function renderBmiCalculator() {
        if (!a.toolContent) return;
        a.toolContent.innerHTML = `
            <div class="bmi-calculator">
                 <div class="tool-tabs unit-toggle">
                    <button class="tool-tab-btn tool-button active" data-unit="metric">Metric</button>
                    <button class="tool-tab-btn tool-button tool-button-secondary" data-unit="imperial">Imperial</button>
                </div>
                <div id="bmi-inputs"></div>
                <button id="bmi-calculate" class="tool-button" style="width: 100%; margin-top: 1rem;">Calculate</button>
                <div id="bmi-output" class="tool-output" style="display:none;"></div>
            </div>
        `;
        
        const inputsContainer = document.getElementById('bmi-inputs');
        const output = document.getElementById('bmi-output');

        function renderInputs(unit) {
            if (unit === 'metric') {
                inputsContainer.innerHTML = `
                    <div class="tool-input-group"><label>Height (cm)</label><input type="number" id="height" class="tool-input"></div>
                    <div class="tool-input-group"><label>Weight (kg)</label><input type="number" id="weight" class="tool-input"></div>
                `;
            } else {
                 inputsContainer.innerHTML = `
                    <div class="tool-input-group"><label>Height</label><div class="tool-input-row"><input type="number" id="height_ft" class="tool-input" placeholder="ft"><input type="number" id="height_in" class="tool-input" placeholder="in"></div></div>
                    <div class="tool-input-group"><label>Weight (lbs)</label><input type="number"id="weight" class="tool-input"></div>
                `;
            }
        }
        
        document.getElementById('bmi-calculate').addEventListener('click', () => {
            const unit = document.querySelector('.unit-toggle .active').dataset.unit;
            let heightM, weightKg;
            
            if (unit === 'metric') {
                heightM = parseFloat(document.getElementById('height').value) / 100;
                weightKg = parseFloat(document.getElementById('weight').value);
            } else {
                const ft = parseFloat(document.getElementById('height_ft').value) || 0;
                const inches = parseFloat(document.getElementById('height_in').value) || 0;
                heightM = ((ft * 12) + inches) * 0.0254;
                weightKg = parseFloat(document.getElementById('weight').value) * 0.453592;
            }

            if (heightM > 0 && weightKg > 0) {
                const bmi = weightKg / (heightM * heightM);
                let category = '';
                if (bmi < 18.5) category = 'Underweight';
                else if (bmi < 24.9) category = 'Normal weight';
                else if (bmi < 29.9) category = 'Overweight';
                else category = 'Obesity';
                output.innerHTML = `<div class="value">${bmi.toFixed(1)}</div><div class="label">${category}</div>`;
                output.style.display = 'block';
            } else {
                output.style.display = 'none';
            }
        });
        
        document.querySelector('.unit-toggle').addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                 document.querySelectorAll('.unit-toggle button').forEach(b => b.classList.replace('active', 'tool-button-secondary'));
                 e.target.classList.replace('tool-button-secondary', 'active');
                 renderInputs(e.target.dataset.unit);
            }
        });
        
        renderInputs('metric');
    }
    
    // --- TEXT & WRITING ---

    function renderWordCounter() {
      if (!a.toolContent) return;
      a.toolContent.innerHTML = `
        <div class="word-counter">
          <textarea id="word-counter-input" class="tool-textarea" placeholder="Start typing here..."></textarea>
          <div class="word-counter-stats">
            <div class="stat-item">
              <div id="stats-words" class="value">0</div>
              <div class="label">Words</div>
            </div>
            <div class="stat-item">
              <div id="stats-chars" class="value">0</div>
              <div class="label">Characters</div>
            </div>
            <div class="stat-item">
              <div id="stats-sentences" class="value">0</div>
              <div class="label">Sentences</div>
            </div>
             <div class="stat-item">
              <div id="stats-paragraphs" class="value">0</div>
              <div class="label">Paragraphs</div>
            </div>
             <div class="stat-item">
              <div id="stats-reading-time" class="value">0m</div>
              <div class="label">Reading Time</div>
            </div>
             <div class="stat-item">
              <div id="stats-speaking-time" class="value">0m</div>
              <div class="label">Speaking Time</div>
            </div>
          </div>
        </div>
      `;

      const input = document.getElementById('word-counter-input');
      const stats = {
          words: document.getElementById('stats-words'),
          chars: document.getElementById('stats-chars'),
          sentences: document.getElementById('stats-sentences'),
          paragraphs: document.getElementById('stats-paragraphs'),
          readingTime: document.getElementById('stats-reading-time'),
          speakingTime: document.getElementById('stats-speaking-time'),
      };

      input?.addEventListener('input', (e) => {
        const text = e.target.value;
        const words = text.match(/\b\w+\b/g) || [];
        const chars = text.length;
        const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
        const paragraphs = text.split(/\n+/).filter(p => p.trim().length > 0) || [];

        const readingTime = Math.ceil(words.length / 200); // 200 wpm avg
        const speakingTime = Math.ceil(words.length / 150); // 150 wpm avg

        if(stats.words) stats.words.textContent = words.length.toString();
        if(stats.chars) stats.chars.textContent = chars.toString();
        if(stats.sentences) stats.sentences.textContent = sentences.length.toString();
        if(stats.paragraphs) stats.paragraphs.textContent = paragraphs.length.toString();
        if(stats.readingTime) stats.readingTime.textContent = `${readingTime}m`;
        if(stats.speakingTime) stats.speakingTime.textContent = `${speakingTime}m`;
      });
    }

    function renderPasswordGenerator() {
        a.toolContent.innerHTML = `
            <div class="password-display">
                <input type="text" id="password-output" class="tool-input" readonly>
                <button id="copy-password" class="tool-button" aria-label="Copy password">Copy</button>
            </div>
            <div class="tool-input-group">
                <label for="pass-length">Length: <span id="pass-length-val">16</span></label>
                <input type="range" id="pass-length" min="8" max="32" value="16">
                <div class="password-strength-meter">
                    <div id="password-strength-bar" class="password-strength-bar"></div>
                </div>
            </div>
            <div class="password-options">
                <div class="password-option"><input type="checkbox" id="pass-upper" checked><label for="pass-upper">Uppercase (A-Z)</label></div>
                <div class="password-option"><input type="checkbox" id="pass-lower" checked><label for="pass-lower">Lowercase (a-z)</label></div>
                <div class="password-option"><input type="checkbox" id="pass-numbers" checked><label for="pass-numbers">Numbers (0-9)</label></div>
                <div class="password-option"><input type="checkbox" id="pass-symbols" checked><label for="pass-symbols">Symbols (!@#)</label></div>
            </div>
            <button id="generate-password" class="tool-button" style="width:100%; margin-top:1rem;">Generate New Password</button>
        `;

        const output = document.getElementById('password-output');
        const lengthSlider = document.getElementById('pass-length');
        const lengthVal = document.getElementById('pass-length-val');
        const strengthBar = document.getElementById('password-strength-bar');
        const options = {
            upper: document.getElementById('pass-upper'),
            lower: document.getElementById('pass-lower'),
            numbers: document.getElementById('pass-numbers'),
            symbols: document.getElementById('pass-symbols'),
        };

        const charSets = {
            upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            lower: 'abcdefghijklmnopqrstuvwxyz',
            numbers: '0123456789',
            symbols: '!@#$%^&*()_+~`|}{[]:;?><,./-=',
        };
        
        const generate = () => {
            const length = parseInt(lengthSlider.value, 10);
            lengthVal.textContent = length.toString();
            
            let charset = '';
            let strength = 0;
            if (options.upper.checked) { charset += charSets.upper; strength++; }
            if (options.lower.checked) { charset += charSets.lower; strength++; }
            if (options.numbers.checked) { charset += charSets.numbers; strength++; }
            if (options.symbols.checked) { charset += charSets.symbols; strength++; }
            
            if (length >= 12) strength++;
            if (length >= 16) strength++;
            if (strength > 4) strength = 4;

            strengthBar.className = 'password-strength-bar';
            if (strength > 0) strengthBar.classList.add(`strength-${strength}`);
            
            if (charset === '') {
                output.value = 'Select at least one option';
                return;
            }
            
            let password = '';
            for (let i = 0; i < length; i++) {
                password += charset.charAt(Math.floor(Math.random() * charset.length));
            }
            output.value = password;
        };

        lengthSlider.addEventListener('input', generate);
        Object.values(options).forEach(opt => opt.addEventListener('change', generate));
        document.getElementById('generate-password').addEventListener('click', generate);
        document.getElementById('copy-password').addEventListener('click', (e) => {
            navigator.clipboard.writeText(output.value);
            e.target.textContent = 'Copied!';
            setTimeout(() => e.target.textContent = 'Copy', 1500);
        });
        
        generate();
    }
    
    function renderQrCodeGenerator() {
      a.toolContent.innerHTML = `
        <div class="tool-grid-2col">
            <div>
                <div class="tool-input-group">
                    <label for="qr-input">Text or URL</label>
                    <textarea id="qr-input" class="tool-textarea" rows="4">https://infinitytoolhub.com</textarea>
                </div>
                <div class="tool-input-group">
                    <label>Colors</label>
                    <div style="display: flex; gap: var(--space-md);">
                        <div><label for="qr-color-fg">Code</label><input type="color" id="qr-color-fg" value="#0A0A1A"></div>
                        <div><label for="qr-color-bg">Background</label><input type="color" id="qr-color-bg" value="#FFFFFF"></div>
                    </div>
                </div>
            </div>
            <div style="text-align:center;">
                <div id="qr-code-output" style="display:inline-block; border: 1px solid var(--color-border); padding: var(--space-sm); border-radius: var(--radius-md); background-color: white;">
                    <img id="qr-code-image" src="" alt="QR Code" style="width: 200px; height: 200px; display: block;">
                </div>
            </div>
        </div>`;

        const outputContainer = document.getElementById('qr-code-output');
        const outputImage = document.getElementById('qr-code-image');
        const input = document.getElementById('qr-input');
        const fgColor = document.getElementById('qr-color-fg');
        const bgColor = document.getElementById('qr-color-bg');

        const generateQR = () => {
            const text = encodeURIComponent(input.value);
            const fg = fgColor.value.substring(1); // remove #
            const bg = bgColor.value.substring(1); // remove #
            const size = '200x200';
            
            if (text) {
                 const apiUrl = `https://api.qrserver.com/v1/create-qr-code/?data=${text}&size=${size}&color=${fg}&bgcolor=${bg}&qzone=1&format=svg`;
                 outputImage.src = apiUrl;
                 outputContainer.style.backgroundColor = bgColor.value;
            } else {
                outputImage.src = ''; // Clear if no text
            }
        };
        
        input.addEventListener('input', generateQR);
        fgColor.addEventListener('input', generateQR);
        bgColor.addEventListener('input', generateQR);
        generateQR();
    }

    function renderMarkdownPreviewer() {
        a.toolContent.innerHTML = `
            <div class="markdown-previewer">
                <textarea id="md-input" class="tool-textarea" placeholder="Type Markdown here..."></textarea>
                <div id="md-output" class="preview-output"></div>
            </div>
        `;
        const input = document.getElementById('md-input');
        const output = document.getElementById('md-output');

        const parseMd = (text) => {
             return text
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                .replace(/\*(.*)\*/gim, '<em>$1</em>')
                .replace(/\[(.*?)\]\((.*?)\)/gim, '<a href="$2" target="_blank">$1</a>')
                .replace(/^\s*[-*] (.*)/gim, '<ul><li>$1</li></ul>')
                .replace(/<\/ul>\s*<ul>/gim, '')
                .replace(/\n/g, '<br>');
        };

        const updatePreview = () => {
            output.innerHTML = parseMd(input.value);
        };
        input.addEventListener('input', updatePreview);
        input.value = `# Welcome!\n\nThis is a **live** *Markdown* previewer.\n\n- Type on the left.\n- See results on the right.\n\n[Learn more about Markdown](https://www.markdownguide.org)`;
        updatePreview();
    }

    function renderCaseConverter() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <textarea id="case-input" class="tool-textarea"></textarea>
            </div>
            <div class="tool-controls-grid">
                <button class="tool-button" data-case="upper">UPPERCASE</button>
                <button class="tool-button" data-case="lower">lowercase</button>
                <button class="tool-button" data-case="title">Title Case</button>
                <button class="tool-button" data-case="sentence">Sentence case</button>
            </div>
        `;
        const input = document.getElementById('case-input');
        document.querySelector('.tool-controls-grid').addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            const text = input.value;
            switch(e.target.dataset.case) {
                case 'upper': input.value = text.toUpperCase(); break;
                case 'lower': input.value = text.toLowerCase(); break;
                case 'title': input.value = text.toLowerCase().replace(/\b\w/g, s => s.toUpperCase()); break;
                case 'sentence': input.value = text.toLowerCase().replace(/(^\s*\w|[.!?]\s*\w)/g, c => c.toUpperCase()); break;
            }
        });
    }
    
    function generateLoremIpsum(paragraphCount) {
        const words = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore', 'magna', 'aliqua', 'ut', 'enim', 'ad', 'minim', 'veniam', 'quis', 'nostrud', 'exercitation', 'ullamco', 'laboris', 'nisi', 'ut', 'aliquip', 'ex', 'ea', 'commodo', 'consequat', 'duis', 'aute', 'irure', 'dolor', 'in', 'reprehenderit', 'in', 'voluptate', 'velit', 'esse', 'cillum', 'dolore', 'eu', 'fugiat', 'nulla', 'pariatur', 'excepteur', 'sint', 'occaecat', 'cupidatat', 'non', 'proident', 'sunt', 'in', 'culpa', 'qui', 'officia', 'deserunt', 'mollit', 'anim', 'id', 'est', 'laborum'];

        const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);

        const makeSentence = () => {
            const sentenceLength = random(8, 15);
            let sentence = [];
            for (let i = 0; i < sentenceLength; i++) {
                sentence.push(words[random(0, words.length - 1)]);
            }
            return capitalize(sentence.join(' ')) + '.';
        };

        const makeParagraph = () => {
            const paraLength = random(4, 7);
            let paragraph = [];
            for (let i = 0; i < paraLength; i++) {
                paragraph.push(makeSentence());
            }
            return paragraph.join(' ');
        };
        
        let result = [];
        for (let i = 0; i < paragraphCount; i++) {
            result.push(makeParagraph());
        }
        return result.join('\n\n');
    }

    function renderLoremIpsumGenerator() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label for="lorem-paragraphs">Number of Paragraphs</label>
                <input type="number" id="lorem-paragraphs" class="tool-input" value="3" min="1">
            </div>
            <button id="lorem-generate" class="tool-button" style="width: 100%">Generate</button>
            <div class="tool-input-group" style="margin-top: 1rem">
                <textarea id="lorem-output" class="tool-textarea" rows="10" readonly></textarea>
            </div>
        `;
        const output = document.getElementById('lorem-output');
        const generateBtn = document.getElementById('lorem-generate');
        const paraCountInput = document.getElementById('lorem-paragraphs');

        const generate = () => {
            const count = parseInt(paraCountInput.value) || 1;
            output.value = generateLoremIpsum(count);
        };

        generateBtn.addEventListener('click', generate);
        generate();
    }
    
    function renderTextReverser() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Input</label><textarea id="rev-input" class="tool-textarea"></textarea></div>
            <div class="tool-input-group"><label>Output</label><textarea id="rev-output" class="tool-textarea" readonly></textarea></div>
        `;
        const input = document.getElementById('rev-input');
        const output = document.getElementById('rev-output');
        input.addEventListener('input', () => {
            output.value = input.value.split('').reverse().join('');
        });
    }
    
    function renderTextSorter() {
        a.toolContent.innerHTML = `
            <textarea id="sort-input" class="tool-textarea" placeholder="Enter lines of text to sort..."></textarea>
            <div class="tool-controls-grid" style="margin-top: 1rem">
                <button class="tool-button" data-sort="az">Sort A-Z</button>
                <button class="tool-button" data-sort="za">Sort Z-A</button>
                <button class="tool-button" data-sort="rev">Reverse Lines</button>
            </div>
        `;
        const input = document.getElementById('sort-input');
        document.querySelector('.tool-controls-grid').addEventListener('click', e => {
            if (e.target.tagName !== 'BUTTON') return;
            const lines = input.value.split('\n');
            switch (e.target.dataset.sort) {
                case 'az': lines.sort((a, b) => a.trim().localeCompare(b.trim())); break;
                case 'za': lines.sort((a, b) => b.trim().localeCompare(a.trim())); break;
                case 'rev': lines.reverse(); break;
            }
            input.value = lines.join('\n');
        });
    }

    function renderBase64Coder() {
        a.toolContent.innerHTML = `
            <div class="tool-grid-2col">
                <div class="tool-input-group"><label>Text</label><textarea id="b64-text" class="tool-textarea"></textarea></div>
                <div class="tool-input-group"><label>Base64</label><textarea id="b64-base" class="tool-textarea"></textarea></div>
            </div>
            <div class="tool-controls-grid" style="margin-top: 1rem">
                <button class="tool-button" id="b64-encode">Encode </button>
                <button class="tool-button" id="b64-decode"> Decode</button>
            </div>
        `;
        const text = document.getElementById('b64-text');
        const base = document.getElementById('b64-base');
        document.getElementById('b64-encode').addEventListener('click', () => {
            try { base.value = btoa(text.value); } catch(e) { base.value = "Error encoding text."; }
        });
        document.getElementById('b64-decode').addEventListener('click', () => {
            try { text.value = atob(base.value); } catch(e) { text.value = "Error: Invalid Base64 string."; }
        });
    }
    
    function renderUrlCoder() {
        a.toolContent.innerHTML = `
             <div class="tool-grid-2col">
                <div class="tool-input-group"><label>Decoded</label><textarea id="url-decoded" class="tool-textarea"></textarea></div>
                <div class="tool-input-group"><label>Encoded</label><textarea id="url-encoded" class="tool-textarea"></textarea></div>
            </div>
            <div class="tool-controls-grid" style="margin-top: 1rem">
                <button class="tool-button" id="url-encode">Encode </button>
                <button class="tool-button" id="url-decode"> Decode</button>
            </div>
        `;
        const decoded = document.getElementById('url-decoded');
        const encoded = document.getElementById('url-encoded');
        document.getElementById('url-encode').addEventListener('click', () => {
            encoded.value = encodeURIComponent(decoded.value);
        });
        document.getElementById('url-decode').addEventListener('click', () => {
            try { decoded.value = decodeURIComponent(encoded.value); } catch (e) { decoded.value = "Error: Invalid URL encoding."; }
        });
    }
    
    function renderSlugifyText() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Input</label><input type="text" id="slug-input" class="tool-input"></div>
            <div class="tool-input-group"><label>URL Slug</label><input type="text" id="slug-output" class="tool-input" readonly></div>
        `;
        const input = document.getElementById('slug-input');
        const output = document.getElementById('slug-output');
        input.addEventListener('input', () => {
            output.value = input.value
                .toLowerCase()
                .trim()
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s_-]+/g, '-')
                .replace(/^-+|-+$/g, '');
        });
    }
    
    // --- INTERNET & NETWORKING ---
    
    function renderIpFinder() {
      a.toolContent.innerHTML = `<div id="ip-output" class="tool-output">Finding your IP...</div>`;
      const output = document.getElementById('ip-output');
      fetch('https://ipapi.co/json/')
        .then(res => res.json())
        .then(data => {
            output.innerHTML = `
                <div class="tool-output-grid">
                  <div class="item"><div class="label">IP Address</div><div class="value">${data.ip}</div></div>
                  <div class="item"><div class="label">City</div><div class="value">${data.city}</div></div>
                  <div class="item"><div class="label">Region</div><div class="value">${data.region}</div></div>
                  <div class="item"><div class="label">Country</div><div class="value">${data.country_name}</div></div>
                  <div class="item" style="grid-column: 1 / -1;"><div class="label">ISP</div><div class="value">${data.org}</div></div>
                </div>`;
        })
        .catch(err => output.innerHTML = 'Could not fetch IP information.');
    }
    
    function renderPingTool() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group" style="flex-direction: row; gap: var(--space-sm); align-items: center;">
                <input type="text" id="ping-host" class="tool-input" value="google.com">
                <button id="ping-btn" class="tool-button">Ping</button>
            </div>
            <div id="ping-output" class="terminal-output"></div>
            <p class="disclaimer">This is a simulation using HTTP requests, not a real ICMP ping.</p>
        `;
        
        const hostInput = document.getElementById('ping-host');
        const pingBtn = document.getElementById('ping-btn');
        const output = document.getElementById('ping-output');

        pingBtn.addEventListener('click', async () => {
            const host = hostInput.value;
            output.innerHTML = `Pinging ${host}...<br>`;
            pingBtn.disabled = true;

            for(let i = 0; i < 4; i++) {
                const startTime = performance.now();
                try {
                    await fetch(`https://${host}`, { method: 'HEAD', mode: 'no-cors', cache: 'no-cache' });
                    const endTime = performance.now();
                    const duration = Math.round(endTime - startTime);
                    output.innerHTML += `<div class="line success">Reply from ${host}: time=${duration}ms</div>`;
                } catch(e) {
                    output.innerHTML += `<div class="line error">Request timeout for ${host}</div>`;
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            pingBtn.disabled = false;
        });
    }
    
    function renderPortScanner() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group" style="flex-direction: row; gap: var(--space-sm); align-items: center;">
                <input type="text" id="port-host" class="tool-input" value="google.com">
                <button id="port-scan-btn" class="tool-button">Scan</button>
            </div>
            <div id="port-scan-output" class="terminal-output"></div>
            <p class="disclaimer">This is a simulation for educational purposes and does not perform real network scans.</p>
        `;
        const hostInput = document.getElementById('port-host');
        const scanBtn = document.getElementById('port-scan-btn');
        const output = document.getElementById('port-scan-output');

        scanBtn.addEventListener('click', async () => {
            const host = hostInput.value;
            output.innerHTML = `Scanning common ports on ${host}...<br>`;
            scanBtn.disabled = true;

            const commonPorts = { '80': 'HTTP', '443': 'HTTPS', '21': 'FTP', '22': 'SSH', '8080': 'HTTP Alt' };
            for(const port in commonPorts) {
                await new Promise(resolve => setTimeout(resolve, 500));
                const isOpen = Math.random() > 0.5; // Simulate open/closed
                const status = isOpen ? `<span class="success">Open</span>` : `<span class="error">Closed</span>`;
                output.innerHTML += `<div>Port ${port} (${commonPorts[port]}): ${status}</div>`;
            }
            scanBtn.disabled = false;
        });
    }

    function renderWhoisLookup() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group" style="flex-direction: row; gap: var(--space-sm); align-items: center;">
                <input type="text" id="whois-domain" class="tool-input" value="google.com">
                <button id="whois-btn" class="tool-button">Lookup</button>
            </div>
            <div id="whois-output" class="terminal-output"></div>
        `;
        const domainInput = document.getElementById('whois-domain');
        const lookupBtn = document.getElementById('whois-btn');
        const output = document.getElementById('whois-output');
        
        lookupBtn.addEventListener('click', () => {
            const domain = domainInput.value;
            output.textContent = `Fetching WHOIS for ${domain}...`;
            lookupBtn.disabled = true;
            fetch(`https://whois.freeaiapi.xyz/?domain=${domain}`)
              .then(res => res.text())
              .then(data => {
                  output.textContent = data;
              })
              .catch(() => output.textContent = `Error fetching WHOIS data for ${domain}.`)
              .finally(() => lookupBtn.disabled = false);
        });
    }
    
    function renderUrlShortener() {
        a.toolContent.innerHTML = `
            <div class="tool-tabs">
                <button class="tool-tab-btn tool-button active" data-mode="shorten">Shorten</button>
                <button class="tool-tab-btn tool-button tool-button-secondary" data-mode="expand">Expand</button>
            </div>
            <div id="url-shortener-content"></div>
        `;
        const content = document.getElementById('url-shortener-content');
        
        const renderContent = (mode) => {
            if (mode === 'shorten') {
                content.innerHTML = `
                    <div class="tool-input-group"><label>Long URL</label><input type="text" id="long-url" class="tool-input"></div>
                    <button id="shorten-btn" class="tool-button">Shorten</button>
                    <div class="tool-input-group" style="margin-top: 1rem;"><label>Short URL</label><input type="text" id="short-url" class="tool-input" readonly></div>
                `;
                document.getElementById('shorten-btn').addEventListener('click', async () => {
                    const longUrl = document.getElementById('long-url').value;
                    if (!longUrl) return;
                    document.getElementById('short-url').value = 'Shortening...';
                    try {
                        const res = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
                        const shortUrl = await res.text();
                        document.getElementById('short-url').value = shortUrl;
                    } catch(e) {
                        document.getElementById('short-url').value = 'Error shortening URL.';
                    }
                });
            } else { // expand
                content.innerHTML = `
                    <div class="tool-input-group"><label>Short URL</label><input type="text" id="short-url-expand" class="tool-input"></div>
                    <button id="expand-btn" class="tool-button">Expand</button>
                    <div class="tool-input-group" style="margin-top: 1rem;"><label>Long URL</label><input type="text" id="long-url-expand" class="tool-input" readonly></div>
                `;
                 document.getElementById('expand-btn').addEventListener('click', async () => {
                    const shortUrl = document.getElementById('short-url-expand').value;
                    if (!shortUrl) return;
                    document.getElementById('long-url-expand').value = 'Expanding...';
                    try {
                        // This API acts as a CORS proxy to follow the redirect
                        const res = await fetch(`https://api.redirect.link/?url=${encodeURIComponent(shortUrl)}`);
                        const data = await res.json();
                        document.getElementById('long-url-expand').value = data.destination;
                    } catch(e) {
                         document.getElementById('long-url-expand').value = 'Error expanding URL.';
                    }
                });
            }
        };
        
        document.querySelector('.tool-tabs').addEventListener('click', e => {
             if (e.target.tagName !== 'BUTTON') return;
             document.querySelectorAll('.tool-tab-btn').forEach(b => b.classList.replace('active', 'tool-button-secondary'));
             e.target.classList.replace('tool-button-secondary', 'active');
             renderContent(e.target.dataset.mode);
        });

        renderContent('shorten');
    }

    function renderBase32Coder() {
      // Basic Base32 implementation. For production, a library would be more robust.
      const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
      const b32Encode = (buffer) => {
        let bits = 0, value = 0, output = '';
        for (let i = 0; i < buffer.length; i++) {
          value = (value << 8) | buffer[i];
          bits += 8;
          while (bits >= 5) {
            output += alphabet[(value >>> (bits - 5)) & 31];
            bits -= 5;
          }
        }
        if (bits > 0) output += alphabet[(value << (5 - bits)) & 31];
        return output;
      };
      a.toolContent.innerHTML = `
        <div class="tool-input-group"><label>Text</label><textarea id="b32-text" class="tool-textarea"></textarea></div>
        <div class="tool-input-group"><label>Base32</label><textarea id="b32-base" class="tool-textarea"></textarea></div>
        <p class="disclaimer">This tool only supports encoding. Decoding is non-trivial in JS and omitted for simplicity.</p>
      `;
      const text = document.getElementById('b32-text');
      const base = document.getElementById('b32-base');
      text.addEventListener('input', () => {
        const textEncoder = new TextEncoder();
        base.value = b32Encode(textEncoder.encode(text.value));
      });
    }

    function renderMorseCode() {
        const morseMap = { 'A':'.-', 'B':'-...', 'C':'-.-.', 'D':'-..', 'E':'.', 'F':'..-.', 'G':'--.', 'H':'....', 'I':'..', 'J':'.---', 'K':'-.-', 'L':'.-..', 'M':'--', 'N':'-.', 'O':'---', 'P':'.--.', 'Q':'--.-', 'R':'.-.', 'S':'...', 'T':'-', 'U':'..-', 'V':'...-', 'W':'.--', 'X':'-..-', 'Y':'-.--', 'Z':'--..', '1':'.----', '2':'..---', '3':'...--', '4':'....-', '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.', '0':'-----', ' ': '/' };
        const reverseMorseMap = Object.fromEntries(Object.entries(morseMap).map(a => a.reverse()));
        
        a.toolContent.innerHTML = `
            <div class="tool-grid-2col">
                <div class="tool-input-group"><label>Text</label><textarea id="morse-text" class="tool-textarea"></textarea></div>
                <div class="tool-input-group"><label>Morse</label><textarea id="morse-code" class="tool-textarea"></textarea></div>
            </div>
            <button id="morse-audio-btn" class="tool-button"><svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg><span>Play Morse</span></button>
        `;
        
        const textIn = document.getElementById('morse-text');
        const morseIn = document.getElementById('morse-code');

        textIn.addEventListener('input', () => {
            morseIn.value = textIn.value.toUpperCase().split('').map(c => morseMap[c] || '').join(' ');
        });

        morseIn.addEventListener('input', () => {
            textIn.value = morseIn.value.trim().split(' ').map(c => reverseMorseMap[c] || '').join('');
        });

        document.getElementById('morse-audio-btn').addEventListener('click', () => {
            const code = morseIn.value;
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let time = audioContext.currentTime;
            const dot = 0.07;
            
            for(const char of code) {
                if (char === '.') {
                    const osc = audioContext.createOscillator();
                    osc.connect(audioContext.destination);
                    osc.start(time);
                    osc.stop(time + dot);
                    time += dot * 2;
                } else if (char === '-') {
                    const osc = audioContext.createOscillator();
                    osc.connect(audioContext.destination);
                    osc.start(time);
                    osc.stop(time + dot * 3);
                    time += dot * 4;
                } else if (char === ' ' || char === '/') {
                    time += dot * (char === '/' ? 7 : 3);
                }
            }
        });
    }

    async function renderTextEncrypt() {
        if (!window.crypto || !window.crypto.subtle) {
            a.toolContent.innerHTML = `<p>Error: Web Crypto API is not supported in this browser.</p>`;
            return;
        }
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Plain Text</label><textarea id="crypto-plain" class="tool-textarea"></textarea></div>
            <div class="tool-input-group"><label>Password</label><input type="password" id="crypto-pass" class="tool-input"></div>
            <div class="tool-input-group"><label>Encrypted (Base64)</label><textarea id="crypto-cipher" class="tool-textarea"></textarea></div>
            <div class="tool-controls-grid">
                <button class="tool-button" id="crypto-encrypt">Encrypt</button>
                <button class="tool-button" id="crypto-decrypt">Decrypt</button>
            </div>
        `;
        const plain = document.getElementById('crypto-plain');
        const pass = document.getElementById('crypto-pass');
        const cipher = document.getElementById('crypto-cipher');
        const enc = new TextEncoder();
        const dec = new TextDecoder();

        const getKey = async (password) => {
            const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), {name: "PBKDF2"}, false, ["deriveKey"]);
            return window.crypto.subtle.deriveKey({ "name": "PBKDF2", "salt": enc.encode("some-salt"), "iterations": 100000, "hash": "SHA-256" }, keyMaterial, { "name": "AES-GCM", "length": 256}, true, [ "encrypt", "decrypt" ]);
        };

        document.getElementById('crypto-encrypt').addEventListener('click', async () => {
            try {
                const key = await getKey(pass.value);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, enc.encode(plain.value));
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);
                cipher.value = btoa(String.fromCharCode.apply(null, combined));
            } catch (e) { cipher.value = 'Encryption failed.'; }
        });
        document.getElementById('crypto-decrypt').addEventListener('click', async () => {
            try {
                const key = await getKey(pass.value);
                const combined = Uint8Array.from(atob(cipher.value), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const data = combined.slice(12);
                const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
                plain.value = dec.decode(decrypted);
            } catch (e) { plain.value = 'Decryption failed. Check password or data.'; }
        });
    }

    function renderHashGenerator() {
         if (!window.crypto || !window.crypto.subtle) {
            a.toolContent.innerHTML = `<p>Error: Web Crypto API is not supported in this browser.</p>`;
            return;
        }
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Input</label><textarea id="hash-input" class="tool-textarea"></textarea></div>
            <div class="tool-input-group"><label>Algorithm</label><select id="hash-algo" class="tool-select"><option>SHA-256</option><option>SHA-384</option><option>SHA-512</option></select></div>
            <div class="tool-input-group"><label>Hash Output</label><textarea id="hash-output" class="tool-textarea" readonly></textarea></div>
        `;
        const input = document.getElementById('hash-input');
        const algo = document.getElementById('hash-algo');
        const output = document.getElementById('hash-output');

        const generateHash = async () => {
            const data = new TextEncoder().encode(input.value);
            const hashBuffer = await crypto.subtle.digest(algo.value, data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            output.value = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        };
        input.addEventListener('input', generateHash);
        algo.addEventListener('change', generateHash);
        generateHash();
    }
    
    // --- UTILITIES ---
    function renderUnitConverterHub() {
        const hubData = { length: converterData.length, weight: converterData.weight, speed: converterData.speed, area: converterData.area, volume: converterData.volume };
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label>Conversion Type</label>
                <select id="hub-type" class="tool-select">
                    ${Object.keys(hubData).map(k => `<option value="${k}">${k.charAt(0).toUpperCase() + k.slice(1)}</option>`).join('')}
                </select>
            </div>
            <div class="tool-input-group">
                <label>Input Value</label>
                <div style="display: flex; gap: var(--space-sm);">
                    <input type="number" id="hub-input" class="tool-input" value="1">
                    <select id="hub-unit" class="tool-select"></select>
                </div>
            </div>
            <div id="hub-output" class="tool-output tool-output-grid"></div>
        `;

        const typeSelect = document.getElementById('hub-type');
        const unitSelect = document.getElementById('hub-unit');
        const input = document.getElementById('hub-input');
        const output = document.getElementById('hub-output');

        const updateUnits = () => {
            const type = typeSelect.value;
            const units = Object.keys(hubData[type].units);
            unitSelect.innerHTML = units.map(u => `<option value="${u}">${u}</option>`).join('');
            unitSelect.value = hubData[type].default[0];
            updateResults();
        };

        const updateResults = () => {
            const type = typeSelect.value;
            const data = hubData[type];
            const sourceUnit = unitSelect.value;
            const sourceValue = parseFloat(input.value) || 0;
            
            const baseValue = sourceValue * data.units[sourceUnit];
            output.innerHTML = '';

            for (const targetUnit in data.units) {
                const targetValue = baseValue / data.units[targetUnit];
                const item = document.createElement('div');
                item.className = 'item';
                item.innerHTML = `
                    <div class="label">${targetUnit}</div>
                    <div class="value">${parseFloat(targetValue.toPrecision(6))}</div>
                `;
                output.appendChild(item);
            }
        };

        typeSelect.addEventListener('change', updateUnits);
        unitSelect.addEventListener('change', updateResults);
        input.addEventListener('input', updateResults);

        updateUnits();
    }

    function renderBatteryStatus() {
        a.toolContent.innerHTML = `<div class="battery-container"><p>Checking battery status...</p></div>`;
        const container = a.toolContent.querySelector('.battery-container');
        
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                const update = () => {
                    container.innerHTML = `
                        <div class="battery-visual ${battery.charging ? 'battery-charging':''}">
                            <div class="battery-level" style="height: ${battery.level * 100}%"></div>
                            <div class="battery-charging-icon"></div>
                        </div>
                        <div class="battery-info">
                            <div class="battery-percent">${Math.round(battery.level * 100)}%</div>
                            <div class="battery-status-text">${battery.charging ? 'Charging' : 'On Battery'}</div>
                        </div>
                    `;
                };
                update();
                battery.addEventListener('levelchange', update);
                battery.addEventListener('chargingchange', update);
            });
        } else {
            container.innerHTML = `<p>Battery Status API not supported.</p>`;
        }
    }
    
    function renderClipboardManager() {
        let history = JSON.parse(sessionStorage.getItem('clipboardHistory') || '[]');
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label>Current Clipboard</label>
                <textarea id="clipboard-current" class="tool-textarea" readonly></textarea>
                <button id="clipboard-read" class="tool-button">Read Clipboard</button>
            </div>
             <div class="tool-input-group">
                <label>History (last 5)</label>
                <div id="clipboard-history" class="list-items" style="max-height: 200px;"></div>
            </div>
        `;
        
        const currentEl = document.getElementById('clipboard-current');
        const historyEl = document.getElementById('clipboard-history');

        const renderHistory = () => {
            historyEl.innerHTML = '';
            history.forEach(item => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<span class="list-item-text"></span>`;
                div.querySelector('span').textContent = item.length > 50 ? item.substring(0, 50) + '...' : item;
                div.addEventListener('click', () => navigator.clipboard.writeText(item));
                historyEl.appendChild(div);
            });
        };

        document.getElementById('clipboard-read').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                currentEl.value = text;
                if (text && !history.includes(text)) {
                    history.unshift(text);
                    history = history.slice(0, 5); // Keep last 5
                    
                    sessionStorage.setItem('clipboardHistory', JSON.stringify(history));
                    renderHistory();
                }
            } catch (e) {
                currentEl.value = 'Permission to read clipboard denied.';
            }
        });
        renderHistory();
    }
    
    function renderNotesApp() {
        let notes = JSON.parse(localStorage.getItem('notesApp') || '[{"id": 1, "content": "Welcome to notes!"}]');
        let currentNoteId = notes[0]?.id || null;

        a.toolContent.innerHTML = `
            <div class="list-app-container">
                <div class="list-sidebar">
                    <div id="notes-list" class="list-items"></div>
                    <button id="note-add" class="tool-button" style="margin-top: var(--space-sm)">New Note</button>
                </div>
                <div class="editor-main">
                    <textarea id="note-editor" class="tool-textarea"></textarea>
                </div>
            </div>
        `;
        
        const listEl = document.getElementById('notes-list');
        const editorEl = document.getElementById('note-editor');

        const saveNotes = () => localStorage.setItem('notesApp', JSON.stringify(notes));
        
        const renderList = () => {
            listEl.innerHTML = '';
            notes.forEach(note => {
                const item = document.createElement('div');
                item.className = `list-item ${note.id === currentNoteId ? 'active' : ''}`;
                item.innerHTML = `<span class="list-item-text"></span><button class="list-delete-btn"></button>`;
                item.querySelector('.list-item-text').textContent = note.content.split('\n')[0] || 'New Note';
                item.addEventListener('click', () => { currentNoteId = note.id; render(); });
                item.querySelector('.list-delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    notes = notes.filter(n => n.id !== note.id);
                    if (currentNoteId === note.id) currentNoteId = notes[0]?.id || null;
                    saveNotes();
                    render();
                });
                listEl.appendChild(item);
            });
        };
        
        const renderEditor = () => {
            const note = notes.find(n => n.id === currentNoteId);
            editorEl.value = note ? note.content : '';
        };
        
        const render = () => { renderList(); renderEditor(); };
        
        document.getElementById('note-add').addEventListener('click', () => {
            const newNote = { id: Date.now(), content: '' };
            notes.unshift(newNote);
            currentNoteId = newNote.id;
            saveNotes();
            render();
            editorEl.focus();
        });

        editorEl.addEventListener('input', () => {
            const note = notes.find(n => n.id === currentNoteId);
            if (note) {
                note.content = editorEl.value;
                saveNotes();
                renderList(); // Update title in list
            }
        });
        
        render();
    }
    
    function renderTodoList() {
        let todos = JSON.parse(localStorage.getItem('todoList') || '[]');
        a.toolContent.innerHTML = `
            <div style="display: flex; gap: var(--space-sm); margin-bottom: var(--space-md);">
                <input type="text" id="todo-input" class="tool-input" placeholder="Add a new task...">
                <button id="todo-add" class="tool-button">Add</button>
            </div>
            <div id="todo-list" style="display: flex; flex-direction: column; gap: var(--space-sm);"></div>
        `;
        
        const input = document.getElementById('todo-input');
        const listEl = document.getElementById('todo-list');

        const save = () => localStorage.setItem('todoList', JSON.stringify(todos));
        
        const render = () => {
            listEl.innerHTML = '';
            todos.forEach(todo => {
                const item = document.createElement('div');
                item.className = `todo-list-item ${todo.completed ? 'completed' : ''}`;
                item.innerHTML = `
                    <input type="checkbox" ${todo.completed ? 'checked' : ''}>
                    <span></span>
                    <button class="list-delete-btn"></button>
                `;
                item.querySelector('span').textContent = todo.text;
                item.querySelector('input').addEventListener('change', () => {
                    todo.completed = !todo.completed;
                    save();
                    render();
                });
                item.querySelector('button').addEventListener('click', () => {
                    todos = todos.filter(t => t.id !== todo.id);
                    save();
                    render();
                });
                listEl.appendChild(item);
            });
        };

        document.getElementById('todo-add').addEventListener('click', () => {
            if (input.value.trim()) {
                todos.push({ id: Date.now(), text: input.value.trim(), completed: false });
                input.value = '';
                save();
                render();
            }
        });
        
        render();
    }
    
    function renderReminderApp() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group"><label>Remind me to...</label><input type="text" id="reminder-text" class="tool-input"></div>
            <div class="tool-input-group"><label>At this time</label><input type="datetime-local" id="reminder-time" class="tool-input"></div>
            <button id="reminder-set" class="tool-button">Set Reminder</button>
            <p class="disclaimer">This will only work if this page is open in your browser.</p>
        `;

        document.getElementById('reminder-set').addEventListener('click', () => {
            const text = document.getElementById('reminder-text').value;
            const time = document.getElementById('reminder-time').value;
            if (!text || !time) return alert('Please set text and time.');
            
            const targetTime = new Date(time).getTime();
            const delay = targetTime - Date.now();

            if (delay <= 0) return alert('Please choose a time in the future.');

            Notification.requestPermission().then(perm => {
                if (perm === 'granted') {
                    setTimeout(() => new Notification('Reminder', { body: text }), delay);
                    alert('Reminder set!');
                } else {
                    alert('Please allow notifications to set reminders.');
                }
            });
        });
    }

    function renderWeatherApp() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group" style="flex-direction: row; gap: var(--space-sm);">
                <input type="text" id="weather-city" class="tool-input" placeholder="Enter city name...">
                <button id="weather-search" class="tool-button">Search</button>
            </div>
            <div id="weather-output"></div>
        `;

        const output = document.getElementById('weather-output');
        
        const fetchWeather = (city) => {
            output.innerHTML = `<p>Loading weather for ${city}...</p>`;
            fetch(`https://wttr.in/${encodeURIComponent(city)}?format=j1`)
                .then(res => res.json())
                .then(data => {
                    const current = data.current_condition[0];
                    output.innerHTML = `
                        <div class="weather-card">
                            <h3 class="weather-location">${data.nearest_area[0].areaName[0].value}</h3>
                            <div class="weather-main">
                                <div class="weather-icon">${current.weatherIconUrl[0].value}</div>
                                <div class="weather-temp">${current.temp_C}C</div>
                            </div>
                            <p class="weather-desc">${current.weatherDesc[0].value}</p>
                            <div class="weather-details">
                                <div><div class="label">Feels Like</div><div class="value">${current.FeelsLikeC}C</div></div>
                                <div><div class="label">Wind</div><div class="value">${current.windspeedKmph} km/h</div></div>
                                <div><div class="label">Humidity</div><div class="value">${current.humidity}%</div></div>
                            </div>
                        </div>
                    `;
                })
                .catch(() => output.innerHTML = `<p>Could not get weather for ${city}.</p>`);
        };

        document.getElementById('weather-search').addEventListener('click', () => {
            const city = document.getElementById('weather-city').value;
            if (city) fetchWeather(city);
        });
        
        // Auto-detect location
        output.innerHTML = `<p>Getting your location...</p>`;
        navigator.geolocation.getCurrentPosition(
            (pos) => fetchWeather(`${pos.coords.latitude},${pos.coords.longitude}`),
            () => { output.innerHTML = `<p>Could not get location. Please search manually.</p>`; }
        );
    }
    
    function renderSoundMeter() {
        a.toolContent.innerHTML = `
            <div class="sound-meter-container">
                <div id="sound-meter-gauge"></div>
                <div id="sound-meter-db">-- dB</div>
                <button id="sound-meter-start" class="tool-button">Start Meter</button>
            </div>
        `;

        document.getElementById('sound-meter-start').addEventListener('click', async (e) => {
            if (soundMeter.stream) return;
            e.target.textContent = 'Starting...';
            try {
                soundMeter.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                soundMeter.analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(soundMeter.stream);
                source.connect(soundMeter.analyser);
                
                const dataArray = new Uint8Array(soundMeter.analyser.frequencyBinCount);
                
                const update = () => {
                    soundMeter.analyser.getByteFrequencyData(dataArray);
                    const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    const db = Math.round(avg * 0.5); // Approximate dB
                    document.getElementById('sound-meter-db').textContent = `${db} dB`;
                    // Update gauge here if using a library
                    soundMeter.animationFrameId = requestAnimationFrame(update);
                };
                update();
                e.target.style.display = 'none';

            } catch (err) {
                document.getElementById('sound-meter-db').textContent = 'Mic Error';
                e.target.textContent = 'Start Meter';
            }
        });
    }

    function renderCompass() {
        a.toolContent.innerHTML = `<div class="compass"><p>Loading...</p></div>`;
        const container = a.toolContent.querySelector('.compass');

        if ('DeviceOrientationEvent' in window) {
            container.innerHTML = `
                <div class="compass-pointer"></div>
                <div id="compass-dial" class="compass-dial"></div>
                <div id="compass-heading" class="compass-heading">N</div>
            `;
            const dial = document.getElementById('compass-dial');
            const headingEl = document.getElementById('compass-heading');

            const handler = (e) => {
                const heading = e.webkitCompassHeading || (360 - e.alpha);
                if (heading) {
                    dial.style.transform = `rotate(${-heading}deg)`;
                    headingEl.textContent = `${Math.round(heading)}`;
                }
            };
            window.addEventListener('deviceorientation', handler);
            // Store handler to remove it later
            currentToolInterval = () => window.removeEventListener('deviceorientation', handler);
        } else {
            container.innerHTML = `<p>Compass not supported on this device.</p>`;
        }
    }

    function renderScreenLight() {
        let lightOn = false;
        const lightDiv = document.createElement('div');
        lightDiv.className = 'screen-light-active';
        
        a.toolContent.innerHTML = `<button id="light-toggle" class="tool-button">Turn On Light</button>`;
        const btn = document.getElementById('light-toggle');

        btn.addEventListener('click', () => {
            lightOn = !lightOn;
            if (lightOn) {
                document.body.appendChild(lightDiv);
                btn.textContent = 'Turn Off Light';
            } else {
                document.body.removeChild(lightDiv);
                btn.textContent = 'Turn On Light';
            }
        });
        // Store cleanup function
        currentToolInterval = () => { if (lightOn) document.body.removeChild(lightDiv); };
    }

    // --- DEVICE TOOLS ---

    function renderDeviceInfoViewer() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="device-platform">--</div>
                    <div class="label">Platform</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-browser">--</div>
                    <div class="label">Browser</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-screen">--</div>
                    <div class="label">Screen Resolution</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-viewport">--</div>
                    <div class="label">Viewport Size</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-memory">--</div>
                    <div class="label">Device Memory</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-cores">--</div>
                    <div class="label">CPU Cores</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-connection">--</div>
                    <div class="label">Connection Type</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-language">--</div>
                    <div class="label">Language</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-timezone">--</div>
                    <div class="label">Timezone</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="device-cookies">--</div>
                    <div class="label">Cookies Enabled</div>
                </div>
            </div>
        `;

        // Populate device information
        document.getElementById('device-platform').textContent = navigator.platform || 'Unknown';
        document.getElementById('device-browser').textContent = navigator.userAgent.split(' ').pop().split('/')[0] || 'Unknown';
        document.getElementById('device-screen').textContent = `${screen.width}${screen.height}`;
        document.getElementById('device-viewport').textContent = `${window.innerWidth}${window.innerHeight}`;
        document.getElementById('device-memory').textContent = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';
        document.getElementById('device-cores').textContent = navigator.hardwareConcurrency || 'Unknown';
        document.getElementById('device-connection').textContent = navigator.connection?.effectiveType || 'Unknown';
        document.getElementById('device-language').textContent = navigator.language || 'Unknown';
        document.getElementById('device-timezone').textContent = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown';
        document.getElementById('device-cookies').textContent = navigator.cookieEnabled ? 'Yes' : 'No';
    }

    function renderStorageCheck() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="storage-quota">--</div>
                    <div class="label">Storage Quota</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="storage-usage">--</div>
                    <div class="label">Storage Used</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="storage-available">--</div>
                    <div class="label">Available Space</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="storage-local">--</div>
                    <div class="label">LocalStorage</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="storage-session">--</div>
                    <div class="label">SessionStorage</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="storage-indexeddb">--</div>
                    <div class="label">IndexedDB</div>
                </div>
            </div>
            <button id="clear-storage" class="tool-button" style="margin-top: var(--space-lg);">Clear Browser Storage</button>
        `;

        // Check storage quota
        if ('storage' in navigator && 'estimate' in navigator.storage) {
            navigator.storage.estimate().then(estimate => {
                const quota = estimate.quota ? (estimate.quota / (1024 * 1024 * 1024)).toFixed(2) + ' GB' : 'Unknown';
                const usage = estimate.usage ? (estimate.usage / (1024 * 1024)).toFixed(2) + ' MB' : 'Unknown';
                const available = estimate.quota && estimate.usage ? 
                    ((estimate.quota - estimate.usage) / (1024 * 1024 * 1024)).toFixed(2) + ' GB' : 'Unknown';
                
                document.getElementById('storage-quota').textContent = quota;
                document.getElementById('storage-usage').textContent = usage;
                document.getElementById('storage-available').textContent = available;
            });
        }

        // Check individual storage types
        try {
            const localStorageSize = JSON.stringify(localStorage).length;
            document.getElementById('storage-local').textContent = (localStorageSize / 1024).toFixed(2) + ' KB';
        } catch (e) {
            document.getElementById('storage-local').textContent = 'Unavailable';
        }

        try {
            const sessionStorageSize = JSON.stringify(sessionStorage).length;
            document.getElementById('storage-session').textContent = (sessionStorageSize / 1024).toFixed(2) + ' KB';
        } catch (e) {
            document.getElementById('storage-session').textContent = 'Unavailable';
        }

        document.getElementById('storage-indexeddb').textContent = 'indexedDB' in window ? 'Available' : 'Not Supported';

        document.getElementById('clear-storage').addEventListener('click', () => {
            if (confirm('This will clear all browser storage for this site. Continue?')) {
                localStorage.clear();
                sessionStorage.clear();
                if ('caches' in window) {
                    caches.keys().then(names => names.forEach(name => caches.delete(name)));
                }
                alert('Storage cleared successfully!');
                location.reload();
            }
        });
    }

    function renderSpeedTest() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="download-speed">--</div>
                    <div class="label">Download Speed</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="upload-speed">--</div>
                    <div class="label">Upload Speed</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="ping-latency">--</div>
                    <div class="label">Ping</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="jitter">--</div>
                    <div class="label">Jitter</div>
                </div>
            </div>
            <button id="start-speed-test" class="tool-button" style="margin-top: var(--space-lg);">Start Speed Test</button>
            <div id="speed-test-progress" style="display: none; margin-top: var(--space-md); text-align: center;">
                <div class="value" style="color: var(--color-primary);">Testing...</div>
            </div>
            <p class="disclaimer">This is a simplified speed test using image downloads and may not reflect actual connection speeds.</p>
        `;

        document.getElementById('start-speed-test').addEventListener('click', async () => {
            const button = document.getElementById('start-speed-test');
            const progress = document.getElementById('speed-test-progress');
            
            button.disabled = true;
            button.textContent = 'Testing...';
            progress.style.display = 'block';

            try {
                // Test ping
                const pingStart = performance.now();
                await fetch('https://httpbin.org/get', { method: 'HEAD', cache: 'no-cache' });
                const ping = Math.round(performance.now() - pingStart);
                document.getElementById('ping-latency').textContent = `${ping} ms`;

                // Test download speed (simplified)
                const downloadStart = performance.now();
                const response = await fetch('https://httpbin.org/bytes/1000000', { cache: 'no-cache' });
                await response.blob();
                const downloadTime = (performance.now() - downloadStart) / 1000;
                const downloadSpeed = (1 / downloadTime).toFixed(2);
                document.getElementById('download-speed').textContent = `${downloadSpeed} MB/s`;

                // Simulate upload test
                const uploadSpeed = (downloadSpeed * 0.3).toFixed(2);
                document.getElementById('upload-speed').textContent = `${uploadSpeed} MB/s`;

                // Calculate jitter (simplified)
                const jitter = Math.round(ping * 0.1);
                document.getElementById('jitter').textContent = `${jitter} ms`;

            } catch (error) {
                alert('Speed test failed. Please check your connection.');
            }

            button.disabled = false;
            button.textContent = 'Start Speed Test';
            progress.style.display = 'none';
        });
    }

    function renderScreenRuler() {
        a.toolContent.innerHTML = `
            <div class="screen-ruler" id="ruler-container">
                <div class="ruler-line ruler-horizontal" id="h-line"></div>
                <div class="ruler-line ruler-vertical" id="v-line"></div>
                <div style="padding: var(--space-lg); text-align: center;">
                    <p>Move your mouse to measure distances on screen</p>
                    <div id="ruler-coords" style="margin-top: var(--space-md); font-family: monospace; font-size: 1.2rem;">
                        X: 0px, Y: 0px
                    </div>
                </div>
            </div>
            <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                <button id="toggle-ruler" class="tool-button">Toggle Ruler</button>
                <button id="reset-ruler" class="tool-button tool-button-secondary">Reset</button>
            </div>
        `;

        const container = document.getElementById('ruler-container');
        const hLine = document.getElementById('h-line');
        const vLine = document.getElementById('v-line');
        const coords = document.getElementById('ruler-coords');
        let rulerActive = true;

        const updateRuler = (e) => {
            if (!rulerActive) return;
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            hLine.style.top = `${y}px`;
            vLine.style.left = `${x}px`;
            coords.textContent = `X: ${Math.round(x)}px, Y: ${Math.round(y)}px`;
        };

        container.addEventListener('mousemove', updateRuler);

        document.getElementById('toggle-ruler').addEventListener('click', () => {
            rulerActive = !rulerActive;
            hLine.style.display = rulerActive ? 'block' : 'none';
            vLine.style.display = rulerActive ? 'block' : 'none';
            document.getElementById('toggle-ruler').textContent = rulerActive ? 'Hide Ruler' : 'Show Ruler';
        });

        document.getElementById('reset-ruler').addEventListener('click', () => {
            hLine.style.top = '50%';
            vLine.style.left = '50%';
            coords.textContent = 'X: 0px, Y: 0px';
        });
    }

    function renderColorPicker() {
        a.toolContent.innerHTML = `
            <div class="color-picker-container">
                <div class="color-preview" id="color-preview" style="background-color: #3B82F6;"></div>
                <input type="color" id="color-input" class="tool-input" value="#3B82F6" style="width: 100%; height: 50px;">
                <div class="color-info">
                    <div class="color-info-item">
                        <div class="value" id="hex-value">#3B82F6</div>
                        <div class="label">HEX</div>
                    </div>
                    <div class="color-info-item">
                        <div class="value" id="rgb-value">59, 130, 246</div>
                        <div class="label">RGB</div>
                    </div>
                    <div class="color-info-item">
                        <div class="value" id="hsl-value">217, 91%, 60%</div>
                        <div class="label">HSL</div>
                    </div>
                </div>
                <div class="tool-controls-grid" style="margin-top: var(--space-lg);">
                    <button id="copy-hex" class="tool-button">Copy HEX</button>
                    <button id="copy-rgb" class="tool-button">Copy RGB</button>
                    <button id="random-color" class="tool-button tool-button-secondary">Random Color</button>
                </div>
            </div>
        `;

        const colorInput = document.getElementById('color-input');
        const colorPreview = document.getElementById('color-preview');
        const hexValue = document.getElementById('hex-value');
        const rgbValue = document.getElementById('rgb-value');
        const hslValue = document.getElementById('hsl-value');

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function updateColorInfo(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return;

            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            
            colorPreview.style.backgroundColor = hex;
            hexValue.textContent = hex.toUpperCase();
            rgbValue.textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
            hslValue.textContent = `${hsl.h}, ${hsl.s}%, ${hsl.l}%`;
        }

        colorInput.addEventListener('input', (e) => {
            updateColorInfo(e.target.value);
        });

        document.getElementById('copy-hex').addEventListener('click', () => {
            navigator.clipboard.writeText(hexValue.textContent);
        });

        document.getElementById('copy-rgb').addEventListener('click', () => {
            navigator.clipboard.writeText(`rgb(${rgbValue.textContent})`);
        });

        document.getElementById('random-color').addEventListener('click', () => {
            const randomHex = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            colorInput.value = randomHex;
            updateColorInfo(randomHex);
        });

        updateColorInfo('#3B82F6');
    }

    function renderScreenSplitter() {
        a.toolContent.innerHTML = `
            <div class="tool-controls-grid">
                <button id="split-vertical" class="tool-button">Split Vertical</button>
                <button id="split-horizontal" class="tool-button">Split Horizontal</button>
                <button id="split-quad" class="tool-button">Quad Split</button>
                <button id="split-reset" class="tool-button tool-button-secondary">Reset</button>
            </div>
            <div id="split-preview" style="margin-top: var(--space-lg); height: 300px; border: 2px solid var(--color-border); border-radius: var(--radius-md); position: relative; background: var(--color-bg-secondary);">
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                    <p>Screen Split Preview</p>
                    <p style="font-size: 0.9rem; color: var(--color-text-secondary); margin-top: var(--space-xs);">Select a split mode above</p>
                </div>
            </div>
            <p class="disclaimer">This tool provides visual guides for screen splitting. Use your OS window management features for actual window splitting.</p>
        `;

        const preview = document.getElementById('split-preview');

        function createSplitPreview(type) {
            preview.innerHTML = '';
            
            switch(type) {
                case 'vertical':
                    preview.innerHTML = `
                        <div style="position: absolute; left: 0; top: 0; width: 50%; height: 100%; background: var(--color-primary); opacity: 0.3; border-right: 2px solid var(--color-primary);"></div>
                        <div style="position: absolute; right: 0; top: 0; width: 50%; height: 100%; background: var(--color-secondary); opacity: 0.3;"></div>
                        <div style="position: absolute; top: 50%; left: 25%; transform: translate(-50%, -50%); color: var(--color-primary); font-weight: bold;">Left</div>
                        <div style="position: absolute; top: 50%; right: 25%; transform: translate(50%, -50%); color: var(--color-secondary); font-weight: bold;">Right</div>
                    `;
                    break;
                case 'horizontal':
                    preview.innerHTML = `
                        <div style="position: absolute; left: 0; top: 0; width: 100%; height: 50%; background: var(--color-primary); opacity: 0.3; border-bottom: 2px solid var(--color-primary);"></div>
                        <div style="position: absolute; left: 0; bottom: 0; width: 100%; height: 50%; background: var(--color-secondary); opacity: 0.3;"></div>
                        <div style="position: absolute; top: 25%; left: 50%; transform: translate(-50%, -50%); color: var(--color-primary); font-weight: bold;">Top</div>
                        <div style="position: absolute; bottom: 25%; left: 50%; transform: translate(-50%, 50%); color: var(--color-secondary); font-weight: bold;">Bottom</div>
                    `;
                    break;
                case 'quad':
                    preview.innerHTML = `
                        <div style="position: absolute; left: 0; top: 0; width: 50%; height: 50%; background: var(--color-primary); opacity: 0.3; border-right: 1px solid var(--color-primary); border-bottom: 1px solid var(--color-primary);"></div>
                        <div style="position: absolute; right: 0; top: 0; width: 50%; height: 50%; background: var(--color-secondary); opacity: 0.3; border-bottom: 1px solid var(--color-secondary);"></div>
                        <div style="position: absolute; left: 0; bottom: 0; width: 50%; height: 50%; background: var(--color-accent); opacity: 0.3; border-right: 1px solid var(--color-accent);"></div>
                        <div style="position: absolute; right: 0; bottom: 0; width: 50%; height: 50%; background: var(--color-text-secondary); opacity: 0.3;"></div>
                        <div style="position: absolute; top: 25%; left: 25%; transform: translate(-50%, -50%); color: var(--color-primary); font-weight: bold; font-size: 0.9rem;">1</div>
                        <div style="position: absolute; top: 25%; right: 25%; transform: translate(50%, -50%); color: var(--color-secondary); font-weight: bold; font-size: 0.9rem;">2</div>
                        <div style="position: absolute; bottom: 25%; left: 25%; transform: translate(-50%, 50%); color: var(--color-accent); font-weight: bold; font-size: 0.9rem;">3</div>
                        <div style="position: absolute; bottom: 25%; right: 25%; transform: translate(50%, 50%); color: var(--color-text-secondary); font-weight: bold; font-size: 0.9rem;">4</div>
                    `;
                    break;
            }
        }

        document.getElementById('split-vertical').addEventListener('click', () => createSplitPreview('vertical'));
        document.getElementById('split-horizontal').addEventListener('click', () => createSplitPreview('horizontal'));
        document.getElementById('split-quad').addEventListener('click', () => createSplitPreview('quad'));
        document.getElementById('split-reset').addEventListener('click', () => {
            preview.innerHTML = `
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                    <p>Screen Split Preview</p>
                    <p style="font-size: 0.9rem; color: var(--color-text-secondary); margin-top: var(--space-xs);">Select a split mode above</p>
                </div>
            `;
        });
    }

    function renderClipboardViewer() {
        a.toolContent.innerHTML = `
            <div class="tool-input-group">
                <label>Current Clipboard Content</label>
                <textarea id="clipboard-content" class="tool-textarea" readonly placeholder="Click 'Read Clipboard' to view content"></textarea>
            </div>
            <div class="tool-controls-grid">
                <button id="read-clipboard" class="tool-button">Read Clipboard</button>
                <button id="clear-clipboard" class="tool-button tool-button-secondary">Clear Display</button>
                <button id="copy-to-clipboard" class="tool-button tool-button-secondary">Copy Text</button>
            </div>
            <div class="tool-input-group">
                <label>Write to Clipboard</label>
                <textarea id="clipboard-write" class="tool-textarea" placeholder="Enter text to copy to clipboard"></textarea>
                <button id="write-clipboard" class="tool-button" style="margin-top: var(--space-sm);">Copy to Clipboard</button>
            </div>
            <p class="disclaimer">This tool requires clipboard permissions. Some browsers may prompt for permission.</p>
        `;

        const contentArea = document.getElementById('clipboard-content');
        const writeArea = document.getElementById('clipboard-write');

        document.getElementById('read-clipboard').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                contentArea.value = text || '(Clipboard is empty)';
            } catch (err) {
                contentArea.value = 'Error: Unable to read clipboard. Permission denied or not supported.';
            }
        });

        document.getElementById('clear-clipboard').addEventListener('click', () => {
            contentArea.value = '';
        });

        document.getElementById('copy-to-clipboard').addEventListener('click', async () => {
            if (contentArea.value) {
                try {
                    await navigator.clipboard.writeText(contentArea.value);
                    alert('Content copied to clipboard!');
                } catch (err) {
                    alert('Failed to copy to clipboard.');
                }
            }
        });

        document.getElementById('write-clipboard').addEventListener('click', async () => {
            if (writeArea.value) {
                try {
                    await navigator.clipboard.writeText(writeArea.value);
                    alert('Text copied to clipboard!');
                    writeArea.value = '';
                } catch (err) {
                    alert('Failed to copy to clipboard.');
                }
            }
        });
    }

    function renderThemeDetector() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="color-scheme">--</div>
                    <div class="label">Color Scheme</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="reduced-motion">--</div>
                    <div class="label">Reduced Motion</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="high-contrast">--</div>
                    <div class="label">High Contrast</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="forced-colors">--</div>
                    <div class="label">Forced Colors</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="display-mode">--</div>
                    <div class="label">Display Mode</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="orientation">--</div>
                    <div class="label">Orientation</div>
                </div>
            </div>
            <button id="refresh-theme" class="tool-button" style="margin-top: var(--space-lg);">Refresh Detection</button>
        `;

        function detectThemePreferences() {
            // Color scheme
            const colorScheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'Dark' : 
                               window.matchMedia('(prefers-color-scheme: light)').matches ? 'Light' : 'No Preference';
            document.getElementById('color-scheme').textContent = colorScheme;

            // Reduced motion
            const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 'Yes' : 'No';
            document.getElementById('reduced-motion').textContent = reducedMotion;

            // High contrast
            const highContrast = window.matchMedia('(prefers-contrast: high)').matches ? 'Yes' : 'No';
            document.getElementById('high-contrast').textContent = highContrast;

            // Forced colors
            const forcedColors = window.matchMedia('(forced-colors: active)').matches ? 'Active' : 'None';
            document.getElementById('forced-colors').textContent = forcedColors;

            // Display mode
            const displayMode = window.matchMedia('(display-mode: standalone)').matches ? 'Standalone' :
                               window.matchMedia('(display-mode: fullscreen)').matches ? 'Fullscreen' :
                               window.matchMedia('(display-mode: minimal-ui)').matches ? 'Minimal UI' : 'Browser';
            document.getElementById('display-mode').textContent = displayMode;

            // Orientation
            const orientation = window.matchMedia('(orientation: portrait)').matches ? 'Portrait' : 'Landscape';
            document.getElementById('orientation').textContent = orientation;
        }

        document.getElementById('refresh-theme').addEventListener('click', detectThemePreferences);
        detectThemePreferences();

        // Listen for changes
        const mediaQueries = [
            '(prefers-color-scheme: dark)',
            '(prefers-reduced-motion: reduce)',
            '(prefers-contrast: high)',
            '(forced-colors: active)',
            '(orientation: portrait)'
        ];

        mediaQueries.forEach(query => {
            window.matchMedia(query).addEventListener('change', detectThemePreferences);
        });
    }

    function renderMicTester() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="mic-status">Not Started</div>
                    <div class="label">Microphone Status</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="mic-level">0</div>
                    <div class="label">Input Level</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="mic-device">--</div>
                    <div class="label">Device Name</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="sample-rate">--</div>
                    <div class="label">Sample Rate</div>
                </div>
            </div>
            <div class="tool-controls-grid" style="margin-top: var(--space-lg);">
                <button id="start-mic-test" class="tool-button">Start Test</button>
                <button id="stop-mic-test" class="tool-button tool-button-secondary" disabled>Stop Test</button>
            </div>
            <div id="mic-visualizer" style="margin-top: var(--space-lg); height: 100px; background: var(--color-bg-secondary); border-radius: var(--radius-md); position: relative; overflow: hidden;">
                <canvas id="mic-canvas" width="400" height="100" style="width: 100%; height: 100%;"></canvas>
            </div>
        `;

        let micStream = null;
        let audioContext = null;
        let analyser = null;
        let animationId = null;

        const canvas = document.getElementById('mic-canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-mic-test');
        const stopBtn = document.getElementById('stop-mic-test');

        function drawVisualizer() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / bufferLength) * 2.5;
            let barHeight;
            let x = 0;

            const primaryColor = getComputedStyle(document.body).getPropertyValue('--color-primary');
            
            for (let i = 0; i < bufferLength; i++) {
                barHeight = (dataArray[i] / 255) * canvas.height;
                
                ctx.fillStyle = primaryColor;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }

            // Update level indicator
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            document.getElementById('mic-level').textContent = Math.round(average);

            animationId = requestAnimationFrame(drawVisualizer);
        }

        startBtn.addEventListener('click', async () => {
            try {
                micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(micStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                document.getElementById('mic-status').textContent = 'Active';
                document.getElementById('sample-rate').textContent = `${audioContext.sampleRate} Hz`;
                
                // Try to get device info
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                if (audioInputs.length > 0) {
                    document.getElementById('mic-device').textContent = audioInputs[0].label || 'Default Microphone';
                }

                startBtn.disabled = true;
                stopBtn.disabled = false;
                drawVisualizer();

            } catch (err) {
                document.getElementById('mic-status').textContent = 'Error: ' + err.message;
            }
        });

        stopBtn.addEventListener('click', () => {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            document.getElementById('mic-status').textContent = 'Stopped';
            document.getElementById('mic-level').textContent = '0';
            
            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--color-bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            startBtn.disabled = false;
            stopBtn.disabled = true;
        });
    }

    function renderCameraPreview() {
        a.toolContent.innerHTML = `
            <div class="device-info-grid">
                <div class="device-info-item">
                    <div class="value" id="camera-status">Not Started</div>
                    <div class="label">Camera Status</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="camera-resolution">--</div>
                    <div class="label">Resolution</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="camera-device">--</div>
                    <div class="label">Device Name</div>
                </div>
                <div class="device-info-item">
                    <div class="value" id="camera-fps">--</div>
                    <div class="label">Frame Rate</div>
                </div>
            </div>
            <div class="tool-controls-grid" style="margin-top: var(--space-lg);">
                <button id="start-camera" class="tool-button">Start Camera</button>
                <button id="stop-camera" class="tool-button tool-button-secondary" disabled>Stop Camera</button>
                <button id="take-photo" class="tool-button tool-button-secondary" disabled>Take Photo</button>
            </div>
            <div id="camera-container" style="margin-top: var(--space-lg); text-align: center;">
                <video id="camera-video" style="max-width: 100%; height: 300px; background: var(--color-bg-secondary); border-radius: var(--radius-md); display: none;" autoplay muted></video>
                <div id="camera-placeholder" style="height: 300px; background: var(--color-bg-secondary); border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; color: var(--color-text-secondary);">
                    Camera preview will appear here
                </div>
            </div>
            <canvas id="photo-canvas" style="display: none;"></canvas>
        `;

        let cameraStream = null;
        const video = document.getElementById('camera-video');
        const placeholder = document.getElementById('camera-placeholder');
        const canvas = document.getElementById('photo-canvas');
        const ctx = canvas.getContext('2d');

        document.getElementById('start-camera').addEventListener('click', async () => {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    } 
                });
                
                video.srcObject = cameraStream;
                video.style.display = 'block';
                placeholder.style.display = 'none';

                document.getElementById('camera-status').textContent = 'Active';
                
                // Get video track info
                const videoTrack = cameraStream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                
                document.getElementById('camera-resolution').textContent = `${settings.width}${settings.height}`;
                document.getElementById('camera-fps').textContent = `${settings.frameRate} fps`;

                // Try to get device info
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs = devices.filter(device => device.kind === 'videoinput');
                if (videoInputs.length > 0) {
                    document.getElementById('camera-device').textContent = videoInputs[0].label || 'Default Camera';
                }

                document.getElementById('start-camera').disabled = true;
                document.getElementById('stop-camera').disabled = false;
                document.getElementById('take-photo').disabled = false;

            } catch (err) {
                document.getElementById('camera-status').textContent = 'Error: ' + err.message;
            }
        });

        document.getElementById('stop-camera').addEventListener('click', () => {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }

            video.style.display = 'none';
            placeholder.style.display = 'flex';
            document.getElementById('camera-status').textContent = 'Stopped';
            document.getElementById('camera-resolution').textContent = '--';
            document.getElementById('camera-fps').textContent = '--';

            document.getElementById('start-camera').disabled = false;
            document.getElementById('stop-camera').disabled = true;
            document.getElementById('take-photo').disabled = true;
        });

        document.getElementById('take-photo').addEventListener('click', () => {
            if (video.videoWidth && video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `photo-${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        });
    }

    // --- PUZZLE GAMES ---

    function renderSudoku() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="tool-controls-grid" style="margin-bottom: var(--space-lg);">
                    <button id="new-game" class="tool-button">New Game</button>
                    <button id="solve-puzzle" class="tool-button tool-button-secondary">Solve</button>
                    <button id="check-solution" class="tool-button tool-button-secondary">Check</button>
                </div>
                <div id="sudoku-grid" class="sudoku-grid"></div>
                <div id="sudoku-status" style="text-align: center; margin-top: var(--space-md); font-weight: bold;"></div>
            </div>
        `;

        let puzzle = [];
        let solution = [];
        const grid = document.getElementById('sudoku-grid');

        function generateSudoku() {
            // Simple sudoku generation (for demo purposes)
            const base = [
                [5,3,0,0,7,0,0,0,0],
                [6,0,0,1,9,5,0,0,0],
                [0,9,8,0,0,0,0,6,0],
                [8,0,0,0,6,0,0,0,3],
                [4,0,0,8,0,3,0,0,1],
                [7,0,0,0,2,0,0,0,6],
                [0,6,0,0,0,0,2,8,0],
                [0,0,0,4,1,9,0,0,5],
                [0,0,0,0,8,0,0,7,9]
            ];
            
            const solved = [
                [5,3,4,6,7,8,9,1,2],
                [6,7,2,1,9,5,3,4,8],
                [1,9,8,3,4,2,5,6,7],
                [8,5,9,7,6,1,4,2,3],
                [4,2,6,8,5,3,7,9,1],
                [7,1,3,9,2,4,8,5,6],
                [9,6,1,5,3,7,2,8,4],
                [2,8,7,4,1,9,6,3,5],
                [3,4,5,2,8,6,1,7,9]
            ];

            puzzle = base.map(row => [...row]);
            solution = solved.map(row => [...row]);
        }

        function renderGrid() {
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('input');
                    cell.className = 'sudoku-cell';
                    cell.type = 'text';
                    cell.maxLength = 1;
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if (puzzle[i][j] !== 0) {
                        cell.value = puzzle[i][j];
                        cell.classList.add('given');
                        cell.readOnly = true;
                    }
                    
                    cell.addEventListener('input', (e) => {
                        const value = e.target.value;
                        if (!/^[1-9]$/.test(value)) {
                            e.target.value = '';
                        }
                        checkConflicts();
                    });
                    
                    grid.appendChild(cell);
                }
            }
        }

        function checkConflicts() {
            const cells = grid.querySelectorAll('.sudoku-cell');
            cells.forEach(cell => cell.classList.remove('conflict'));
            
            cells.forEach(cell => {
                if (!cell.value || cell.classList.contains('given')) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = cell.value;
                
                // Check row conflicts
                cells.forEach(otherCell => {
                    if (otherCell !== cell && 
                        otherCell.dataset.row === cell.dataset.row && 
                        otherCell.value === value) {
                        cell.classList.add('conflict');
                        otherCell.classList.add('conflict');
                    }
                });
                
                // Check column conflicts
                cells.forEach(otherCell => {
                    if (otherCell !== cell && 
                        otherCell.dataset.col === cell.dataset.col && 
                        otherCell.value === value) {
                        cell.classList.add('conflict');
                        otherCell.classList.add('conflict');
                    }
                });
                
                // Check 3x3 box conflicts
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                
                cells.forEach(otherCell => {
                    const otherRow = parseInt(otherCell.dataset.row);
                    const otherCol = parseInt(otherCell.dataset.col);
                    
                    if (otherCell !== cell &&
                        Math.floor(otherRow / 3) * 3 === boxRow &&
                        Math.floor(otherCol / 3) * 3 === boxCol &&
                        otherCell.value === value) {
                        cell.classList.add('conflict');
                        otherCell.classList.add('conflict');
                    }
                });
            });
        }

        function solvePuzzle() {
            const cells = grid.querySelectorAll('.sudoku-cell');
            cells.forEach(cell => {
                if (!cell.classList.contains('given')) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    cell.value = solution[row][col];
                }
            });
            document.getElementById('sudoku-status').textContent = 'Puzzle solved!';
            document.getElementById('sudoku-status').style.color = 'var(--color-secondary)';
        }

        function checkSolution() {
            const cells = grid.querySelectorAll('.sudoku-cell');
            let isComplete = true;
            let isCorrect = true;
            
            cells.forEach(cell => {
                if (!cell.value) {
                    isComplete = false;
                } else {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    if (parseInt(cell.value) !== solution[row][col]) {
                        isCorrect = false;
                    }
                }
            });
            
            const status = document.getElementById('sudoku-status');
            if (!isComplete) {
                status.textContent = 'Puzzle incomplete';
                status.style.color = 'var(--color-text-secondary)';
            } else if (isCorrect) {
                status.textContent = 'Congratulations! Puzzle solved correctly!';
                status.style.color = 'var(--color-secondary)';
            } else {
                status.textContent = 'Some numbers are incorrect';
                status.style.color = 'var(--color-accent)';
            }
        }

        document.getElementById('new-game').addEventListener('click', () => {
            generateSudoku();
            renderGrid();
            document.getElementById('sudoku-status').textContent = '';
        });

        document.getElementById('solve-puzzle').addEventListener('click', solvePuzzle);
        document.getElementById('check-solution').addEventListener('click', checkSolution);

        // Initialize
        generateSudoku();
        renderGrid();
    }

    function renderCrossword() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="tool-controls-grid" style="margin-bottom: var(--space-lg);">
                    <button id="new-crossword" class="tool-button">New Puzzle</button>
                    <button id="check-crossword" class="tool-button tool-button-secondary">Check</button>
                    <button id="reveal-crossword" class="tool-button tool-button-secondary">Reveal</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 300px; gap: var(--space-lg); align-items: start;">
                    <div id="crossword-grid" style="display: grid; grid-template-columns: repeat(10, 1fr); gap: 1px; background: var(--color-border); max-width: 400px;"></div>
                    <div id="crossword-clues" style="background: var(--color-bg-secondary); padding: var(--space-md); border-radius: var(--radius-md); max-height: 400px; overflow-y: auto;">
                        <h4 style="margin-bottom: var(--space-sm); color: var(--color-primary);">Clues</h4>
                        <div id="clues-content"></div>
                    </div>
                </div>
            </div>
        `;

        const crosswordData = {
            grid: [
                ['C','A','T','','','','','','',''],
                ['','','','','','','','','',''],
                ['D','O','G','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','',''],
                ['','','','','','','','','','']
            ],
            clues: {
                across: [
                    { number: 1, clue: "Feline pet", answer: "CAT", row: 0, col: 0 },
                    { number: 3, clue: "Man's best friend", answer: "DOG", row: 2, col: 0 }
                ],
                down: [
                    { number: 1, clue: "Compact disc", answer: "CD", row: 0, col: 0 },
                    { number: 2, clue: "Opposite of out", answer: "AT", row: 0, col: 1 }
                ]
            }
        };

        function renderCrosswordGrid() {
            const grid = document.getElementById('crossword-grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const cell = document.createElement('div');
                    cell.style.cssText = `
                        aspect-ratio: 1;
                        background: ${crosswordData.grid[i][j] ? 'white' : 'var(--color-bg-primary)'};
                        border: 1px solid var(--color-border);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                        font-weight: bold;
                        color: black;
                    `;
                    
                    if (crosswordData.grid[i][j]) {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.style.cssText = `
                            width: 100%;
                            height: 100%;
                            border: none;
                            text-align: center;
                            font-weight: bold;
                            font-size: 1rem;
                            background: transparent;
                            color: black;
                        `;
                        input.dataset.row = i;
                        input.dataset.col = j;
                        input.dataset.answer = crosswordData.grid[i][j];
                        cell.appendChild(input);
                        
                        // Add number labels for clue starts
                        const clueNumber = findClueNumber(i, j);
                        if (clueNumber) {
                            const numberLabel = document.createElement('span');
                            numberLabel.textContent = clueNumber;
                            numberLabel.style.cssText = `
                                position: absolute;
                                top: 2px;
                                left: 2px;
                                font-size: 0.7rem;
                                color: black;
                                font-weight: bold;
                            `;
                            cell.appendChild(numberLabel);
                        }
                    }
                    
                    grid.appendChild(cell);
                }
            }
        }

        function findClueNumber(row, col) {
            const allClues = [...crosswordData.clues.across, ...crosswordData.clues.down];
            const clue = allClues.find(c => c.row === row && c.col === col);
            return clue ? clue.number : null;
        }

        function renderClues() {
            const cluesContent = document.getElementById('clues-content');
            cluesContent.innerHTML = `
                <div style="margin-bottom: var(--space-md);">
                    <h5 style="color: var(--color-secondary); margin-bottom: var(--space-xs);">Across</h5>
                    ${crosswordData.clues.across.map(clue => 
                        `<div style="margin-bottom: var(--space-xs); font-size: 0.9rem;">
                            <strong>${clue.number}.</strong> ${clue.clue}
                        </div>`
                    ).join('')}
                </div>
                <div>
                    <h5 style="color: var(--color-secondary); margin-bottom: var(--space-xs);">Down</h5>
                    ${crosswordData.clues.down.map(clue => 
                        `<div style="margin-bottom: var(--space-xs); font-size: 0.9rem;">
                            <strong>${clue.number}.</strong> ${clue.clue}
                        </div>`
                    ).join('')}
                </div>
            `;
        }

        function checkAnswers() {
            const inputs = document.querySelectorAll('#crossword-grid input');
            let correct = 0;
            let total = 0;
            
            inputs.forEach(input => {
                total++;
                if (input.value.toUpperCase() === input.dataset.answer) {
                    correct++;
                    input.style.backgroundColor = '#d4edda';
                } else if (input.value) {
                    input.style.backgroundColor = '#f8d7da';
                } else {
                    input.style.backgroundColor = 'white';
                }
            });
            
            alert(`${correct} out of ${total} letters correct!`);
        }

        function revealAnswers() {
            const inputs = document.querySelectorAll('#crossword-grid input');
            inputs.forEach(input => {
                input.value = input.dataset.answer;
                input.style.backgroundColor = '#d1ecf1';
            });
        }

        document.getElementById('new-crossword').addEventListener('click', () => {
            renderCrosswordGrid();
            renderClues();
        });

        document.getElementById('check-crossword').addEventListener('click', checkAnswers);
        document.getElementById('reveal-crossword').addEventListener('click', revealAnswers);

        // Initialize
        renderCrosswordGrid();
        renderClues();
    }

    function renderWordSearch() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="tool-controls-grid" style="margin-bottom: var(--space-lg);">
                    <button id="new-word-search" class="tool-button">New Puzzle</button>
                    <button id="show-words" class="tool-button tool-button-secondary">Show Words</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 200px; gap: var(--space-lg); align-items: start;">
                    <div id="word-search-grid" class="word-search-grid" style="grid-template-columns: repeat(12, 1fr);"></div>
                    <div id="word-list" style="background: var(--color-bg-secondary); padding: var(--space-md); border-radius: var(--radius-md);">
                        <h4 style="margin-bottom: var(--space-sm); color: var(--color-primary);">Find These Words:</h4>
                        <div id="words-to-find"></div>
                    </div>
                </div>
            </div>
        `;

        const words = ['CAT', 'DOG', 'BIRD', 'FISH', 'MOUSE', 'HORSE'];
        let grid = [];
        let foundWords = [];
        let isSelecting = false;
        let startCell = null;
        let selectedCells = [];

        function generateGrid() {
            grid = Array(12).fill().map(() => Array(12).fill(''));
            foundWords = [];
            
            // Place words randomly
            words.forEach(word => {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 50) {
                    const direction = Math.floor(Math.random() * 8); // 8 directions
                    const row = Math.floor(Math.random() * 12);
                    const col = Math.floor(Math.random() * 12);
                    
                    if (canPlaceWord(word, row, col, direction)) {
                        placeWord(word, row, col, direction);
                        placed = true;
                    }
                    attempts++;
                }
            });
            
            // Fill empty cells with random letters
            for (let i = 0; i < 12; i++) {
                for (let j = 0; j < 12; j++) {
                    if (grid[i][j] === '') {
                        grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }
        }

        function canPlaceWord(word, row, col, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dr, dc] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = row + i * dr;
                const newCol = col + i * dc;
                
                if (newRow < 0 || newRow >= 12 || newCol < 0 || newCol >= 12) {
                    return false;
                }
                
                if (grid[newRow][newCol] !== '' && grid[newRow][newCol] !== word[i]) {
                    return false;
                }
            }
            
            return true;
        }

        function placeWord(word, row, col, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dr, dc] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = row + i * dr;
                const newCol = col + i * dc;
                grid[newRow][newCol] = word[i];
            }
        }

        function renderGrid() {
            const gridElement = document.getElementById('word-search-grid');
            gridElement.innerHTML = '';
            
            for (let i = 0; i < 12; i++) {
                for (let j = 0; j < 12; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'word-search-cell';
                    cell.textContent = grid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseenter', continueSelection);
                    cell.addEventListener('mouseup', endSelection);
                    
                    gridElement.appendChild(cell);
                }
            }
        }

        function startSelection(e) {
            isSelecting = true;
            startCell = e.target;
            selectedCells = [e.target];
            e.target.classList.add('selecting');
        }

        function continueSelection(e) {
            if (!isSelecting) return;
            
            // Clear previous selection
            selectedCells.forEach(cell => cell.classList.remove('selecting'));
            selectedCells = [];
            
            // Calculate line from start to current cell
            const startRow = parseInt(startCell.dataset.row);
            const startCol = parseInt(startCell.dataset.col);
            const endRow = parseInt(e.target.dataset.row);
            const endCol = parseInt(e.target.dataset.col);
            
            const cells = getLineCells(startRow, startCol, endRow, endCol);
            cells.forEach(cell => {
                cell.classList.add('selecting');
                selectedCells.push(cell);
            });
        }

        function endSelection() {
            if (!isSelecting) return;
            isSelecting = false;
            
            const selectedWord = selectedCells.map(cell => cell.textContent).join('');
            const reversedWord = selectedWord.split('').reverse().join('');
            
            if (words.includes(selectedWord) || words.includes(reversedWord)) {
                const word = words.includes(selectedWord) ? selectedWord : reversedWord;
                if (!foundWords.includes(word)) {
                    foundWords.push(word);
                    selectedCells.forEach(cell => {
                        cell.classList.remove('selecting');
                        cell.classList.add('found');
                    });
                    updateWordList();
                    
                    if (foundWords.length === words.length) {
                        setTimeout(() => alert('Congratulations! You found all words!'), 100);
                    }
                }
            } else {
                selectedCells.forEach(cell => cell.classList.remove('selecting'));
            }
            
            selectedCells = [];
            startCell = null;
        }

        function getLineCells(startRow, startCol, endRow, endCol) {
            const cells = [];
            const rowDiff = endRow - startRow;
            const colDiff = endCol - startCol;
            const steps = Math.max(Math.abs(rowDiff), Math.abs(colDiff));
            
            if (steps === 0) {
                const cell = document.querySelector(`[data-row="${startRow}"][data-col="${startCol}"]`);
                return [cell];
            }
            
            const rowStep = rowDiff / steps;
            const colStep = colDiff / steps;
            
            for (let i = 0; i <= steps; i++) {
                const row = Math.round(startRow + i * rowStep);
                const col = Math.round(startCol + i * colStep);
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) cells.push(cell);
            }
            
            return cells;
        }

        function updateWordList() {
            const wordsContainer = document.getElementById('words-to-find');
            wordsContainer.innerHTML = words.map(word => 
                `<div style="margin-bottom: var(--space-xs); ${foundWords.includes(word) ? 'text-decoration: line-through; color: var(--color-secondary);' : ''}">${word}</div>`
            ).join('');
        }

        document.getElementById('new-word-search').addEventListener('click', () => {
            generateGrid();
            renderGrid();
            updateWordList();
        });

        document.getElementById('show-words').addEventListener('click', () => {
            // Highlight all word positions (cheat mode)
            alert('Words are highlighted in the grid!');
        });

        // Initialize
        generateGrid();
        renderGrid();
        updateWordList();
    }

    function renderMathQuiz() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-lg);">
                    <div class="device-info-item">
                        <div class="value" id="quiz-score">0</div>
                        <div class="label">Score</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="quiz-question-num">1</div>
                        <div class="label">Question</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="quiz-time">30</div>
                        <div class="label">Time Left</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="quiz-streak">0</div>
                        <div class="label">Streak</div>
                    </div>
                </div>
                <div class="quiz-question">
                    <h3 id="math-question">Click Start to begin</h3>
                    <div class="quiz-answers" id="quiz-answers"></div>
                </div>
                <div class="tool-controls-grid">
                    <button id="start-quiz" class="tool-button">Start Quiz</button>
                    <button id="next-question" class="tool-button tool-button-secondary" disabled>Next Question</button>
                    <button id="end-quiz" class="tool-button tool-button-secondary" disabled>End Quiz</button>
                </div>
            </div>
        `;

        let quizState = {
            score: 0,
            questionNum: 1,
            timeLeft: 30,
            streak: 0,
            currentAnswer: null,
            timer: null,
            isActive: false
        };

        function generateQuestion() {
            const operations = ['+', '-', '', ''];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            let num1, num2, correctAnswer;

            switch (operation) {
                case '+':
                    num1 = Math.floor(Math.random() * 50) + 1;
                    num2 = Math.floor(Math.random() * 50) + 1;
                    correctAnswer = num1 + num2;
                    break;
                case '-':
                    num1 = Math.floor(Math.random() * 50) + 25;
                    num2 = Math.floor(Math.random() * 25) + 1;
                    correctAnswer = num1 - num2;
                    break;
                case '':
                    num1 = Math.floor(Math.random() * 12) + 1;
                    num2 = Math.floor(Math.random() * 12) + 1;
                    correctAnswer = num1 * num2;
                    break;
                case '':
                    correctAnswer = Math.floor(Math.random() * 12) + 1;
                    num2 = Math.floor(Math.random() * 12) + 1;
                    num1 = correctAnswer * num2;
                    break;
            }

            const question = `${num1} ${operation} ${num2} = ?`;
            const wrongAnswers = [];
            
            // Generate 3 wrong answers
            while (wrongAnswers.length < 3) {
                const wrong = correctAnswer + (Math.floor(Math.random() * 20) - 10);
                if (wrong !== correctAnswer && wrong > 0 && !wrongAnswers.includes(wrong)) {
                    wrongAnswers.push(wrong);
                }
            }

            const allAnswers = [correctAnswer, ...wrongAnswers].sort(() => Math.random() - 0.5);
            
            return { question, correctAnswer, answers: allAnswers };
        }

        function displayQuestion() {
            const { question, correctAnswer, answers } = generateQuestion();
            quizState.currentAnswer = correctAnswer;
            
            document.getElementById('math-question').textContent = question;
            
            const answersContainer = document.getElementById('quiz-answers');
            answersContainer.innerHTML = '';
            
            answers.forEach(answer => {
                const button = document.createElement('button');
                button.className = 'quiz-answer';
                button.textContent = answer;
                button.addEventListener('click', () => selectAnswer(answer, button));
                answersContainer.appendChild(button);
            });
        }

        function selectAnswer(selectedAnswer, buttonElement) {
            const allButtons = document.querySelectorAll('.quiz-answer');
            allButtons.forEach(btn => btn.disabled = true);
            
            if (selectedAnswer === quizState.currentAnswer) {
                buttonElement.classList.add('correct');
                quizState.score += 10 + quizState.streak;
                quizState.streak++;
            } else {
                buttonElement.classList.add('incorrect');
                // Show correct answer
                allButtons.forEach(btn => {
                    if (parseInt(btn.textContent) === quizState.currentAnswer) {
                        btn.classList.add('correct');
                    }
                });
                quizState.streak = 0;
            }
            
            updateDisplay();
            document.getElementById('next-question').disabled = false;
        }

        function updateDisplay() {
            document.getElementById('quiz-score').textContent = quizState.score;
            document.getElementById('quiz-question-num').textContent = quizState.questionNum;
            document.getElementById('quiz-time').textContent = quizState.timeLeft;
            document.getElementById('quiz-streak').textContent = quizState.streak;
        }

        function startTimer() {
            quizState.timer = setInterval(() => {
                quizState.timeLeft--;
                updateDisplay();
                
                if (quizState.timeLeft <= 0) {
                    // Time's up - mark as wrong and move to next
                    const allButtons = document.querySelectorAll('.quiz-answer');
                    allButtons.forEach(btn => {
                        btn.disabled = true;
                        if (parseInt(btn.textContent) === quizState.currentAnswer) {
                            btn.classList.add('correct');
                        }
                    });
                    quizState.streak = 0;
                    document.getElementById('next-question').disabled = false;
                }
            }, 1000);
        }

        function nextQuestion() {
            quizState.questionNum++;
            quizState.timeLeft = 30;
            
            if (quizState.timer) {
                clearInterval(quizState.timer);
            }
            
            displayQuestion();
            startTimer();
            updateDisplay();
            
            document.getElementById('next-question').disabled = true;
        }

        function startQuiz() {
            quizState = {
                score: 0,
                questionNum: 1,
                timeLeft: 30,
                streak: 0,
                currentAnswer: null,
                timer: null,
                isActive: true
            };
            
            displayQuestion();
            startTimer();
            updateDisplay();
            
            document.getElementById('start-quiz').disabled = true;
            document.getElementById('end-quiz').disabled = false;
        }

        function endQuiz() {
            if (quizState.timer) {
                clearInterval(quizState.timer);
            }
            
            alert(`Quiz ended! Final score: ${quizState.score} points in ${quizState.questionNum - 1} questions.`);
            
            document.getElementById('math-question').textContent = 'Click Start to begin';
            document.getElementById('quiz-answers').innerHTML = '';
            document.getElementById('start-quiz').disabled = false;
            document.getElementById('next-question').disabled = true;
            document.getElementById('end-quiz').disabled = true;
            
            quizState.isActive = false;
        }

        document.getElementById('start-quiz').addEventListener('click', startQuiz);
        document.getElementById('next-question').addEventListener('click', nextQuestion);
        document.getElementById('end-quiz').addEventListener('click', endQuiz);
    }

    function renderMemoryMatch() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-lg);">
                    <div class="device-info-item">
                        <div class="value" id="memory-moves">0</div>
                        <div class="label">Moves</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="memory-matches">0</div>
                        <div class="label">Matches</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="memory-time">0</div>
                        <div class="label">Time</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="memory-best">--</div>
                        <div class="label">Best Time</div>
                    </div>
                </div>
                <div class="memory-grid" id="memory-grid"></div>
                <div class="tool-controls-grid">
                    <button id="new-memory-game" class="tool-button">New Game</button>
                    <button id="reset-best" class="tool-button tool-button-secondary">Reset Best</button>
                </div>
            </div>
        `;

        const symbols = ['', '', '', '', '', '', '', '', '', '', '', ''];
        let gameState = {
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            moves: 0,
            startTime: null,
            timer: null,
            gameActive: false
        };

        function initializeGame() {
            // Create pairs of cards
            const cardSymbols = symbols.slice(0, 8); // Use 8 different symbols
            gameState.cards = [...cardSymbols, ...cardSymbols]
                .sort(() => Math.random() - 0.5)
                .map((symbol, index) => ({
                    id: index,
                    symbol,
                    flipped: false,
                    matched: false
                }));

            gameState.flippedCards = [];
            gameState.matchedPairs = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.gameActive = true;

            renderGrid();
            startTimer();
            updateDisplay();
        }

        function renderGrid() {
            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';

            gameState.cards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = `memory-card ${card.flipped ? 'flipped' : ''} ${card.matched ? 'matched' : ''}`;
                cardElement.dataset.cardId = card.id;
                
                if (card.flipped || card.matched) {
                    cardElement.textContent = card.symbol;
                } else {
                    cardElement.textContent = '?';
                }
                
                cardElement.addEventListener('click', () => flipCard(card.id));
                grid.appendChild(cardElement);
            });
        }

        function flipCard(cardId) {
            if (!gameState.gameActive) return;
            
            const card = gameState.cards.find(c => c.id === cardId);
            if (card.flipped || card.matched || gameState.flippedCards.length >= 2) return;

            card.flipped = true;
            gameState.flippedCards.push(card);
            renderGrid();

            if (gameState.flippedCards.length === 2) {
                gameState.moves++;
                updateDisplay();
                
                setTimeout(() => {
                    checkMatch();
                }, 1000);
            }
        }

        function checkMatch() {
            const [card1, card2] = gameState.flippedCards;
            
            if (card1.symbol === card2.symbol) {
                // Match found
                card1.matched = true;
                card2.matched = true;
                gameState.matchedPairs++;
                
                if (gameState.matchedPairs === 8) {
                    // Game won
                    gameState.gameActive = false;
                    clearInterval(gameState.timer);
                    
                    const finalTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                    const bestTime = localStorage.getItem('memoryGameBest');
                    
                    if (!bestTime || finalTime < parseInt(bestTime)) {
                        localStorage.setItem('memoryGameBest', finalTime.toString());
                        updateDisplay();
                        alert(`Congratulations! New best time: ${finalTime} seconds!`);
                    } else {
                        alert(`Game completed in ${finalTime} seconds with ${gameState.moves} moves!`);
                    }
                }
            } else {
                // No match
                card1.flipped = false;
                card2.flipped = false;
            }
            
            gameState.flippedCards = [];
            renderGrid();
            updateDisplay();
        }

        function startTimer() {
            gameState.timer = setInterval(() => {
                updateDisplay();
            }, 1000);
        }

        function updateDisplay() {
            document.getElementById('memory-moves').textContent = gameState.moves;
            document.getElementById('memory-matches').textContent = gameState.matchedPairs;
            
            if (gameState.startTime) {
                const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                document.getElementById('memory-time').textContent = elapsed;
            }
            
            const bestTime = localStorage.getItem('memoryGameBest');
            document.getElementById('memory-best').textContent = bestTime ? `${bestTime}s` : '--';
        }

        document.getElementById('new-memory-game').addEventListener('click', () => {
            if (gameState.timer) clearInterval(gameState.timer);
            initializeGame();
        });

        document.getElementById('reset-best').addEventListener('click', () => {
            localStorage.removeItem('memoryGameBest');
            updateDisplay();
        });

        // Initialize first game
        initializeGame();
    }

    function renderPatternLockPuzzle() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="tool-controls-grid" style="margin-bottom: var(--space-lg);">
                    <button id="create-pattern" class="tool-button">Create Pattern</button>
                    <button id="solve-pattern" class="tool-button tool-button-secondary">Solve Pattern</button>
                    <button id="clear-pattern" class="tool-button tool-button-secondary">Clear</button>
                </div>
                <div id="pattern-status" style="text-align: center; margin-bottom: var(--space-md); font-weight: bold;"></div>
                <div id="pattern-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-md); max-width: 300px; margin: 0 auto;">
                    ${Array(9).fill().map((_, i) => 
                        `<div class="pattern-dot" data-dot="${i}" style="
                            aspect-ratio: 1;
                            background: var(--color-bg-secondary);
                            border: 3px solid var(--color-border);
                            border-radius: 50%;
                            cursor: pointer;
                            transition: all var(--transition-fast);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            font-size: 1.2rem;
                        "></div>`
                    ).join('')}
                </div>
                <canvas id="pattern-canvas" style="position: absolute; pointer-events: none; z-index: 10;"></canvas>
            </div>
        `;

        let patternState = {
            mode: 'idle', // 'creating', 'solving', 'idle'
            createdPattern: [],
            currentPattern: [],
            isDrawing: false,
            canvas: null,
            ctx: null
        };

        const canvas = document.getElementById('pattern-canvas');
        const ctx = canvas.getContext('2d');
        patternState.canvas = canvas;
        patternState.ctx = ctx;

        function setupCanvas() {
            const grid = document.getElementById('pattern-grid');
            const rect = grid.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            canvas.style.left = rect.left + 'px';
            canvas.style.top = rect.top + 'px';
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        function getDotPosition(dotIndex) {
            const dot = document.querySelector(`[data-dot="${dotIndex}"]`);
            const rect = dot.getBoundingClientRect();
            const gridRect = document.getElementById('pattern-grid').getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2 - gridRect.left,
                y: rect.top + rect.height / 2 - gridRect.top
            };
        }

        function drawPattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (patternState.currentPattern.length < 2) return;
            
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--color-primary');
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            
            const firstPos = getDotPosition(patternState.currentPattern[0]);
            ctx.moveTo(firstPos.x, firstPos.y);
            
            for (let i = 1; i < patternState.currentPattern.length; i++) {
                const pos = getDotPosition(patternState.currentPattern[i]);
                ctx.lineTo(pos.x, pos.y);
            }
            
            ctx.stroke();
        }

        function addDotToPattern(dotIndex) {
            if (patternState.currentPattern.includes(dotIndex)) return;
            
            patternState.currentPattern.push(dotIndex);
            const dot = document.querySelector(`[data-dot="${dotIndex}"]`);
            dot.style.backgroundColor = 'var(--color-primary)';
            dot.style.borderColor = 'var(--color-primary)';
            dot.style.color = 'var(--color-bg-primary)';
            dot.textContent = patternState.currentPattern.length;
            
            drawPattern();
        }

        function clearPattern() {
            patternState.currentPattern = [];
            document.querySelectorAll('.pattern-dot').forEach(dot => {
                dot.style.backgroundColor = 'var(--color-bg-secondary)';
                dot.style.borderColor = 'var(--color-border)';
                dot.style.color = 'var(--color-text-primary)';
                dot.textContent = '';
            });
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function startCreating() {
            patternState.mode = 'creating';
            clearPattern();
            document.getElementById('pattern-status').textContent = 'Draw your pattern by connecting dots';
            document.getElementById('pattern-status').style.color = 'var(--color-primary)';
        }

        function startSolving() {
            if (patternState.createdPattern.length === 0) {
                alert('Please create a pattern first!');
                return;
            }
            
            patternState.mode = 'solving';
            clearPattern();
            document.getElementById('pattern-status').textContent = 'Recreate the pattern you just created';
            document.getElementById('pattern-status').style.color = 'var(--color-secondary)';
        }

        function checkSolution() {
            const created = patternState.createdPattern.join(',');
            const current = patternState.currentPattern.join(',');
            
            if (created === current) {
                document.getElementById('pattern-status').textContent = 'Correct! Pattern matched!';
                document.getElementById('pattern-status').style.color = 'var(--color-secondary)';
                patternState.mode = 'idle';
            } else {
                document.getElementById('pattern-status').textContent = 'Incorrect pattern. Try again!';
                document.getElementById('pattern-status').style.color = 'var(--color-accent)';
                setTimeout(() => {
                    clearPattern();
                    document.getElementById('pattern-status').textContent = 'Recreate the pattern you just created';
                    document.getElementById('pattern-status').style.color = 'var(--color-secondary)';
                }, 1500);
            }
        }

        // Event listeners
        document.getElementById('pattern-grid').addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('pattern-dot')) {
                patternState.isDrawing = true;
                const dotIndex = parseInt(e.target.dataset.dot);
                addDotToPattern(dotIndex);
            }
        });

        document.getElementById('pattern-grid').addEventListener('mouseover', (e) => {
            if (patternState.isDrawing && e.target.classList.contains('pattern-dot')) {
                const dotIndex = parseInt(e.target.dataset.dot);
                addDotToPattern(dotIndex);
            }
        });

        document.addEventListener('mouseup', () => {
            if (patternState.isDrawing) {
                patternState.isDrawing = false;
                
                if (patternState.mode === 'creating' && patternState.currentPattern.length >= 3) {
                    patternState.createdPattern = [...patternState.currentPattern];
                    document.getElementById('pattern-status').textContent = 'Pattern created! Now try to solve it.';
                    patternState.mode = 'idle';
                } else if (patternState.mode === 'solving' && patternState.currentPattern.length >= 3) {
                    checkSolution();
                }
            }
        });

        document.getElementById('create-pattern').addEventListener('click', startCreating);
        document.getElementById('solve-pattern').addEventListener('click', startSolving);
        document.getElementById('clear-pattern').addEventListener('click', clearPattern);

        // Initialize
        setupCanvas();
        window.addEventListener('resize', setupCanvas);
    }

    function renderLogicRiddles() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-lg);">
                    <div class="device-info-item">
                        <div class="value" id="riddle-number">1</div>
                        <div class="label">Riddle</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="riddles-solved">0</div>
                        <div class="label">Solved</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="riddle-difficulty">Easy</div>
                        <div class="label">Difficulty</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="riddle-hints">3</div>
                        <div class="label">Hints Left</div>
                    </div>
                </div>
                <div class="quiz-question">
                    <h3 id="riddle-text">Click Next Riddle to start</h3>
                    <div style="margin-top: var(--space-lg);">
                        <input type="text" id="riddle-answer" class="tool-input" placeholder="Enter your answer..." style="margin-bottom: var(--space-md);">
                        <div id="riddle-hint" style="background: var(--color-bg-secondary); padding: var(--space-md); border-radius: var(--radius-md); margin-bottom: var(--space-md); display: none;">
                            <strong>Hint:</strong> <span id="hint-text"></span>
                        </div>
                    </div>
                </div>
                <div class="tool-controls-grid">
                    <button id="submit-answer" class="tool-button">Submit Answer</button>
                    <button id="get-hint" class="tool-button tool-button-secondary">Get Hint</button>
                    <button id="next-riddle" class="tool-button tool-button-secondary">Next Riddle</button>
                    <button id="skip-riddle" class="tool-button tool-button-secondary">Skip</button>
                </div>
            </div>
        `;

        const riddles = [
            {
                question: "I have keys but no locks. I have space but no room. You can enter, but you can't go outside. What am I?",
                answer: "keyboard",
                hints: ["I'm used with computers", "I help you type", "I have letters and numbers"],
                difficulty: "Easy"
            },
            {
                question: "The more you take, the more you leave behind. What am I?",
                answer: "footsteps",
                hints: ["Think about walking", "You create them as you move", "They show where you've been"],
                difficulty: "Easy"
            },
            {
                question: "I am not alive, but I grow; I don't have lungs, but I need air; I don't have a mouth, but water kills me. What am I?",
                answer: "fire",
                hints: ["I'm hot and bright", "I consume oxygen", "Water is my enemy"],
                difficulty: "Medium"
            },
            {
                question: "A man lives on the 20th floor of an apartment building. Every morning he takes the elevator down to the ground floor. When he comes home, he takes the elevator to the 10th floor and walks the rest of the way... except on rainy days, when he takes the elevator all the way to the 20th floor. Why?",
                answer: "short",
                hints: ["Think about his physical characteristics", "He can't reach something", "Rain gives him a tool"],
                difficulty: "Hard"
            },
            {
                question: "You see a boat filled with people. It has not sunk, but when you look again you don't see a single person on the boat. Why?",
                answer: "married",
                hints: ["Think about the word 'single'", "All the people have something in common", "It's about relationship status"],
                difficulty: "Medium"
            }
        ];

        let riddleState = {
            currentIndex: 0,
            solved: 0,
            hintsLeft: 3,
            currentRiddle: null
        };

        function loadRiddle() {
            if (riddleState.currentIndex >= riddles.length) {
                document.getElementById('riddle-text').textContent = 'Congratulations! You\'ve completed all riddles!';
                document.getElementById('next-riddle').disabled = true;
                return;
            }

            riddleState.currentRiddle = riddles[riddleState.currentIndex];
            riddleState.hintsLeft = 3;
            
            document.getElementById('riddle-text').textContent = riddleState.currentRiddle.question;
            document.getElementById('riddle-answer').value = '';
            document.getElementById('riddle-hint').style.display = 'none';
            
            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('riddle-number').textContent = riddleState.currentIndex + 1;
            document.getElementById('riddles-solved').textContent = riddleState.solved;
            document.getElementById('riddle-difficulty').textContent = riddleState.currentRiddle?.difficulty || 'Easy';
            document.getElementById('riddle-hints').textContent = riddleState.hintsLeft;
        }

        function submitAnswer() {
            const userAnswer = document.getElementById('riddle-answer').value.toLowerCase().trim();
            const correctAnswer = riddleState.currentRiddle.answer.toLowerCase();
            
            if (userAnswer === correctAnswer) {
                alert('Correct! Well done!');
                riddleState.solved++;
                riddleState.currentIndex++;
                loadRiddle();
            } else {
                alert('Not quite right. Try again or get a hint!');
            }
        }

        function getHint() {
            if (riddleState.hintsLeft <= 0) {
                alert('No more hints available for this riddle!');
                return;
            }
            
            const hintIndex = 3 - riddleState.hintsLeft;
            const hint = riddleState.currentRiddle.hints[hintIndex];
            
            document.getElementById('hint-text').textContent = hint;
            document.getElementById('riddle-hint').style.display = 'block';
            
            riddleState.hintsLeft--;
            updateDisplay();
        }

        function nextRiddle() {
            riddleState.currentIndex++;
            loadRiddle();
        }

        function skipRiddle() {
            if (confirm('Are you sure you want to skip this riddle?')) {
                riddleState.currentIndex++;
                loadRiddle();
            }
        }

        document.getElementById('submit-answer').addEventListener('click', submitAnswer);
        document.getElementById('get-hint').addEventListener('click', getHint);
        document.getElementById('next-riddle').addEventListener('click', nextRiddle);
        document.getElementById('skip-riddle').addEventListener('click', skipRiddle);

        document.getElementById('riddle-answer').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitAnswer();
            }
        });

        // Initialize
        loadRiddle();
    }

    function renderHangman() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="hangman-display">
                    <div id="hangman-drawing" style="font-family: monospace; font-size: 1.2rem; line-height: 1.2; background: var(--color-bg-secondary); padding: var(--space-lg); border-radius: var(--radius-md); margin-bottom: var(--space-md);">
                        <div>  +---+</div>
                        <div>  |   |</div>
                        <div>      |</div>
                        <div>      |</div>
                        <div>      |</div>
                        <div>      |</div>
                        <div>=========</div>
                    </div>
                    <div class="hangman-word" id="hangman-word">_ _ _ _ _</div>
                    <div style="margin: var(--space-md) 0;">
                        <div style="color: var(--color-text-secondary); margin-bottom: var(--space-xs);">Wrong letters:</div>
                        <div id="wrong-letters" style="font-size: 1.2rem; color: var(--color-accent);"></div>
                    </div>
                </div>
                <div class="hangman-letters" id="hangman-letters">
                    ${Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ').map(letter => 
                        `<button class="hangman-letter" data-letter="${letter}">${letter}</button>`
                    ).join('')}
                </div>
                <div class="tool-controls-grid" style="margin-top: var(--space-lg);">
                    <button id="new-hangman-game" class="tool-button">New Game</button>
                    <button id="give-up" class="tool-button tool-button-secondary">Give Up</button>
                </div>
            </div>
        `;

        const words = [
            'JAVASCRIPT', 'COMPUTER', 'PROGRAMMING', 'WEBSITE', 'KEYBOARD',
            'MONITOR', 'SOFTWARE', 'HARDWARE', 'INTERNET', 'BROWSER',
            'DATABASE', 'ALGORITHM', 'FUNCTION', 'VARIABLE', 'ARRAY'
        ];

        const hangmanStages = [
            [
                "  +---+",
                "  |   |",
                "      |",
                "      |", 
                "      |",
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |",
                "  O   |",
                "      |",
                "      |", 
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |", 
                "  O   |",
                "  |   |",
                "      |",
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |",
                "  O   |", 
                " /|   |",
                "      |",
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |",
                "  O   |",
                " /|\\  |", 
                "      |",
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |",
                "  O   |",
                " /|\\  |",
                " /    |", 
                "      |",
                "========="
            ],
            [
                "  +---+",
                "  |   |", 
                "  O   |",
                " /|\\  |",
                " / \\  |",
                "      |",
                "========="
            ]
        ];

        let gameState = {
            currentWord: '',
            guessedLetters: [],
            wrongGuesses: 0,
            gameOver: false,
            won: false
        };

        function startNewGame() {
            gameState.currentWord = words[Math.floor(Math.random() * words.length)];
            gameState.guessedLetters = [];
            gameState.wrongGuesses = 0;
            gameState.gameOver = false;
            gameState.won = false;

            updateDisplay();
            resetLetters();
        }

        function updateDisplay() {
            // Update word display
            const wordDisplay = gameState.currentWord
                .split('')
                .map(letter => gameState.guessedLetters.includes(letter) ? letter : '_')
                .join(' ');
            document.getElementById('hangman-word').textContent = wordDisplay;

            // Update hangman drawing
            const drawing = hangmanStages[gameState.wrongGuesses];
            document.getElementById('hangman-drawing').innerHTML = drawing.map(line => `<div>${line}</div>`).join('');

            // Update wrong letters
            const wrongLetters = gameState.guessedLetters.filter(letter => 
                !gameState.currentWord.includes(letter)
            );
            document.getElementById('wrong-letters').textContent = wrongLetters.join(' ');

            // Check win condition
            if (gameState.currentWord.split('').every(letter => gameState.guessedLetters.includes(letter))) {
                gameState.won = true;
                gameState.gameOver = true;
                setTimeout(() => alert('Congratulations! You won!'), 100);
            }

            // Check lose condition
            if (gameState.wrongGuesses >= 6) {
                gameState.gameOver = true;
                setTimeout(() => alert(`Game over! The word was: ${gameState.currentWord}`), 100);
            }
        }

        function resetLetters() {
            document.querySelectorAll('.hangman-letter').forEach(button => {
                button.classList.remove('guessed', 'correct', 'incorrect');
                button.disabled = false;
            });
        }

        function guessLetter(letter) {
            if (gameState.gameOver || gameState.guessedLetters.includes(letter)) return;

            gameState.guessedLetters.push(letter);
            const button = document.querySelector(`[data-letter="${letter}"]`);
            button.classList.add('guessed');
            button.disabled = true;

            if (gameState.currentWord.includes(letter)) {
                button.classList.add('correct');
            } else {
                button.classList.add('incorrect');
                gameState.wrongGuesses++;
            }

            updateDisplay();
        }

        function giveUp() {
            if (confirm('Are you sure you want to give up?')) {
                gameState.gameOver = true;
                alert(`The word was: ${gameState.currentWord}`);
                
                // Show all letters
                gameState.currentWord.split('').forEach(letter => {
                    if (!gameState.guessedLetters.includes(letter)) {
                        gameState.guessedLetters.push(letter);
                    }
                });
                updateDisplay();
            }
        }

        // Event listeners
        document.getElementById('hangman-letters').addEventListener('click', (e) => {
            if (e.target.classList.contains('hangman-letter')) {
                guessLetter(e.target.dataset.letter);
            }
        });

        document.getElementById('new-hangman-game').addEventListener('click', startNewGame);
        document.getElementById('give-up').addEventListener('click', giveUp);

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            const letter = e.key.toUpperCase();
            if (letter >= 'A' && letter <= 'Z') {
                guessLetter(letter);
            }
        });

        // Initialize
        startNewGame();
    }

    function renderTypingTest() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="typing-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: var(--space-md); margin-bottom: var(--space-lg);">
                    <div class="stat-item">
                        <div class="value" id="typing-wpm">0</div>
                        <div class="label">WPM</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="typing-accuracy">100%</div>
                        <div class="label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="typing-time">60</div>
                        <div class="label">Time Left</div>
                    </div>
                    <div class="stat-item">
                        <div class="value" id="typing-progress">0%</div>
                        <div class="label">Progress</div>
                    </div>
                </div>
                <div class="typing-test-area">
                    <div class="typing-text" id="typing-text"></div>
                    <textarea id="typing-input" class="typing-input" placeholder="Click here and start typing when ready..." disabled></textarea>
                </div>
                <div class="tool-controls-grid" style="margin-top: var(--space-lg);">
                    <button id="start-typing-test" class="tool-button">Start Test</button>
                    <button id="reset-typing-test" class="tool-button tool-button-secondary">Reset</button>
                    <select id="typing-duration" class="tool-select">
                        <option value="30">30 seconds</option>
                        <option value="60" selected>60 seconds</option>
                        <option value="120">2 minutes</option>
                    </select>
                </div>
            </div>
        `;

        const sampleTexts = [
            "The quick brown fox jumps over the lazy dog. This pangram contains every letter of the alphabet and is commonly used for typing practice.",
            "Technology has revolutionized the way we communicate, work, and live. From smartphones to artificial intelligence, innovation continues to shape our future.",
            "Programming is the art of telling a computer what to do through a series of instructions. It requires logical thinking, problem-solving skills, and attention to detail.",
            "The internet has connected people from all corners of the world, creating a global community where information flows freely and instantly.",
            "Learning to type efficiently is an essential skill in the digital age. Practice makes perfect, and consistency is key to improving your typing speed and accuracy."
        ];

        let typingState = {
            text: '',
            currentIndex: 0,
            startTime: null,
            endTime: null,
            timer: null,
            duration: 60,
            isActive: false,
            correctChars: 0,
            totalChars: 0
        };

        function initializeTest() {
            typingState.text = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
            typingState.currentIndex = 0;
            typingState.correctChars = 0;
            typingState.totalChars = 0;
            typingState.isActive = false;
            
            renderText();
            updateStats();
        }

        function renderText() {
            const textElement = document.getElementById('typing-text');
            const input = document.getElementById('typing-input');
            const typedText = input.value;
            
            let html = '';
            
            for (let i = 0; i < typingState.text.length; i++) {
                const char = typingState.text[i];
                let className = '';
                
                if (i < typedText.length) {
                    if (typedText[i] === char) {
                        className = 'correct';
                    } else {
                        className = 'incorrect';
                    }
                } else if (i === typedText.length) {
                    className = 'current';
                }
                
                html += `<span class="char ${className}">${char === ' ' ? '&nbsp;' : char}</span>`;
            }
            
            textElement.innerHTML = html;
        }

        function startTest() {
            typingState.isActive = true;
            typingState.startTime = Date.now();
            typingState.duration = parseInt(document.getElementById('typing-duration').value);
            
            document.getElementById('typing-input').disabled = false;
            document.getElementById('typing-input').focus();
            document.getElementById('start-typing-test').disabled = true;
            
            startTimer();
        }

        function startTimer() {
            typingState.timer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - typingState.startTime) / 1000);
                const remaining = Math.max(0, typingState.duration - elapsed);
                
                document.getElementById('typing-time').textContent = remaining;
                
                if (remaining === 0) {
                    endTest();
                }
                
                updateStats();
            }, 1000);
        }

        function endTest() {
            typingState.isActive = false;
            typingState.endTime = Date.now();
            
            if (typingState.timer) {
                clearInterval(typingState.timer);
            }
            
            document.getElementById('typing-input').disabled = true;
            document.getElementById('start-typing-test').disabled = false;
            
            showResults();
        }

        function updateStats() {
            if (!typingState.startTime) return;
            
            const input = document.getElementById('typing-input');
            const typedText = input.value;
            
            // Calculate WPM
            const timeElapsed = (Date.now() - typingState.startTime) / 1000 / 60; // in minutes
            const wordsTyped = typedText.length / 5; // Standard: 5 characters = 1 word
            const wpm = timeElapsed > 0 ? Math.round(wordsTyped / timeElapsed) : 0;
            
            // Calculate accuracy
            let correctChars = 0;
            for (let i = 0; i < typedText.length && i < typingState.text.length; i++) {
                if (typedText[i] === typingState.text[i]) {
                    correctChars++;
                }
            }
            
            const accuracy = typedText.length > 0 ? Math.round((correctChars / typedText.length) * 100) : 100;
            
            // Calculate progress
            const progress = Math.round((typedText.length / typingState.text.length) * 100);
            
            document.getElementById('typing-wpm').textContent = wpm;
            document.getElementById('typing-accuracy').textContent = accuracy + '%';
            document.getElementById('typing-progress').textContent = Math.min(100, progress) + '%';
        }

        function showResults() {
            const input = document.getElementById('typing-input');
            const typedText = input.value;
            
            const timeElapsed = (typingState.endTime - typingState.startTime) / 1000 / 60;
            const wordsTyped = typedText.length / 5;
            const wpm = Math.round(wordsTyped / timeElapsed);
            
            let correctChars = 0;
            for (let i = 0; i < typedText.length && i < typingState.text.length; i++) {
                if (typedText[i] === typingState.text[i]) {
                    correctChars++;
                }
            }
            
            const accuracy = typedText.length > 0 ? Math.round((correctChars / typedText.length) * 100) : 100;
            
            alert(`Test completed!\nWPM: ${wpm}\nAccuracy: ${accuracy}%\nCharacters typed: ${typedText.length}`);
        }

        function resetTest() {
            if (typingState.timer) {
                clearInterval(typingState.timer);
            }
            
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-input').disabled = true;
            document.getElementById('start-typing-test').disabled = false;
            document.getElementById('typing-time').textContent = document.getElementById('typing-duration').value;
            
            initializeTest();
        }

        // Event listeners
        document.getElementById('start-typing-test').addEventListener('click', startTest);
        document.getElementById('reset-typing-test').addEventListener('click', resetTest);
        
        document.getElementById('typing-input').addEventListener('input', () => {
            if (typingState.isActive) {
                renderText();
                updateStats();
                
                // Check if test is complete
                const input = document.getElementById('typing-input');
                if (input.value.length >= typingState.text.length) {
                    endTest();
                }
            }
        });

        document.getElementById('typing-duration').addEventListener('change', () => {
            if (!typingState.isActive) {
                document.getElementById('typing-time').textContent = document.getElementById('typing-duration').value;
            }
        });

        // Initialize
        initializeTest();
    }

    function renderSpellingBee() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-lg);">
                    <div class="device-info-item">
                        <div class="value" id="bee-score">0</div>
                        <div class="label">Score</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="bee-level">1</div>
                        <div class="label">Level</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="bee-streak">0</div>
                        <div class="label">Streak</div>
                    </div>
                    <div class="device-info-item">
                        <div class="value" id="bee-lives">3</div>
                        <div class="label">Lives</div>
                    </div>
                </div>
                <div class="quiz-question">
                    <h3 id="bee-word-display" style="font-size: 2rem; margin-bottom: var(--space-lg);">Click Start to begin</h3>
                    <div style="text-align: center; margin-bottom: var(--space-lg);">
                        <button id="play-word" class="tool-button tool-button-secondary" disabled> Play Word</button>
                        <button id="play-slow" class="tool-button tool-button-secondary" disabled> Play Slow</button>
                    </div>
                    <input type="text" id="bee-spelling-input" class="tool-input" placeholder="Type the spelling here..." disabled style="font-size: 1.2rem; text-align: center;">
                </div>
                <div class="tool-controls-grid">
                    <button id="start-spelling-bee" class="tool-button">Start Game</button>
                    <button id="submit-spelling" class="tool-button tool-button-secondary" disabled>Submit</button>
                    <button id="skip-word" class="tool-button tool-button-secondary" disabled>Skip Word</button>
                    <button id="end-spelling-game" class="tool-button tool-button-secondary" disabled>End Game</button>
                </div>
            </div>
        `;

        const wordLists = {
            1: ['cat', 'dog', 'sun', 'run', 'fun', 'big', 'red', 'hot', 'top', 'cup'],
            2: ['house', 'mouse', 'phone', 'chair', 'table', 'water', 'happy', 'green', 'quick', 'light'],
            3: ['computer', 'elephant', 'birthday', 'sandwich', 'umbrella', 'butterfly', 'mountain', 'keyboard', 'rainbow', 'chocolate'],
            4: ['beautiful', 'important', 'different', 'wonderful', 'dangerous', 'comfortable', 'interesting', 'necessary', 'available', 'incredible'],
            5: ['extraordinary', 'responsibility', 'communication', 'understanding', 'pronunciation', 'characteristic', 'disappointment', 'entertainment', 'appreciation', 'concentration']
        };

        let beeState = {
            currentWord: '',
            currentLevel: 1,
            score: 0,
            streak: 0,
            lives: 3,
            isActive: false,
            usedWords: []
        };

        function startGame() {
            beeState = {
                currentWord: '',
                currentLevel: 1,
                score: 0,
                streak: 0,
                lives: 3,
                isActive: true,
                usedWords: []
            };
            
            document.getElementById('bee-spelling-input').disabled = false;
            document.getElementById('play-word').disabled = false;
            document.getElementById('play-slow').disabled = false;
            document.getElementById('submit-spelling').disabled = false;
            document.getElementById('skip-word').disabled = false;
            document.getElementById('end-spelling-game').disabled = false;
            document.getElementById('start-spelling-bee').disabled = true;
            
            nextWord();
        }

        function nextWord() {
            const levelWords = wordLists[beeState.currentLevel];
            const availableWords = levelWords.filter(word => !beeState.usedWords.includes(word));
            
            if (availableWords.length === 0) {
                // Level complete
                beeState.currentLevel++;
                beeState.usedWords = [];
                
                if (beeState.currentLevel > 5) {
                    endGame('Congratulations! You completed all levels!');
                    return;
                }
                
                alert(`Level ${beeState.currentLevel - 1} complete! Moving to level ${beeState.currentLevel}`);
                nextWord();
                return;
            }
            
            beeState.currentWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            beeState.usedWords.push(beeState.currentWord);
            
            document.getElementById('bee-word-display').textContent = ' Listen and spell the word';
            document.getElementById('bee-spelling-input').value = '';
            document.getElementById('bee-spelling-input').focus();
            
            updateDisplay();
            
            // Auto-play the word
            setTimeout(() => playWord(), 500);
        }

        function playWord(slow = false) {
            if (!beeState.isActive) return;
            
            // Use Web Speech API to speak the word
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(beeState.currentWord);
                utterance.rate = slow ? 0.5 : 1;
                utterance.volume = 0.8;
                speechSynthesis.speak(utterance);
            } else {
                // Fallback: show the word briefly
                const display = document.getElementById('bee-word-display');
                const originalText = display.textContent;
                display.textContent = beeState.currentWord.toUpperCase();
                setTimeout(() => {
                    display.textContent = originalText;
                }, slow ? 2000 : 1000);
            }
        }

        function submitSpelling() {
            const userSpelling = document.getElementById('bee-spelling-input').value.toLowerCase().trim();
            
            if (userSpelling === beeState.currentWord) {
                // Correct!
                const points = beeState.currentLevel * 10 + beeState.streak * 5;
                beeState.score += points;
                beeState.streak++;
                
                document.getElementById('bee-word-display').textContent = ` Correct! "${beeState.currentWord.toUpperCase()}" (+${points} points)`;
                
                setTimeout(() => {
                    nextWord();
                }, 1500);
                
            } else {
                // Incorrect
                beeState.lives--;
                beeState.streak = 0;
                
                document.getElementById('bee-word-display').textContent = ` Incorrect. The word was "${beeState.currentWord.toUpperCase()}"`;
                
                if (beeState.lives <= 0) {
                    setTimeout(() => {
                        endGame('Game Over! You ran out of lives.');
                    }, 2000);
                } else {
                    setTimeout(() => {
                        nextWord();
                    }, 2000);
                }
            }
            
            updateDisplay();
        }

        function skipWord() {
            if (confirm('Skip this word? You will lose a life.')) {
                beeState.lives--;
                beeState.streak = 0;
                
                document.getElementById('bee-word-display').textContent = ` Skipped. The word was "${beeState.currentWord.toUpperCase()}"`;
                
                if (beeState.lives <= 0) {
                    setTimeout(() => {
                        endGame('Game Over! You ran out of lives.');
                    }, 2000);
                } else {
                    setTimeout(() => {
                        nextWord();
                    }, 1500);
                }
                
                updateDisplay();
            }
        }

        function endGame(message) {
            beeState.isActive = false;
            
            document.getElementById('bee-spelling-input').disabled = true;
            document.getElementById('play-word').disabled = true;
            document.getElementById('play-slow').disabled = true;
            document.getElementById('submit-spelling').disabled = true;
            document.getElementById('skip-word').disabled = true;
            document.getElementById('end-spelling-game').disabled = true;
            document.getElementById('start-spelling-bee').disabled = false;
            
            alert(`${message}\nFinal Score: ${beeState.score}\nLevel Reached: ${beeState.currentLevel}`);
            
            document.getElementById('bee-word-display').textContent = 'Click Start to begin';
        }

        function updateDisplay() {
            document.getElementById('bee-score').textContent = beeState.score;
            document.getElementById('bee-level').textContent = beeState.currentLevel;
            document.getElementById('bee-streak').textContent = beeState.streak;
            document.getElementById('bee-lives').textContent = beeState.lives;
        }

        // Event listeners
        document.getElementById('start-spelling-bee').addEventListener('click', startGame);
        document.getElementById('submit-spelling').addEventListener('click', submitSpelling);
        document.getElementById('skip-word').addEventListener('click', skipWord);
        document.getElementById('play-word').addEventListener('click', () => playWord(false));
        document.getElementById('play-slow').addEventListener('click', () => playWord(true));
        document.getElementById('end-spelling-game').addEventListener('click', () => {
            if (confirm('Are you sure you want to end the game?')) {
                endGame('Game ended by player.');
            }
        });

        document.getElementById('bee-spelling-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && beeState.isActive) {
                submitSpelling();
            }
        });

        // Initialize display
        updateDisplay();
    }

    // --- MINI GAMES ---

    function renderSnakeClassic() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="snake-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="snake-level">1</div><div class="label">Level</div></div>
                    <div class="device-info-item"><div class="value" id="snake-speed">200</div><div class="label">Speed (ms)</div></div>
                    <div class="device-info-item"><div class="value" id="snake-length">3</div><div class="label">Length</div></div>
                </div>
                <canvas id="snake-canvas" width="400" height="400" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,0,0.5); display: block; margin: 0 auto;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="snake-start" class="tool-button">Start Game</button>
                    <button id="snake-pause" class="tool-button tool-button-secondary" disabled>Pause</button>
                    <button id="snake-reset" class="tool-button tool-button-secondary">Reset</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Use Arrow Keys or WASD to control  Collect glowing food  Avoid walls and yourself</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('snake-canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        let food = {x: 15, y: 15, isGolden: false};
        let dx = 1, dy = 0;
        let score = 0, level = 1, speed = 200;
        let gameLoop = null;
        let isPaused = false;
        let obstacles = [];

        function drawGame() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(0,212,255,0.1)';
            for (let i = 0; i < tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw obstacles
            ctx.fillStyle = '#FF4D00';
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x * gridSize, obs.y * gridSize, gridSize - 2, gridSize - 2);
            });

            // Draw food with glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = food.isGolden ? '#FFD700' : '#00FF00';
            ctx.fillStyle = food.isGolden ? '#FFD700' : '#00FF00';
            ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 2, gridSize - 4, gridSize - 4);
            ctx.shadowBlur = 0;

            // Draw snake with gradient
            snake.forEach((segment, index) => {
                const alpha = 1 - (index / snake.length) * 0.5;
                ctx.fillStyle = `rgba(0,212,255,${alpha})`;
                ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });

            // Draw head differently
            ctx.fillStyle = '#8B5CF6';
            ctx.fillRect(snake[0].x * gridSize + 3, snake[0].y * gridSize + 3, gridSize - 6, gridSize - 6);
        }

        function moveSnake() {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};

            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            // Check obstacle collision
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                score += food.isGolden ? 10 : 1;
                if (score % 5 === 0) {
                    speed = Math.max(50, speed - 10);
                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameUpdate, speed);
                }
                if (score % 10 === 0) level++;
                if (level >= 4) generateObstacles();
                placeFood();
                updateStats();
            } else {
                snake.pop();
            }

            drawGame();
        }

        function placeFood() {
            food.isGolden = score > 0 && score % 10 === 0;
            do {
                food.x = Math.floor(Math.random() * tileCount);
                food.y = Math.floor(Math.random() * tileCount);
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y) || obstacles.some(obs => obs.x === food.x && obs.y === food.y));
        }

        function generateObstacles() {
            obstacles = [];
            const count = level >= 7 ? 15 : level >= 4 ? 8 : 0;
            for (let i = 0; i < count; i++) {
                let obs;
                do {
                    obs = {x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount)};
                } while (snake.some(s => s.x === obs.x && s.y === obs.y) || (obs.x === food.x && obs.y === food.y));
                obstacles.push(obs);
            }
        }

        function gameUpdate() {
            if (!isPaused) moveSnake();
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Final Score: ${score} | Level: ${level}`);
            document.getElementById('snake-start').disabled = false;
            document.getElementById('snake-pause').disabled = true;
        }

        function updateStats() {
            document.getElementById('snake-score').textContent = score;
            document.getElementById('snake-level').textContent = level;
            document.getElementById('snake-speed').textContent = speed;
            document.getElementById('snake-length').textContent = snake.length;
        }

        document.getElementById('snake-start').addEventListener('click', () => {
            snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
            dx = 1; dy = 0;
            score = 0; level = 1; speed = 200;
            obstacles = [];
            isPaused = false;
            placeFood();
            updateStats();
            drawGame();
            gameLoop = setInterval(gameUpdate, speed);
            document.getElementById('snake-start').disabled = true;
            document.getElementById('snake-pause').disabled = false;
        });

        document.getElementById('snake-pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('snake-reset').addEventListener('click', () => {
            clearInterval(gameLoop);
            snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
            dx = 1; dy = 0;
            score = 0; level = 1; speed = 200;
            obstacles = [];
            placeFood();
            updateStats();
            drawGame();
            document.getElementById('snake-start').disabled = false;
            document.getElementById('snake-pause').disabled = true;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w') { if (dy === 0) { dx = 0; dy = -1; } }
            else if (e.key === 'ArrowDown' || e.key === 's') { if (dy === 0) { dx = 0; dy = 1; } }
            else if (e.key === 'ArrowLeft' || e.key === 'a') { if (dx === 0) { dx = -1; dy = 0; } }
            else if (e.key === 'ArrowRight' || e.key === 'd') { if (dx === 0) { dx = 1; dy = 0; } }
        });

        placeFood();
        drawGame();
        updateStats();
    }

    function renderNeonFlappy() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="flappy-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="flappy-high">0</div><div class="label">High Score</div></div>
                    <div class="device-info-item"><div class="value" id="flappy-mode">Day</div><div class="label">Mode</div></div>
                </div>
                <canvas id="flappy-canvas" width="400" height="600" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(10,5,30,0.9); display: block; margin: 0 auto; cursor: pointer;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="flappy-start" class="tool-button">Start Game</button>
                    <button id="flappy-reset" class="tool-button tool-button-secondary">Reset</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Click or Press SPACE to flap  Avoid the glowing pipes  Night mode after 50 points</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('flappy-canvas');
        const ctx = canvas.getContext('2d');

        let bird = {y: canvas.height / 2, velocity: 0, radius: 15};
        let pipes = [];
        let score = 0, highScore = 0;
        let gameLoop = null;
        let gravity = 0.5, flapPower = -8;
        let pipeSpeed = 2;
        let gapSize = 150;
        let nightMode = false;

        function drawBird() {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00D4FF';
            ctx.fillStyle = '#00D4FF';
            ctx.beginPath();
            ctx.arc(50, bird.y, bird.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = pipe.moving ? '#FF00FF' : '#00FF00';
                ctx.fillStyle = pipe.moving ? '#FF00FF' : '#00FF00';
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
                ctx.fillRect(pipe.x, pipe.bottom, pipe.width, canvas.height - pipe.bottom);
                ctx.shadowBlur = 0;
            });
        }

        function drawBackground() {
            if (nightMode) {
                ctx.fillStyle = 'rgba(0,0,0,0.95)';
            } else {
                ctx.fillStyle = 'rgba(10,5,30,0.3)';
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function createPipe() {
            const minTop = 50;
            const maxTop = canvas.height - gapSize - 50;
            const top = Math.random() * (maxTop - minTop) + minTop;
            pipes.push({
                x: canvas.width,
                top: top,
                bottom: top + gapSize,
                width: 50,
                scored: false,
                moving: score >= 30 && Math.random() > 0.7
            });
        }

        function updateGame() {
            drawBackground();

            bird.velocity += gravity;
            bird.y += bird.velocity;

            if (bird.y + bird.radius > canvas.height || bird.y - bird.radius < 0) {
                gameOver();
                return;
            }

            pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);

            pipes.forEach(pipe => {
                pipe.x -= pipeSpeed;

                if (pipe.moving) {
                    pipe.top += Math.sin(Date.now() / 500) * 2;
                    pipe.bottom = pipe.top + gapSize;
                }

                if (pipe.x + pipe.width < 50 && !pipe.scored) {
                    score++;
                    pipe.scored = true;
                    if (score > highScore) highScore = score;
                    if (score % 10 === 0) gapSize = Math.max(100, gapSize - 5);
                    if (score % 20 === 0) pipeSpeed = Math.min(5, pipeSpeed + 0.5);
                    if (score >= 50) nightMode = true;
                    updateStats();
                }

                if (50 > pipe.x && 50 < pipe.x + pipe.width) {
                    if (bird.y - bird.radius < pipe.top || bird.y + bird.radius > pipe.bottom) {
                        gameOver();
                        return;
                    }
                }
            });

            if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 200) {
                createPipe();
            }

            drawPipes();
            drawBird();
        }

        function flap() {
            bird.velocity = flapPower;
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Score: ${score} | High Score: ${highScore}`);
            document.getElementById('flappy-start').disabled = false;
        }

        function updateStats() {
            document.getElementById('flappy-score').textContent = score;
            document.getElementById('flappy-high').textContent = highScore;
            document.getElementById('flappy-mode').textContent = nightMode ? 'Night' : 'Day';
        }

        canvas.addEventListener('click', () => { if (gameLoop) flap(); });
        document.addEventListener('keydown', (e) => { if (e.key === ' ' && gameLoop) { e.preventDefault(); flap(); } });

        document.getElementById('flappy-start').addEventListener('click', () => {
            bird = {y: canvas.height / 2, velocity: 0, radius: 15};
            pipes = [];
            score = 0;
            pipeSpeed = 2;
            gapSize = 150;
            nightMode = false;
            updateStats();
            gameLoop = setInterval(updateGame, 1000 / 60);
            document.getElementById('flappy-start').disabled = true;
        });

        document.getElementById('flappy-reset').addEventListener('click', () => {
            clearInterval(gameLoop);
            gameLoop = null;
            bird = {y: canvas.height / 2, velocity: 0, radius: 15};
            pipes = [];
            score = 0;
            nightMode = false;
            drawBackground();
            drawBird();
            updateStats();
            document.getElementById('flappy-start').disabled = false;
        });

        drawBackground();
        drawBird();
    }

    function render2048Fusion() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="fusion-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="fusion-best">0</div><div class="label">Best</div></div>
                    <div class="device-info-item"><div class="value" id="fusion-target">2048</div><div class="label">Target</div></div>
                </div>
                <div id="fusion-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; max-width: 400px; margin: 0 auto; padding: var(--space-md); background: rgba(0,0,0,0.3); border-radius: var(--radius-lg);"></div>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="fusion-new" class="tool-button">New Game</button>
                    <button id="fusion-undo" class="tool-button tool-button-secondary" disabled>Undo</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Use Arrow Keys or Swipe  Merge matching tiles  Reach 2048!</p>
                </div>
            </div>
        `;

        let grid = Array(4).fill().map(() => Array(4).fill(0));
        let score = 0, bestScore = 0;
        let previousState = null;

        const colors = {
            2: '#00D4FF', 4: '#8B5CF6', 8: '#EC4899', 16: '#F59E0B',
            32: '#10B981', 64: '#EF4444', 128: '#FFD700', 256: '#FF69B4',
            512: '#00CED1', 1024: '#FF6347', 2048: '#FFD700', 4096: '#9370DB'
        };

        function drawGrid() {
            const container = document.getElementById('fusion-grid');
            container.innerHTML = '';
            grid.forEach(row => {
                row.forEach(cell => {
                    const tile = document.createElement('div');
                    tile.style.cssText = `
                        aspect-ratio: 1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        font-weight: bold;
                        border-radius: var(--radius-md);
                        background: ${cell ? colors[cell] || '#9370DB' : 'rgba(255,255,255,0.1)'};
                        color: var(--color-bg-primary);
                        box-shadow: ${cell ? '0 0 20px ' + (colors[cell] || '#9370DB') + '80' : 'none'};
                        transition: all 0.2s;
                    `;
                    tile.textContent = cell || '';
                    container.appendChild(tile);
                });
            });
        }

        function addRandomTile() {
            const empty = [];
            grid.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell === 0) empty.push({i, j});
                });
            });
            if (empty.length > 0) {
                const pos = empty[Math.floor(Math.random() * empty.length)];
                grid[pos.i][pos.j] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function move(direction) {
            previousState = {grid: JSON.parse(JSON.stringify(grid)), score};
            let moved = false;

            const rotate = () => {
                grid = grid[0].map((_, i) => grid.map(row => row[i]).reverse());
            };

            const moveLeft = () => {
                grid.forEach(row => {
                    const filtered = row.filter(cell => cell !== 0);
                    for (let i = 0; i < filtered.length - 1; i++) {
                        if (filtered[i] === filtered[i + 1]) {
                            filtered[i] *= 2;
                            score += filtered[i];
                            filtered.splice(i + 1, 1);
                            moved = true;
                        }
                    }
                    const newRow = filtered.concat(Array(4 - filtered.length).fill(0));
                    if (JSON.stringify(row) !== JSON.stringify(newRow)) moved = true;
                    row.splice(0, 4, ...newRow);
                });
            };

            if (direction === 'left') moveLeft();
            else if (direction === 'right') { rotate(); rotate(); moveLeft(); rotate(); rotate(); }
            else if (direction === 'up') { rotate(); rotate(); rotate(); moveLeft(); rotate(); }
            else if (direction === 'down') { rotate(); moveLeft(); rotate(); rotate(); rotate(); }

            if (moved) {
                addRandomTile();
                if (score > bestScore) bestScore = score;
                updateStats();
                drawGrid();
                document.getElementById('fusion-undo').disabled = false;
                checkWin();
                if (checkGameOver()) alert('Game Over! No more moves available.');
            }
        }

        function checkWin() {
            if (grid.some(row => row.includes(2048))) {
                alert('Congratulations! You reached 2048!');
            }
        }

        function checkGameOver() {
            if (grid.some(row => row.includes(0))) return false;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if ((j < 3 && grid[i][j] === grid[i][j + 1]) || (i < 3 && grid[i][j] === grid[i + 1][j])) {
                        return false;
                    }
                }
            }
            return true;
        }

        function updateStats() {
            document.getElementById('fusion-score').textContent = score;
            document.getElementById('fusion-best').textContent = bestScore;
        }

        function newGame() {
            grid = Array(4).fill().map(() => Array(4).fill(0));
            score = 0;
            previousState = null;
            addRandomTile();
            addRandomTile();
            updateStats();
            drawGrid();
            document.getElementById('fusion-undo').disabled = true;
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') move('left');
            else if (e.key === 'ArrowRight') move('right');
            else if (e.key === 'ArrowUp') move('up');
            else if (e.key === 'ArrowDown') move('down');
        });

        document.getElementById('fusion-new').addEventListener('click', newGame);
        document.getElementById('fusion-undo').addEventListener('click', () => {
            if (previousState) {
                grid = previousState.grid;
                score = previousState.score;
                updateStats();
                drawGrid();
                document.getElementById('fusion-undo').disabled = true;
            }
        });

        newGame();
    }

    function renderLaserBreaker() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="breaker-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="breaker-level">1</div><div class="label">Level</div></div>
                    <div class="device-info-item"><div class="value" id="breaker-lives">3</div><div class="label">Lives</div></div>
                </div>
                <canvas id="breaker-canvas" width="400" height="500" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,20,0.9); display: block; margin: 0 auto;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="breaker-start" class="tool-button">Start Game</button>
                    <button id="breaker-pause" class="tool-button tool-button-secondary" disabled>Pause</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Move mouse to control paddle  Break all bricks  Collect power-ups</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('breaker-canvas');
        const ctx = canvas.getContext('2d');

        let paddle = {x: canvas.width / 2 - 40, y: canvas.height - 30, width: 80, height: 10, speed: 8};
        let ball = {x: canvas.width / 2, y: canvas.height - 50, dx: 3, dy: -3, radius: 6};
        let bricks = [];
        let score = 0, level = 1, lives = 3;
        let gameLoop = null, isPaused = false;
        let powerUps = [];

        function createBricks() {
            bricks = [];
            const rows = 4 + level;
            const cols = 8;
            const brickWidth = (canvas.width - 20) / cols;
            const brickHeight = 20;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const hits = level >= 3 && Math.random() > 0.7 ? 2 : 1;
                    bricks.push({
                        x: j * brickWidth + 10,
                        y: i * brickHeight + 30,
                        width: brickWidth - 2,
                        height: brickHeight - 2,
                        hits: hits,
                        maxHits: hits,
                        visible: true
                    });
                }
            }
        }

        function drawGame() {
            ctx.fillStyle = 'rgba(0,0,20,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw paddle
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00D4FF';
            ctx.fillStyle = '#00D4FF';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.shadowBlur = 0;

            // Draw ball
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#FFD700';
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw bricks
            bricks.forEach(brick => {
                if (brick.visible) {
                    const hue = (brick.hits / brick.maxHits) * 120;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                }
            });

            // Draw powerUps
            powerUps.forEach(pu => {
                ctx.fillStyle = pu.type === 'expand' ? '#00FF00' : '#FF00FF';
                ctx.fillRect(pu.x, pu.y, 15, 15);
            });
        }

        function updateGame() {
            if (isPaused) return;

            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collision
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
            if (ball.y - ball.radius < 0) ball.dy *= -1;

            // Paddle collision
            if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                ball.dy *= -1;
                const hitPos = (ball.x - paddle.x) / paddle.width;
                ball.dx = (hitPos - 0.5) * 8;
            }

            // Bottom collision
            if (ball.y + ball.radius > canvas.height) {
                lives--;
                if (lives > 0) {
                    ball.x = canvas.width / 2;
                    ball.y = canvas.height - 50;
                    ball.dx = 3;
                    ball.dy = -3;
                } else {
                    gameOver();
                    return;
                }
                updateStats();
            }

            // Brick collision
            bricks.forEach(brick => {
                if (brick.visible && ball.x > brick.x && ball.x < brick.x + brick.width && ball.y > brick.y && ball.y < brick.y + brick.height) {
                    ball.dy *= -1;
                    brick.hits--;
                    if (brick.hits <= 0) {
                        brick.visible = false;
                        score += 10;
                        if (Math.random() > 0.8) {
                            powerUps.push({x: brick.x, y: brick.y, type: Math.random() > 0.5 ? 'expand' : 'multiball'});
                        }
                    }
                    updateStats();
                }
            });

            // Power-ups
            powerUps = powerUps.filter(pu => {
                pu.y += 2;
                if (pu.y > paddle.y && pu.x > paddle.x && pu.x < paddle.x + paddle.width) {
                    if (pu.type === 'expand') paddle.width = Math.min(150, paddle.width + 20);
                    return false;
                }
                return pu.y < canvas.height;
            });

            // Level complete
            if (bricks.every(brick => !brick.visible)) {
                level++;
                alert(`Level ${level - 1} Complete!`);
                createBricks();
                ball.x = canvas.width / 2;
                ball.y = canvas.height - 50;
                ball.dx *= 1.1;
                ball.dy *= 1.1;
                updateStats();
            }

            drawGame();
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Final Score: ${score} | Level: ${level}`);
            document.getElementById('breaker-start').disabled = false;
            document.getElementById('breaker-pause').disabled = true;
        }

        function updateStats() {
            document.getElementById('breaker-score').textContent = score;
            document.getElementById('breaker-level').textContent = level;
            document.getElementById('breaker-lives').textContent = lives;
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            paddle.x = e.clientX - rect.left - paddle.width / 2;
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
        });

        document.getElementById('breaker-start').addEventListener('click', () => {
            score = 0; level = 1; lives = 3;
            paddle.width = 80;
            ball.dx = 3; ball.dy = -3;
            createBricks();
            updateStats();
            gameLoop = setInterval(updateGame, 1000 / 60);
            document.getElementById('breaker-start').disabled = true;
            document.getElementById('breaker-pause').disabled = false;
        });

        document.getElementById('breaker-pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        createBricks();
        drawGame();
    }

    function renderCosmicDefender() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="cosmic-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="cosmic-health">100</div><div class="label">Health</div></div>
                    <div class="device-info-item"><div class="value" id="cosmic-level">1</div><div class="label">Level</div></div>
                    <div class="device-info-item"><div class="value" id="cosmic-weapon">Basic</div><div class="label">Weapon</div></div>
                </div>
                <canvas id="cosmic-canvas" width="400" height="500" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,10,1); display: block; margin: 0 auto;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="cosmic-start" class="tool-button">Start Game</button>
                    <button id="cosmic-pause" class="tool-button tool-button-secondary" disabled>Pause</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Move mouse to fly  Auto-fire  Avoid enemies  Collect power-ups</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('cosmic-canvas');
        const ctx = canvas.getContext('2d');

        let ship = {x: canvas.width / 2, y: canvas.height - 60, width: 30, height: 30, health: 100, weapon: 'basic'};
        let bullets = [], enemies = [], powerUps = [];
        let score = 0, level = 1;
        let gameLoop = null, isPaused = false;
        let enemySpawnRate = 60;

        function drawShip() {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00D4FF';
            ctx.fillStyle = '#00D4FF';
            ctx.beginPath();
            ctx.moveTo(ship.x, ship.y - 15);
            ctx.lineTo(ship.x - 15, ship.y + 15);
            ctx.lineTo(ship.x + 15, ship.y + 15);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function spawnEnemy() {
            const types = ['basic', 'fast', 'tank', 'zigzag', 'shooter'];
            const type = types[Math.min(level - 1, types.length - 1)];
            enemies.push({
                x: Math.random() * (canvas.width - 30),
                y: -30,
                width: 25,
                height: 25,
                type: type,
                health: type === 'tank' ? 3 : 1,
                speed: type === 'fast' ? 4 : type === 'tank' ? 1 : 2,
                zigzag: 0
            });
        }

        function updateGame() {
            if (isPaused) return;

            ctx.fillStyle = 'rgba(0,0,10,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Spawn enemies
            if (Math.random() < 1 / enemySpawnRate) spawnEnemy();

            // Auto-fire
            if (Math.random() < 0.15) {
                bullets.push({x: ship.x, y: ship.y - 20, speed: 7});
            }

            // Update bullets
            bullets = bullets.filter(b => {
                b.y -= b.speed;
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(b.x - 2, b.y, 4, 10);
                return b.y > 0;
            });

            // Update enemies
            enemies = enemies.filter(e => {
                if (e.type === 'zigzag') {
                    e.zigzag += 0.1;
                    e.x += Math.sin(e.zigzag) * 3;
                }
                e.y += e.speed;

                ctx.fillStyle = e.type === 'tank' ? '#FF0000' : e.type === 'fast' ? '#FF00FF' : '#00FF00';
                ctx.fillRect(e.x, e.y, e.width, e.height);

                // Check bullet collision
                bullets.forEach((b, bi) => {
                    if (b.x > e.x && b.x < e.x + e.width && b.y > e.y && b.y < e.y + e.height) {
                        e.health--;
                        bullets.splice(bi, 1);
                        if (e.health <= 0) {
                            score += 10;
                            if (Math.random() > 0.9) {
                                powerUps.push({x: e.x, y: e.y, type: 'weapon'});
                            }
                            updateStats();
                            return false;
                        }
                    }
                });

                // Check ship collision
                if (Math.abs(e.x - ship.x) < 30 && Math.abs(e.y - ship.y) < 30) {
                    ship.health -= 10;
                    updateStats();
                    if (ship.health <= 0) gameOver();
                    return false;
                }

                return e.y < canvas.height;
            });

            // Update power-ups
            powerUps = powerUps.filter(pu => {
                pu.y += 2;
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(pu.x, pu.y, 15, 15);
                if (Math.abs(pu.x - ship.x) < 25 && Math.abs(pu.y - ship.y) < 25) {
                    ship.weapon = 'laser';
                    updateStats();
                    setTimeout(() => { ship.weapon = 'basic'; updateStats(); }, 10000);
                    return false;
                }
                return pu.y < canvas.height;
            });

            drawShip();

            // Level up
            if (score > 0 && score % 100 === 0 && level < 10) {
                level++;
                enemySpawnRate = Math.max(20, enemySpawnRate - 5);
                updateStats();
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Final Score: ${score} | Level: ${level}`);
            document.getElementById('cosmic-start').disabled = false;
            document.getElementById('cosmic-pause').disabled = true;
        }

        function updateStats() {
            document.getElementById('cosmic-score').textContent = score;
            document.getElementById('cosmic-health').textContent = ship.health;
            document.getElementById('cosmic-level').textContent = level;
            document.getElementById('cosmic-weapon').textContent = ship.weapon === 'laser' ? 'Laser' : 'Basic';
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            ship.x = e.clientX - rect.left;
            ship.x = Math.max(20, Math.min(canvas.width - 20, ship.x));
        });

        document.getElementById('cosmic-start').addEventListener('click', () => {
            ship.health = 100;
            score = 0; level = 1;
            bullets = []; enemies = []; powerUps = [];
            enemySpawnRate = 60;
            updateStats();
            gameLoop = setInterval(updateGame, 1000 / 60);
            document.getElementById('cosmic-start').disabled = true;
            document.getElementById('cosmic-pause').disabled = false;
        });

        document.getElementById('cosmic-pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });
    }

    function renderPixelSweeper() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="sweeper-mines">10</div><div class="label">Mines</div></div>
                    <div class="device-info-item"><div class="value" id="sweeper-time">0</div><div class="label">Time (s)</div></div>
                    <div class="device-info-item"><div class="value" id="sweeper-difficulty">Beginner</div><div class="label">Difficulty</div></div>
                </div>
                <div id="sweeper-grid" style="display: inline-block; margin: 0 auto;"></div>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="sweeper-beginner" class="tool-button">Beginner</button>
                    <button id="sweeper-intermediate" class="tool-button tool-button-secondary">Intermediate</button>
                    <button id="sweeper-expert" class="tool-button tool-button-secondary">Expert</button>
                    <button id="sweeper-new" class="tool-button tool-button-secondary">New Game</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Left-click to reveal  Right-click to flag  Avoid mines!</p>
                </div>
            </div>
        `;

        let grid = [], rows = 9, cols = 9, mines = 10;
        let revealed = 0, flagged = 0;
        let gameStarted = false, gameOver = false;
        let timer = null, time = 0;

        function createGrid() {
            grid = Array(rows).fill().map(() => Array(cols).fill().map(() => ({
                isMine: false,
                revealed: false,
                flagged: false,
                adjacentMines: 0
            })));

            let minesPlaced = 0;
            while (minesPlaced < mines) {
                const r = Math.floor(Math.random() * rows);
                const c = Math.floor(Math.random() * cols);
                if (!grid[r][c].isMine) {
                    grid[r][c].isMine = true;
                    minesPlaced++;
                }
            }

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (!grid[r][c].isMine) {
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc].isMine) {
                                    count++;
                                }
                            }
                        }
                        grid[r][c].adjacentMines = count;
                    }
                }
            }
        }

        function drawGrid() {
            const container = document.getElementById('sweeper-grid');
            container.style.cssText = `display: grid; grid-template-columns: repeat(${cols}, 30px); gap: 2px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: var(--radius-md);`;
            container.innerHTML = '';

            grid.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const cellEl = document.createElement('div');
                    cellEl.style.cssText = `
                        width: 30px; height: 30px;
                        display: flex; align-items: center; justify-content: center;
                        font-size: 14px; font-weight: bold;
                        border-radius: 4px; cursor: pointer;
                        background: ${cell.revealed ? (cell.isMine ? '#FF0000' : 'rgba(0,212,255,0.2)') : 'rgba(139,92,246,0.5)'};
                        color: ${cell.adjacentMines === 1 ? '#00D4FF' : cell.adjacentMines === 2 ? '#00FF00' : cell.adjacentMines === 3 ? '#FFD700' : '#FF00FF'};
                        box-shadow: ${cell.revealed ? 'inset 0 0 10px rgba(0,0,0,0.5)' : '0 0 10px rgba(139,92,246,0.5)'};
                    `;

                    if (cell.flagged) cellEl.textContent = '';
                    else if (cell.revealed) {
                        if (cell.isMine) cellEl.textContent = '';
                        else if (cell.adjacentMines > 0) cellEl.textContent = cell.adjacentMines;
                    }

                    cellEl.addEventListener('click', () => revealCell(r, c));
                    cellEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(r, c);
                    });

                    container.appendChild(cellEl);
                });
            });
        }

        function revealCell(r, c) {
            if (gameOver || grid[r][c].revealed || grid[r][c].flagged) return;

            if (!gameStarted) {
                gameStarted = true;
                timer = setInterval(() => {
                    time++;
                    document.getElementById('sweeper-time').textContent = time;
                }, 1000);
            }

            grid[r][c].revealed = true;
            revealed++;

            if (grid[r][c].isMine) {
                endGame(false);
                return;
            }

            if (grid[r][c].adjacentMines === 0) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].revealed) {
                            revealCell(nr, nc);
                        }
                    }
                }
            }

            if (revealed === rows * cols - mines) {
                endGame(true);
            }

            drawGrid();
        }

        function toggleFlag(r, c) {
            if (gameOver || grid[r][c].revealed) return;
            grid[r][c].flagged = !grid[r][c].flagged;
            flagged += grid[r][c].flagged ? 1 : -1;
            document.getElementById('sweeper-mines').textContent = mines - flagged;
            drawGrid();
        }

        function endGame(won) {
            gameOver = true;
            clearInterval(timer);
            grid.forEach(row => row.forEach(cell => { if (cell.isMine) cell.revealed = true; }));
            drawGrid();
            alert(won ? `Congratulations! You won in ${time} seconds!` : 'Game Over! You hit a mine!');
        }

        function newGame(difficulty) {
            if (difficulty === 'beginner') { rows = 9; cols = 9; mines = 10; }
            else if (difficulty === 'intermediate') { rows = 16; cols = 16; mines = 40; }
            else if (difficulty === 'expert') { rows = 16; cols = 30; mines = 99; }

            clearInterval(timer);
            time = 0;
            revealed = 0;
            flagged = 0;
            gameStarted = false;
            gameOver = false;

            document.getElementById('sweeper-mines').textContent = mines;
            document.getElementById('sweeper-time').textContent = time;
            document.getElementById('sweeper-difficulty').textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

            createGrid();
            drawGrid();
        }

        document.getElementById('sweeper-beginner').addEventListener('click', () => newGame('beginner'));
        document.getElementById('sweeper-intermediate').addEventListener('click', () => newGame('intermediate'));
        document.getElementById('sweeper-expert').addEventListener('click', () => newGame('expert'));
        document.getElementById('sweeper-new').addEventListener('click', () => {
            const current = document.getElementById('sweeper-difficulty').textContent.toLowerCase();
            newGame(current);
        });

        newGame('beginner');
    }

    function renderPacmanNeon() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="pacman-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="pacman-level">1</div><div class="label">Level</div></div>
                    <div class="device-info-item"><div class="value" id="pacman-lives">3</div><div class="label">Lives</div></div>
                </div>
                <canvas id="pacman-canvas" width="420" height="460" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,0,0.9); display: block; margin: 0 auto;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="pacman-start" class="tool-button">Start Game</button>
                    <button id="pacman-pause" class="tool-button tool-button-secondary" disabled>Pause</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Arrow keys to move  Eat all dots  Avoid ghosts  Power pellets make ghosts edible</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('pacman-canvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 20;

        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,2,1],
            [1,3,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,1,0,1,0,1,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
            [0,0,0,0,2,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let pacman = {x: 10, y: 15, dir: 0, mouthOpen: true};
        let ghosts = [
            {x: 9, y: 9, color: '#FF0000', dir: 0},
            {x: 10, y: 9, color: '#FFB8FF', dir: 1},
            {x: 11, y: 9, color: '#00FFFF', dir: 2},
            {x: 10, y: 10, color: '#FFB852', dir: 3}
        ];
        let score = 0, level = 1, lives = 3;
        let dotsRemaining = 0;
        let powerMode = false, powerTimer = 0;
        let gameLoop = null, isPaused = false;
        let nextDir = 0;

        function countDots() {
            dotsRemaining = 0;
            maze.forEach(row => row.forEach(cell => { if (cell === 2 || cell === 3) dotsRemaining++; }));
        }

        function drawMaze() {
            maze.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === 1) {
                        ctx.strokeStyle = '#00D4FF';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    } else if (cell === 2) {
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 3) {
                        ctx.fillStyle = '#FFD700';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
            });
        }

        function drawPacman() {
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            const mouthAngle = pacman.mouthOpen ? 0.2 : 0;
            ctx.arc(pacman.x * tileSize + tileSize / 2, pacman.y * tileSize + tileSize / 2, tileSize / 2 - 2,
                mouthAngle + pacman.dir * Math.PI / 2, (2 - mouthAngle) * Math.PI + pacman.dir * Math.PI / 2);
            ctx.lineTo(pacman.x * tileSize + tileSize / 2, pacman.y * tileSize + tileSize / 2);
            ctx.fill();
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                ctx.fillStyle = powerMode ? '#0000FF' : ghost.color;
                ctx.beginPath();
                ctx.arc(ghost.x * tileSize + tileSize / 2, ghost.y * tileSize + tileSize / 2 - 3, tileSize / 2 - 2, Math.PI, 0);
                ctx.lineTo(ghost.x * tileSize + tileSize - 2, ghost.y * tileSize + tileSize - 2);
                ctx.lineTo(ghost.x * tileSize + tileSize - 5, ghost.y * tileSize + tileSize / 2 + 3);
                ctx.lineTo(ghost.x * tileSize + tileSize / 2, ghost.y * tileSize + tileSize - 2);
                ctx.lineTo(ghost.x * tileSize + 5, ghost.y * tileSize + tileSize / 2 + 3);
                ctx.lineTo(ghost.x * tileSize + 2, ghost.y * tileSize + tileSize - 2);
                ctx.closePath();
                ctx.fill();
            });
        }

        function canMove(x, y) {
            return maze[y] && maze[y][x] !== 1 && maze[y][x] !== undefined;
        }

        function updateGame() {
            if (isPaused) return;

            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const dirs = [{x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 0, y: -1}];

            // Try to change direction
            const nextMove = dirs[nextDir];
            if (canMove(pacman.x + nextMove.x, pacman.y + nextMove.y)) {
                pacman.dir = nextDir;
            }

            // Move pacman
            const move = dirs[pacman.dir];
            if (canMove(pacman.x + move.x, pacman.y + move.y)) {
                pacman.x += move.x;
                pacman.y += move.y;
                pacman.mouthOpen = !pacman.mouthOpen;
            }

            // Eat dots
            if (maze[pacman.y][pacman.x] === 2) {
                maze[pacman.y][pacman.x] = 0;
                score += 10;
                dotsRemaining--;
            } else if (maze[pacman.y][pacman.x] === 3) {
                maze[pacman.y][pacman.x] = 0;
                score += 50;
                dotsRemaining--;
                powerMode = true;
                powerTimer = 60;
            }

            // Power mode timer
            if (powerMode) {
                powerTimer--;
                if (powerTimer <= 0) powerMode = false;
            }

            // Move ghosts
            ghosts.forEach(ghost => {
                if (Math.random() < 0.3) {
                    const possibleDirs = [0, 1, 2, 3].filter(d => {
                        const m = dirs[d];
                        return canMove(ghost.x + m.x, ghost.y + m.y);
                    });
                    ghost.dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }
                const gMove = dirs[ghost.dir];
                if (canMove(ghost.x + gMove.x, ghost.y + gMove.y)) {
                    ghost.x += gMove.x;
                    ghost.y += gMove.y;
                }

                // Check collision with pacman
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (powerMode) {
                        score += 200;
                        ghost.x = 10; ghost.y = 9;
                    } else {
                        lives--;
                        if (lives > 0) {
                            pacman.x = 10; pacman.y = 15;
                        } else {
                            gameOver();
                            return;
                        }
                    }
                }
            });

            // Check level complete
            if (dotsRemaining === 0) {
                level++;
                alert(`Level ${level - 1} Complete!`);
                resetLevel();
            }

            drawMaze();
            drawGhosts();
            drawPacman();
            updateStats();
        }

        function resetLevel() {
            maze.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === 0) {
                        maze[y][x] = x === 3 || x === 17 ? (y === 3 || y === 16 ? 3 : 2) : 2;
                    }
                });
            });
            countDots();
            pacman.x = 10; pacman.y = 15;
            ghosts = [
                {x: 9, y: 9, color: '#FF0000', dir: 0},
                {x: 10, y: 9, color: '#FFB8FF', dir: 1},
                {x: 11, y: 9, color: '#00FFFF', dir: 2},
                {x: 10, y: 10, color: '#FFB852', dir: 3}
            ];
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Final Score: ${score} | Level: ${level}`);
            document.getElementById('pacman-start').disabled = false;
            document.getElementById('pacman-pause').disabled = true;
        }

        function updateStats() {
            document.getElementById('pacman-score').textContent = score;
            document.getElementById('pacman-level').textContent = level;
            document.getElementById('pacman-lives').textContent = lives;
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') nextDir = 0;
            else if (e.key === 'ArrowDown') nextDir = 1;
            else if (e.key === 'ArrowLeft') nextDir = 2;
            else if (e.key === 'ArrowUp') nextDir = 3;
        });

        document.getElementById('pacman-start').addEventListener('click', () => {
            score = 0; level = 1; lives = 3;
            powerMode = false;
            resetLevel();
            updateStats();
            gameLoop = setInterval(updateGame, 150);
            document.getElementById('pacman-start').disabled = true;
            document.getElementById('pacman-pause').disabled = false;
        });

        document.getElementById('pacman-pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        countDots();
        drawMaze();
        drawPacman();
        drawGhosts();
    }

    function renderTetrisDimension() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="tetris-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="tetris-lines">0</div><div class="label">Lines</div></div>
                    <div class="device-info-item"><div class="value" id="tetris-level">1</div><div class="label">Level</div></div>
                    <div class="device-info-item"><div class="value" id="tetris-mode">Marathon</div><div class="label">Mode</div></div>
                </div>
                <div style="display: flex; justify-content: center; gap: var(--space-md);">
                    <canvas id="tetris-canvas" width="240" height="480" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,0,0.9);"></canvas>
                    <canvas id="tetris-next" width="100" height="100" style="border: 2px solid var(--color-secondary); border-radius: var(--radius-md); background: rgba(0,0,0,0.9);"></canvas>
                </div>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="tetris-start" class="tool-button">Start Marathon</button>
                    <button id="tetris-sprint" class="tool-button tool-button-secondary">Sprint (40 Lines)</button>
                    <button id="tetris-pause" class="tool-button tool-button-secondary" disabled>Pause</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Arrow keys: Move  Up: Rotate  Down: Soft drop  Space: Hard drop</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('tetris-next');
        const nextCtx = nextCanvas.getContext('2d');
        const tileSize = 24;
        const rows = 20, cols = 10;

        const pieces = {
            I: [[1,1,1,1]], O: [[1,1],[1,1]], T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]], Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]], L: [[0,0,1],[1,1,1]]
        };
        const colors = {I: '#00D4FF', O: '#FFD700', T: '#8B5CF6', S: '#00FF00', Z: '#FF0000', J: '#0000FF', L: '#FF8C00'};

        let board = Array(rows).fill().map(() => Array(cols).fill(0));
        let current = null, next = null;
        let score = 0, lines = 0, level = 1;
        let gameLoop = null, isPaused = false;
        let gameMode = 'marathon';
        let dropSpeed = 500;

        function getRandomPiece() {
            const keys = Object.keys(pieces);
            const type = keys[Math.floor(Math.random() * keys.length)];
            return {
                shape: pieces[type],
                color: colors[type],
                x: Math.floor(cols / 2) - 1,
                y: 0,
                type: type
            };
        }

        function drawBoard() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(0,212,255,0.1)';
            for (let i = 0; i <= cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= rows; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvas.width, i * tileSize);
                ctx.stroke();
            }

            board.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) {
                        ctx.fillStyle = cell;
                        ctx.fillRect(x * tileSize + 1, y * tileSize + 1, tileSize - 2, tileSize - 2);
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.strokeRect(x * tileSize + 1, y * tileSize + 1, tileSize - 2, tileSize - 2);
                    }
                });
            });

            if (current) {
                // Draw ghost piece
                const ghostY = getGhostY();
                ctx.globalAlpha = 0.3;
                current.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            ctx.fillStyle = current.color;
                            ctx.fillRect((current.x + dx) * tileSize + 1, (ghostY + dy) * tileSize + 1, tileSize - 2, tileSize - 2);
                        }
                    });
                });
                ctx.globalAlpha = 1;

                // Draw current piece
                current.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            ctx.fillStyle = current.color;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = current.color;
                            ctx.fillRect((current.x + dx) * tileSize + 1, (current.y + dy) * tileSize + 1, tileSize - 2, tileSize - 2);
                            ctx.shadowBlur = 0;
                        }
                    });
                });
            }
        }

        function drawNext() {
            nextCtx.fillStyle = 'rgba(0,0,0,0.9)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            if (next) {
                const offsetX = (nextCanvas.width - next.shape[0].length * 20) / 2;
                const offsetY = (nextCanvas.height - next.shape.length * 20) / 2;
                next.shape.forEach((row, dy) => {
                    row.forEach((cell, dx) => {
                        if (cell) {
                            nextCtx.fillStyle = next.color;
                            nextCtx.fillRect(offsetX + dx * 20, offsetY + dy * 20, 18, 18);
                        }
                    });
                });
            }
        }

        function collides(piece, x, y) {
            return piece.shape.some((row, dy) => {
                return row.some((cell, dx) => {
                    if (!cell) return false;
                    const newX = x + dx;
                    const newY = y + dy;
                    return newX < 0 || newX >= cols || newY >= rows || (newY >= 0 && board[newY][newX]);
                });
            });
        }

        function getGhostY() {
            let ghostY = current.y;
            while (!collides(current, current.x, ghostY + 1)) {
                ghostY++;
            }
            return ghostY;
        }

        function merge() {
            current.shape.forEach((row, dy) => {
                row.forEach((cell, dx) => {
                    if (cell) {
                        board[current.y + dy][current.x + dx] = current.color;
                    }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = rows - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(cols).fill(0));
                    linesCleared++;
                    y++;
                }
            }
            if (linesCleared > 0) {
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                dropSpeed = Math.max(100, 500 - (level - 1) * 50);
                updateStats();
            }
            return linesCleared;
        }

        function rotate() {
            const rotated = current.shape[0].map((_, i) => current.shape.map(row => row[i]).reverse());
            if (!collides({...current, shape: rotated}, current.x, current.y)) {
                current.shape = rotated;
            }
        }

        function move(dx) {
            if (!collides(current, current.x + dx, current.y)) {
                current.x += dx;
            }
        }

        function drop() {
            if (!collides(current, current.x, current.y + 1)) {
                current.y++;
            } else {
                merge();
                clearLines();
                current = next;
                next = getRandomPiece();
                if (collides(current, current.x, current.y)) {
                    gameOver();
                }
                drawNext();
            }
        }

        function hardDrop() {
            while (!collides(current, current.x, current.y + 1)) {
                current.y++;
                score += 2;
            }
            drop();
        }

        function updateGame() {
            if (!isPaused) {
                drop();
                drawBoard();
                if (gameMode === 'sprint' && lines >= 40) {
                    alert(`Sprint Complete! Time: ${Math.floor(Date.now() / 1000)} seconds`);
                    clearInterval(gameLoop);
                }
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            alert(`Game Over! Score: ${score} | Lines: ${lines} | Level: ${level}`);
            document.getElementById('tetris-start').disabled = false;
            document.getElementById('tetris-sprint').disabled = false;
            document.getElementById('tetris-pause').disabled = true;
        }

        function updateStats() {
            document.getElementById('tetris-score').textContent = score;
            document.getElementById('tetris-lines').textContent = lines;
            document.getElementById('tetris-level').textContent = level;
        }

        document.addEventListener('keydown', (e) => {
            if (!current || isPaused) return;
            if (e.key === 'ArrowLeft') move(-1);
            else if (e.key === 'ArrowRight') move(1);
            else if (e.key === 'ArrowDown') drop();
            else if (e.key === 'ArrowUp') rotate();
            else if (e.key === ' ') { e.preventDefault(); hardDrop(); }
            drawBoard();
        });

        function startGame(mode) {
            gameMode = mode;
            board = Array(rows).fill().map(() => Array(cols).fill(0));
            score = 0; lines = 0; level = 1;
            dropSpeed = 500;
            current = getRandomPiece();
            next = getRandomPiece();
            updateStats();
            document.getElementById('tetris-mode').textContent = mode === 'marathon' ? 'Marathon' : 'Sprint';
            drawNext();
            drawBoard();
            gameLoop = setInterval(updateGame, dropSpeed);
            document.getElementById('tetris-start').disabled = true;
            document.getElementById('tetris-sprint').disabled = true;
            document.getElementById('tetris-pause').disabled = false;
        }

        document.getElementById('tetris-start').addEventListener('click', () => startGame('marathon'));
        document.getElementById('tetris-sprint').addEventListener('click', () => startGame('sprint'));
        document.getElementById('tetris-pause').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        drawBoard();
    }

    function renderPongEvolution() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="pong-player">0</div><div class="label">Player</div></div>
                    <div class="device-info-item"><div class="value" id="pong-ai">0</div><div class="label">AI</div></div>
                    <div class="device-info-item"><div class="value" id="pong-difficulty">Easy</div><div class="label">Difficulty</div></div>
                </div>
                <canvas id="pong-canvas" width="600" height="400" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: rgba(0,0,0,0.9); display: block; margin: 0 auto;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="pong-easy" class="tool-button">Easy</button>
                    <button id="pong-medium" class="tool-button tool-button-secondary">Medium</button>
                    <button id="pong-hard" class="tool-button tool-button-secondary">Hard</button>
                    <button id="pong-start" class="tool-button">Start Game</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Move mouse vertically to control paddle  First to 5 wins  Power-ups appear randomly</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('pong-canvas');
        const ctx = canvas.getContext('2d');

        let playerPaddle = {x: 20, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 5};
        let aiPaddle = {x: canvas.width - 30, y: canvas.height / 2 - 50, width: 10, height: 100, speed: 3};
        let ball = {x: canvas.width / 2, y: canvas.height / 2, dx: 4, dy: 4, radius: 8};
        let playerScore = 0, aiScore = 0;
        let difficulty = 'easy';
        let gameLoop = null;
        let powerUps = [];

        function drawGame() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = 'rgba(0,212,255,0.3)';
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw paddles
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00D4FF';
            ctx.fillStyle = '#00D4FF';
            ctx.fillRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height);
            ctx.shadowColor = '#FF00FF';
            ctx.fillStyle = '#FF00FF';
            ctx.fillRect(aiPaddle.x, aiPaddle.y, aiPaddle.width, aiPaddle.height);
            ctx.shadowBlur = 0;

            // Draw ball
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#FFD700';
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw power-ups
            powerUps.forEach(pu => {
                ctx.fillStyle = pu.type === 'expand' ? '#00FF00' : '#FF0000';
                ctx.fillRect(pu.x, pu.y, 20, 20);
            });
        }

        function updateGame() {
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Ball collision with walls
            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.dy *= -1;
            }

            // Ball collision with paddles
            if (ball.x - ball.radius < playerPaddle.x + playerPaddle.width &&
                ball.y > playerPaddle.y && ball.y < playerPaddle.y + playerPaddle.height) {
                ball.dx = Math.abs(ball.dx);
                const hitPos = (ball.y - playerPaddle.y) / playerPaddle.height;
                ball.dy = (hitPos - 0.5) * 10;
            }

            if (ball.x + ball.radius > aiPaddle.x &&
                ball.y > aiPaddle.y && ball.y < aiPaddle.y + aiPaddle.height) {
                ball.dx = -Math.abs(ball.dx);
                const hitPos = (ball.y - aiPaddle.y) / aiPaddle.height;
                ball.dy = (hitPos - 0.5) * 10;
            }

            // AI movement
            let aiSpeed = difficulty === 'easy' ? 3 : difficulty === 'medium' ? 5 : 7;
            if (ball.dx > 0) {
                if (aiPaddle.y + aiPaddle.height / 2 < ball.y) {
                    aiPaddle.y += aiSpeed;
                } else {
                    aiPaddle.y -= aiSpeed;
                }
            }
            aiPaddle.y = Math.max(0, Math.min(canvas.height - aiPaddle.height, aiPaddle.y));

            // Scoring
            if (ball.x - ball.radius < 0) {
                aiScore++;
                resetBall();
            } else if (ball.x + ball.radius > canvas.width) {
                playerScore++;
                resetBall();
            }

            // Power-ups
            if (Math.random() < 0.01) {
                powerUps.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    type: Math.random() > 0.5 ? 'expand' : 'speed'
                });
            }

            powerUps = powerUps.filter(pu => {
                if (Math.abs(ball.x - pu.x - 10) < ball.radius + 10 && Math.abs(ball.y - pu.y - 10) < ball.radius + 10) {
                    if (pu.type === 'expand') {
                        playerPaddle.height = Math.min(150, playerPaddle.height + 20);
                    } else {
                        ball.dx *= 1.2;
                        ball.dy *= 1.2;
                    }
                    return false;
                }
                return true;
            });

            updateStats();
            drawGame();

            if (playerScore >= 5 || aiScore >= 5) {
                endGame();
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
            ball.dy = (Math.random() - 0.5) * 8;
        }

        function endGame() {
            clearInterval(gameLoop);
            const winner = playerScore >= 5 ? 'Player' : 'AI';
            alert(`${winner} Wins! Final Score: ${playerScore} - ${aiScore}`);
            document.getElementById('pong-start').disabled = false;
        }

        function updateStats() {
            document.getElementById('pong-player').textContent = playerScore;
            document.getElementById('pong-ai').textContent = aiScore;
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            playerPaddle.y = e.clientY - rect.top - playerPaddle.height / 2;
            playerPaddle.y = Math.max(0, Math.min(canvas.height - playerPaddle.height, playerPaddle.y));
        });

        document.getElementById('pong-easy').addEventListener('click', () => {
            difficulty = 'easy';
            document.getElementById('pong-difficulty').textContent = 'Easy';
        });
        document.getElementById('pong-medium').addEventListener('click', () => {
            difficulty = 'medium';
            document.getElementById('pong-difficulty').textContent = 'Medium';
        });
        document.getElementById('pong-hard').addEventListener('click', () => {
            difficulty = 'hard';
            document.getElementById('pong-difficulty').textContent = 'Hard';
        });

        document.getElementById('pong-start').addEventListener('click', () => {
            playerScore = 0; aiScore = 0;
            playerPaddle.height = 100;
            powerUps = [];
            resetBall();
            updateStats();
            gameLoop = setInterval(updateGame, 1000 / 60);
            document.getElementById('pong-start').disabled = true;
        });

        drawGame();
    }

    function renderFruitSlash() {
        a.toolContent.innerHTML = `
            <div class="puzzle-container">
                <div class="device-info-grid" style="margin-bottom: var(--space-md);">
                    <div class="device-info-item"><div class="value" id="slash-score">0</div><div class="label">Score</div></div>
                    <div class="device-info-item"><div class="value" id="slash-combo">0</div><div class="label">Combo</div></div>
                    <div class="device-info-item"><div class="value" id="slash-lives">3</div><div class="label">Lives</div></div>
                    <div class="device-info-item"><div class="value" id="slash-mode">Classic</div><div class="label">Mode</div></div>
                </div>
                <canvas id="slash-canvas" width="500" height="600" style="border: 2px solid var(--color-primary); border-radius: var(--radius-md); background: linear-gradient(180deg, rgba(135,206,250,0.3), rgba(255,250,205,0.3)); display: block; margin: 0 auto; cursor: crosshair;"></canvas>
                <div class="tool-controls-grid" style="margin-top: var(--space-md);">
                    <button id="slash-classic" class="tool-button">Classic</button>
                    <button id="slash-zen" class="tool-button tool-button-secondary">Zen</button>
                    <button id="slash-arcade" class="tool-button tool-button-secondary">Arcade</button>
                    <button id="slash-start" class="tool-button">Start Game</button>
                </div>
                <div style="text-align: center; margin-top: var(--space-md); color: var(--color-text-secondary);">
                    <p>Swipe to slash fruits  Avoid bombs  Build combos  Special fruits give bonus points</p>
                </div>
            </div>
        `;

        const canvas = document.getElementById('slash-canvas');
        const ctx = canvas.getContext('2d');

        let fruits = [];
        let score = 0, combo = 0, lives = 3;
        let gameMode = 'classic';
        let gameLoop = null;
        let slashTrail = [];
        let gameTime = 0;
        let gameActive = false;
        let fruitSpawnRate = 0.03;
        let specialFruitChance = 0.1;

        const fruitTypes = [
            {type: 'apple', color: '#FF0000', points: 1, emoji: ''},
            {type: 'orange', color: '#FF8C00', points: 1, emoji: ''},
            {type: 'banana', color: '#FFD700', points: 1, emoji: ''},
            {type: 'watermelon', color: '#00FF00', points: 2, emoji: ''},
            {type: 'grape', color: '#8B00FF', points: 3, emoji: ''},
            {type: 'special', color: '#FF00FF', points: 10, emoji: ''}
        ];

        const fruitImages = {};
        
        function preloadFruitImages() {
            fruitTypes.forEach(fruit => {
                const img = new Image();
                img.src = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">${fruit.emoji}</text></svg>`;
                fruitImages[fruit.type] = img;
            });
            
            // Bomb image
            const bombImg = new Image();
            bombImg.src = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90"></text></svg>`;
            fruitImages['bomb'] = bombImg;
        }

        function spawnFruit() {
            if (!gameActive) return;
            
            // Choose fruit type
            let fruitIndex = Math.floor(Math.random() * (fruitTypes.length - 1)); // Exclude special fruit from regular selection
            
            // Chance for special fruit
            if (Math.random() < specialFruitChance) {
                fruitIndex = fruitTypes.length - 1; // Special fruit is last in array
            }
            
            const fruit = {...fruitTypes[fruitIndex]};
            fruit.x = Math.random() * (canvas.width - 60) + 30;
            fruit.y = canvas.height + 20;
            fruit.vx = (Math.random() - 0.5) * 4;
            fruit.vy = -(Math.random() * 5 + 10);
            fruit.radius = 20 + fruit.points * 5;
            fruit.rotation = 0;
            fruit.rotationSpeed = (Math.random() - 0.5) * 0.2;
            fruit.slashed = false;
            fruit.isBomb = gameMode !== 'zen' && Math.random() < 0.15;
            
            if (fruit.isBomb) {
                fruit.color = '#000000';
                fruit.points = 0;
                fruit.type = 'bomb';
            }
            
            fruits.push(fruit);
            
            // Increase spawn rate in arcade mode
            if (gameMode === 'arcade' && gameTime > 1800) { // After 30 seconds
                fruitSpawnRate = Math.min(0.08, 0.03 + (gameTime - 1800) / 30000);
            }
        }

        function drawFruit(fruit) {
            ctx.save();
            ctx.translate(fruit.x, fruit.y);
            ctx.rotate(fruit.rotation);

            // Draw fruit shadow
            ctx.shadowBlur = 10;
            ctx.shadowColor = fruit.color;
            
            // Draw fruit background
            ctx.fillStyle = fruit.color;
            ctx.beginPath();
            ctx.arc(0, 0, fruit.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw fruit image
            if (fruitImages[fruit.type]) {
                const imgSize = fruit.radius * 1.5;
                ctx.drawImage(fruitImages[fruit.type], -imgSize/2, -imgSize/2, imgSize, imgSize);
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawSlashTrail() {
            if (slashTrail.length < 2) return;

            // Create gradient for slash trail
            const gradient = ctx.createLinearGradient(
                slashTrail[0].x, slashTrail[0].y, 
                slashTrail[slashTrail.length-1].x, slashTrail[slashTrail.length-1].y
            );
            gradient.addColorStop(0, '#FFD700');
            gradient.addColorStop(0.5, '#FF00FF');
            gradient.addColorStop(1, '#00FFFF');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#FFFFFF';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(slashTrail[0].x, slashTrail[0].y);
            
            for (let i = 1; i < slashTrail.length; i++) {
                ctx.lineTo(slashTrail[i].x, slashTrail[i].y);
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function updateGame() {
            if (!gameActive) return;
            
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(135,206,250,0.2)');
            gradient.addColorStop(1, 'rgba(255,250,205,0.2)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Spawn fruits based on spawn rate
            if (Math.random() < fruitSpawnRate) spawnFruit();

            // Update and draw fruits
            fruits = fruits.filter(fruit => {
                if (fruit.slashed) {
                    // Create slashed effect and remove
                    createSlashEffect(fruit);
                    return false;
                }

                fruit.vy += 0.3; // gravity
                fruit.x += fruit.vx;
                fruit.y += fruit.vy;
                fruit.rotation += fruit.rotationSpeed;

                // Check if fruit is off screen
                if (fruit.y > canvas.height + 50) {
                    if (!fruit.isBomb && gameMode === 'classic') {
                        lives--;
                        combo = 0;
                        updateStats();
                        if (lives <= 0) endGame();
                    }
                    return false;
                }

                drawFruit(fruit);

                // Check slash collision
                if (slashTrail.length > 1) {
                    for (let i = 1; i < slashTrail.length; i++) {
                        const p1 = slashTrail[i-1];
                        const p2 = slashTrail[i];
                        
                        // Check if line segment intersects with fruit
                        if (lineCircleIntersect(p1.x, p1.y, p2.x, p2.y, fruit.x, fruit.y, fruit.radius) && !fruit.slashed) {
                            fruit.slashed = true;
                            if (fruit.isBomb) {
                                lives--;
                                combo = 0;
                                createExplosion(fruit.x, fruit.y);
                                if (lives <= 0) endGame();
                            } else {
                                score += fruit.points * (combo + 1);
                                combo++;
                                // Special fruit bonus
                                if (fruit.type === 'special') {
                                    lives = Math.min(lives + 1, 5); // Bonus life up to max 5
                                }
                            }
                            updateStats();
                            break;
                        }
                    }
                }

                return true;
            });

            drawSlashTrail();

            // Fade slash trail
            if (slashTrail.length > 0 && Date.now() - slashTrail[slashTrail.length - 1].time > 100) {
                slashTrail = [];
                if (combo > 0) combo = Math.max(0, combo - 1);
            }

            // Arcade mode timer
            if (gameMode === 'arcade') {
                gameTime++;
                const timeLeft = Math.max(0, 120 - Math.floor(gameTime / 60));
                document.getElementById('slash-mode').textContent = `Arcade (${timeLeft}s)`;
                
                if (gameTime >= 120 * 60) {
                    endGame();
                }
            }
        }
        
        function lineCircleIntersect(x1, y1, x2, y2, cx, cy, r) {
            // Calculate the closest point on the line segment to the circle center
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            
            // Normalize direction vector
            const nx = dx / len;
            const ny = dy / len;
            
            // Vector from line start to circle center
            const vx = cx - x1;
            const vy = cy - y1;
            
            // Project this vector onto the line direction
            const projection = vx * nx + vy * ny;
            
            // Clamp projection to line segment
            const clampedProjection = Math.max(0, Math.min(len, projection));
            
            // Closest point on line to circle center
            const closestX = x1 + clampedProjection * nx;
            const closestY = y1 + clampedProjection * ny;
            
            // Distance from closest point to circle center
            const distance = Math.sqrt((closestX - cx)**2 + (closestY - cy)**2);
            
            return distance <= r;
        }
        
        function createSlashEffect(fruit) {
            // Create particle effect for slashed fruit
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;
                const size = Math.random() * 10 + 5;
                
                ctx.fillStyle = fruit.color;
                ctx.beginPath();
                ctx.arc(
                    fruit.x + Math.cos(angle) * 10, 
                    fruit.y + Math.sin(angle) * 10, 
                    size, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        function createExplosion(x, y) {
            // Create explosion effect for bomb
            ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, 80, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 200, 50, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, 50, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.fill();
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameLoop);
            
            // Draw game over message
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const message = gameMode === 'arcade' ?
                `Time's Up!` :
                `Game Over!`;
            
            ctx.fillText(message, canvas.width/2, canvas.height/2 - 50);
            ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2);
            ctx.fillText(`Max Combo: ${combo}`, canvas.width/2, canvas.height/2 + 50);
            
            document.getElementById('slash-start').disabled = false;
            document.getElementById('slash-start').textContent = 'Play Again';
        }

        function updateStats() {
            document.getElementById('slash-score').textContent = score;
            document.getElementById('slash-combo').textContent = combo;
            document.getElementById('slash-lives').textContent = gameMode === 'zen' ? '' : lives;
        }

        function startGame() {
            score = 0; 
            combo = 0; 
            lives = 3; 
            gameTime = 0;
            fruits = [];
            gameActive = true;
            fruitSpawnRate = 0.03;
            
            document.getElementById('slash-start').disabled = true;
            document.getElementById('slash-start').textContent = 'Game In Progress';
            
            updateStats();
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(updateGame, 1000 / 60); // 60 FPS
        }

        // Touch and mouse events for slashing
        let isSlashing = false;
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => { 
            if (!gameActive) return;
            isSlashing = true; 
            slashTrail = []; 
            const rect = canvas.getBoundingClientRect();
            slashTrail.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
                time: Date.now()
            });
        });
        
        canvas.addEventListener('mouseup', () => { 
            isSlashing = false; 
        });
        
        canvas.addEventListener('mouseleave', () => { 
            isSlashing = false; 
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isSlashing && gameActive) {
                const rect = canvas.getBoundingClientRect();
                slashTrail.push({
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    time: Date.now()
                });
                if (slashTrail.length > 20) slashTrail.shift();
            }
        });
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!gameActive) return;
            e.preventDefault();
            isSlashing = true;
            slashTrail = [];
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            slashTrail.push({
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top,
                time: Date.now()
            });
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isSlashing = false;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (isSlashing && gameActive) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                slashTrail.push({
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top,
                    time: Date.now()
                });
                if (slashTrail.length > 20) slashTrail.shift();
            }
        });

        // Game mode buttons
        document.getElementById('slash-classic').addEventListener('click', () => {
            gameMode = 'classic';
            document.getElementById('slash-mode').textContent = 'Classic';
            document.getElementById('slash-classic').className = 'tool-button';
            document.getElementById('slash-zen').className = 'tool-button tool-button-secondary';
            document.getElementById('slash-arcade').className = 'tool-button tool-button-secondary';
        });
        
        document.getElementById('slash-zen').addEventListener('click', () => {
            gameMode = 'zen';
            document.getElementById('slash-mode').textContent = 'Zen';
            document.getElementById('slash-classic').className = 'tool-button tool-button-secondary';
            document.getElementById('slash-zen').className = 'tool-button';
            document.getElementById('slash-arcade').className = 'tool-button tool-button-secondary';
        });
        
        document.getElementById('slash-arcade').addEventListener('click', () => {
            gameMode = 'arcade';
            document.getElementById('slash-mode').textContent = 'Arcade (120s)';
            document.getElementById('slash-classic').className = 'tool-button tool-button-secondary';
            document.getElementById('slash-zen').className = 'tool-button tool-button-secondary';
            document.getElementById('slash-arcade').className = 'tool-button';
        });

        document.getElementById('slash-start').addEventListener('click', startGame);

        // Preload images and draw initial screen
        preloadFruitImages();
        
        // Draw welcome screen
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Fruit Slash', canvas.width/2, canvas.height/2 - 50);
        ctx.font = '24px Arial';
        ctx.fillText('Click "Start Game" to play!', canvas.width/2, canvas.height/2 + 20);
        
        // Add event listener for start button
        document.getElementById('slash-start').addEventListener('click', startGame);
    }

    // --- BOARD GAMES ---

    function renderQuantumChess() {
        const html = `
            <style>
                #chess-board { display: grid; grid-template-columns: repeat(8, 1fr); gap: 0; width: min(90vw, 480px); height: min(90vw, 480px); margin: var(--space-lg) auto; background: rgba(10, 10, 26, 0.9); border: 2px solid var(--color-primary); box-shadow: var(--glow-primary), 0 0 40px rgba(0, 212, 255, 0.3); position: relative; }
                .chess-square { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.05); }
                .chess-square.light { background: rgba(0, 212, 255, 0.1); }
                .chess-square.dark { background: rgba(139, 92, 246, 0.15); }
                .chess-square.selected { box-shadow: inset 0 0 20px var(--color-primary); background: rgba(0, 212, 255, 0.3) !important; }
                .chess-square.valid-move { background: rgba(0, 255, 100, 0.2) !important; }
                .chess-square.valid-move::after { content: ''; position: absolute; width: 40%; height: 40%; border-radius: 50%; background: rgba(0, 255, 100, 0.4); }
                .chess-piece { font-size: clamp(20px, 5vw, 40px); transition: all 0.3s; filter: drop-shadow(0 0 6px currentColor); }
                .player-piece { color: var(--color-primary); }
                .ai-piece { color: var(--color-secondary); }
                .chess-piece:hover { transform: scale(1.1); }
                #chess-info { text-align: center; margin: var(--space-md) 0; }
                .ai-select { display: flex; flex-wrap: wrap; gap: var(--space-xs); justify-content: center; margin: var(--space-md) 0; }
                .ai-btn { padding: var(--space-xs) var(--space-sm); background: var(--color-glass-bg); border: 1px solid var(--color-border); color: var(--color-text-primary); cursor: pointer; border-radius: 8px; font-size: 14px; transition: all 0.2s; }
                .ai-btn:hover, .ai-btn.active { background: var(--color-primary); color: var(--color-bg-primary); box-shadow: var(--glow-primary); }
                .game-status { font-size: 18px; font-weight: 600; color: var(--color-accent); margin: var(--space-md) 0; text-align: center; }
            </style>
            <div id="chess-info">
                <div class="game-status" id="chess-status">Select AI Difficulty</div>
                <div class="ai-select">
                    <button class="ai-btn active" data-level="1">Novice</button>
                    <button class="ai-btn" data-level="2">Beginner</button>
                    <button class="ai-btn" data-level="3">*****</button>
                    <button class="ai-btn" data-level="4">Intermediate</button>
                    <button class="ai-btn" data-level="5">Advanced</button>
                    <button class="ai-btn" data-level="6">Expert</button>
                    <button class="ai-btn" data-level="7">Master</button>
                    <button class="ai-btn" data-level="8">Grandmaster</button>
                </div>
            </div>
            <div id="chess-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="chess-new-game" class="tool-button">New Game</button>
                <button id="chess-hint" class="tool-button tool-button-secondary">Hint</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const pieces = { K:'', Q:'', R:'', B:'', N:'', P:'', k:'', q:'', r:'', b:'', n:'', p:'' };
        let board = [], selectedSquare = null, validMoves = [], currentPlayer = 'white', aiLevel = 1, gameOver = false;

        function initBoard() {
            board = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            selectedSquare = null;
            validMoves = [];
            currentPlayer = 'white';
            gameOver = false;
            renderBoard();
            updateStatus();
        }

        function renderBoard() {
            const boardEl = document.getElementById('chess-board');
            boardEl.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    const piece = board[row][col];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `chess-piece ${piece === piece.toUpperCase() ? 'player-piece' : 'ai-piece'}`;
                        pieceEl.textContent = pieces[piece];
                        square.appendChild(pieceEl);
                    }
                    if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    if (validMoves.some(m => m.row === row && m.col === col)) {
                        square.classList.add('valid-move');
                    }
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardEl.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer !== 'white') return;
            const piece = board[row][col];
            if (selectedSquare) {
                const isValidMove = validMoves.some(m => m.row === row && m.col === col);
                if (isValidMove) {
                    board[row][col] = board[selectedSquare.row][selectedSquare.col];
                    board[selectedSquare.row][selectedSquare.col] = '';
                    selectedSquare = null;
                    validMoves = [];
                    if (checkWin()) return;
                    currentPlayer = 'black';
                    updateStatus();
                    renderBoard();
                    setTimeout(aiMove, 500);
                } else if (piece && piece === piece.toUpperCase()) {
                    selectedSquare = { row, col };
                    validMoves = getValidMoves(row, col);
                    renderBoard();
                } else {
                    selectedSquare = null;
                    validMoves = [];
                    renderBoard();
                }
            } else if (piece && piece === piece.toUpperCase()) {
                selectedSquare = { row, col };
                validMoves = getValidMoves(row, col);
                renderBoard();
            }
        }

        function getValidMoves(row, col) {
            const moves = [];
            const piece = board[row][col];
            if (!piece) return moves;
            const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
            if (piece.toLowerCase() === 'p') {
                const dir = piece === 'P' ? -1 : 1;
                const newRow = row + dir;
                if (newRow >= 0 && newRow < 8 && !board[newRow][col]) moves.push({row: newRow, col});
                if (col > 0 && board[newRow]?.[col-1] && isOpponent(piece, board[newRow][col-1])) moves.push({row: newRow, col: col-1});
                if (col < 7 && board[newRow]?.[col+1] && isOpponent(piece, board[newRow][col+1])) moves.push({row: newRow, col: col+1});
            } else if (piece.toLowerCase() === 'n') {
                knightMoves.forEach(([dr, dc]) => {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && (!board[nr][nc] || isOpponent(piece, board[nr][nc]))) moves.push({row: nr, col: nc});
                });
            } else if (piece.toLowerCase() === 'k') {
                dirs.forEach(([dr, dc]) => {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && (!board[nr][nc] || isOpponent(piece, board[nr][nc]))) moves.push({row: nr, col: nc});
                });
            } else {
                const isDiag = piece.toLowerCase() === 'b';
                const isLine = piece.toLowerCase() === 'r';
                const checkDirs = isDiag ? [[1,1],[1,-1],[-1,1],[-1,-1]] : isLine ? [[1,0],[-1,0],[0,1],[0,-1]] : dirs;
                checkDirs.forEach(([dr, dc]) => {
                    let nr = row + dr, nc = col + dc;
                    while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!board[nr][nc]) { moves.push({row: nr, col: nc}); }
                        else { if (isOpponent(piece, board[nr][nc])) moves.push({row: nr, col: nc}); break; }
                        nr += dr; nc += dc;
                    }
                });
            }
            return moves;
        }

        function isOpponent(p1, p2) { return (p1 === p1.toUpperCase()) !== (p2 === p2.toUpperCase()); }

        function aiMove() {
            const allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece === piece.toLowerCase()) {
                        const moves = getValidMoves(r, c);
                        moves.forEach(m => allMoves.push({ from: {row: r, col: c}, to: m, score: evaluateMove(r, c, m) }));
                    }
                }
            }
            if (allMoves.length === 0) { gameOver = true; updateStatus('White Wins!'); return; }
            allMoves.sort((a, b) => b.score - a.score);
            const topMoves = allMoves.slice(0, Math.max(1, Math.floor(allMoves.length / (10 - aiLevel))));
            const move = topMoves[Math.floor(Math.random() * topMoves.length)];
            board[move.to.row][move.to.col] = board[move.from.row][move.from.col];
            board[move.from.row][move.from.col] = '';
            currentPlayer = 'white';
            renderBoard();
            if (checkWin()) return;
            updateStatus();
        }

        function evaluateMove(fromR, fromC, to) {
            let score = Math.random() * 0.5;
            if (board[to.row][to.col]) score += 10;
            score += (7 - Math.abs(3.5 - to.row)) + (7 - Math.abs(3.5 - to.col));
            return score * (aiLevel / 2);
        }

        function checkWin() {
            let whiteKing = false, blackKing = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === 'K') whiteKing = true;
                    if (board[r][c] === 'k') blackKing = true;
                }
            }
            if (!whiteKing) { gameOver = true; updateStatus('Black Wins!'); return true; }
            if (!blackKing) { gameOver = true; updateStatus('White Wins!'); return true; }
            return false;
        }

        function updateStatus(msg) {
            document.getElementById('chess-status').textContent = msg || (currentPlayer === 'white' ? 'Your Turn (White)' : 'AI Thinking...');
        }

        document.querySelectorAll('.ai-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.ai-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                aiLevel = parseInt(btn.dataset.level);
            });
        });

        document.getElementById('chess-new-game').addEventListener('click', initBoard);
        document.getElementById('chess-hint').addEventListener('click', () => {
            if (selectedSquare && validMoves.length > 0) {
                const bestMove = validMoves[Math.floor(Math.random() * Math.min(3, validMoves.length))];
                const square = document.querySelector(`[data-row="${bestMove.row}"][data-col="${bestMove.col}"]`);
                square.style.animation = 'pulse 0.5s ease-in-out 3';
            }
        });

        initBoard();
    }

    function renderNeonCheckers() {
        const html = `
            <style>
                #checkers-board { display: grid; grid-template-columns: repeat(8, 1fr); gap: 0; width: min(90vw, 480px); height: min(90vw, 480px); margin: var(--space-lg) auto; background: #000; box-shadow: 0 0 30px var(--color-primary); }
                .checker-square { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; }
                .checker-square.cyan { background: rgba(0, 212, 255, 0.2); }
                .checker-square.magenta { background: rgba(236, 72, 153, 0.2); }
                .checker-square.playable:hover { background: rgba(0, 255, 100, 0.3) !important; }
                .checker-square.selected { box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.8); }
                .checker-square.valid-jump { background: rgba(0, 255, 100, 0.4) !important; }
                .checker-piece { width: 70%; height: 70%; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all 0.3s; position: relative; }
                .checker-piece.player { background: radial-gradient(circle at 30% 30%, rgba(0, 212, 255, 1), rgba(0, 150, 200, 1)); box-shadow: 0 0 15px var(--color-primary); }
                .checker-piece.ai { background: radial-gradient(circle at 30% 30%, rgba(236, 72, 153, 1), rgba(200, 50, 120, 1)); box-shadow: 0 0 15px var(--color-accent); }
                .checker-piece.king::after { content: ''; font-size: 24px; color: gold; position: absolute; animation: rotate 2s linear infinite; }
                @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
                .checker-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
                .checker-stats div { padding: var(--space-sm); background: var(--color-glass-bg); border-radius: 8px; }
            </style>
            <div class="checker-stats">
                <div><strong>Level:</strong> <span id="checker-level">1</span></div>
                <div><strong>Your Pieces:</strong> <span id="player-pieces">12</span></div>
                <div><strong>AI Pieces:</strong> <span id="ai-pieces">12</span></div>
            </div>
            <div id="checkers-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="checkers-new" class="tool-button">New Game</button>
                <button id="checkers-level-up" class="tool-button tool-button-secondary">Increase Difficulty</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], selected = null, validMoves = [], currentPlayer = 'player', aiLevel = 1, mustJump = null;

        function initBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 === 1) board[r][c] = { player: 'ai', king: false };
                }
            }
            for (let r = 5; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 === 1) board[r][c] = { player: 'player', king: false };
                }
            }
            selected = null;
            validMoves = [];
            currentPlayer = 'player';
            mustJump = null;
            render();
            updateStats();
        }

        function render() {
            const boardEl = document.getElementById('checkers-board');
            boardEl.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `checker-square ${(r + c) % 2 === 0 ? 'cyan' : 'magenta'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;
                    const piece = board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `checker-piece ${piece.player} ${piece.king ? 'king' : ''}`;
                        square.appendChild(pieceEl);
                    }
                    if ((r + c) % 2 === 1) square.classList.add('playable');
                    if (selected && selected.row === r && selected.col === c) square.classList.add('selected');
                    if (validMoves.some(m => m.to.row === r && m.to.col === c)) square.classList.add('valid-jump');
                    square.addEventListener('click', () => handleClick(r, c));
                    boardEl.appendChild(square);
                }
            }
        }

        function handleClick(r, c) {
            if (currentPlayer !== 'player') return;
            const piece = board[r][c];
            if (selected) {
                const move = validMoves.find(m => m.to.row === r && m.to.col === c);
                if (move) {
                    executeMove(move);
                    if (move.jump && canJumpFrom(r, c, 'player').length > 0) {
                        selected = { row: r, col: c };
                        validMoves = canJumpFrom(r, c, 'player');
                        render();
                    } else {
                        selected = null;
                        validMoves = [];
                        if (checkWin()) return;
                        currentPlayer = 'ai';
                        render();
                        setTimeout(aiTurn, 500);
                    }
                } else if (piece && piece.player === 'player') {
                    selected = { row: r, col: c };
                    validMoves = getValidMoves(r, c);
                    render();
                } else {
                    selected = null;
                    validMoves = [];
                    render();
                }
            } else if (piece && piece.player === 'player') {
                selected = { row: r, col: c };
                validMoves = getValidMoves(r, c);
                render();
            }
        }

        function getValidMoves(r, c) {
            const jumps = canJumpFrom(r, c, 'player');
            if (jumps.length > 0) return jumps;
            const piece = board[r][c];
            const moves = [];
            const dirs = piece.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : [[-1,-1],[-1,1]];
            dirs.forEach(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !board[nr][nc]) {
                    moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc}, jump: false });
                }
            });
            return moves;
        }

        function canJumpFrom(r, c, player) {
            const piece = board[r][c];
            if (!piece || piece.player !== player) return [];
            const jumps = [];
            const dirs = piece.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : player === 'player' ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
            dirs.forEach(([dr, dc]) => {
                const mr = r + dr, mc = c + dc;
                const nr = r + dr * 2, nc = c + dc * 2;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && board[mr][mc] && board[mr][mc].player !== player && !board[nr][nc]) {
                    jumps.push({ from: {row: r, col: c}, to: {row: nr, col: nc}, capture: {row: mr, col: mc}, jump: true });
                }
            });
            return jumps;
        }

        function executeMove(move) {
            const piece = board[move.from.row][move.from.col];
            board[move.to.row][move.to.col] = piece;
            board[move.from.row][move.from.col] = null;
            if (move.capture) board[move.capture.row][move.capture.col] = null;
            if ((piece.player === 'player' && move.to.row === 0) || (piece.player === 'ai' && move.to.row === 7)) {
                piece.king = true;
            }
            updateStats();
        }

        function aiTurn() {
            const allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].player === 'ai') {
                        const moves = getAIMoves(r, c);
                        allMoves.push(...moves);
                    }
                }
            }
            if (allMoves.length === 0) { alert('Player Wins!'); return; }
            const jumps = allMoves.filter(m => m.jump);
            const movesToUse = jumps.length > 0 ? jumps : allMoves;
            const move = movesToUse[Math.floor(Math.random() * Math.min(movesToUse.length, aiLevel))];
            executeMove(move);
            if (move.jump && canJumpFrom(move.to.row, move.to.col, 'ai').length > 0) {
                setTimeout(() => {
                    const nextJumps = canJumpFrom(move.to.row, move.to.col, 'ai');
                    if (nextJumps.length > 0) {
                        executeMove(nextJumps[0]);
                        currentPlayer = 'player';
                        render();
                        checkWin();
                    }
                }, 300);
            } else {
                currentPlayer = 'player';
                render();
                checkWin();
            }
        }

        function getAIMoves(r, c) {
            const jumps = canJumpFrom(r, c, 'ai');
            if (jumps.length > 0) return jumps;
            const piece = board[r][c];
            const moves = [];
            const dirs = piece.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : [[1,-1],[1,1]];
            dirs.forEach(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !board[nr][nc]) {
                    moves.push({ from: {row: r, col: c}, to: {row: nr, col: nc}, jump: false });
                }
            });
            return moves;
        }

        function updateStats() {
            let playerCount = 0, aiCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]) {
                        if (board[r][c].player === 'player') playerCount++;
                        else aiCount++;
                    }
                }
            }
            document.getElementById('player-pieces').textContent = playerCount;
            document.getElementById('ai-pieces').textContent = aiCount;
        }

        function checkWin() {
            let playerCount = 0, aiCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]) {
                        if (board[r][c].player === 'player') playerCount++;
                        else aiCount++;
                    }
                }
            }
            if (playerCount === 0) { alert('AI Wins!'); return true; }
            if (aiCount === 0) { alert('Player Wins!'); return true; }
            return false;
        }

        document.getElementById('checkers-new').addEventListener('click', initBoard);
        document.getElementById('checkers-level-up').addEventListener('click', () => {
            aiLevel = Math.min(8, aiLevel + 1);
            document.getElementById('checker-level').textContent = aiLevel;
        });

        initBoard();
    }

    function renderLudoLegacy() {
        const html = `
            <style>
                #ludo-board { width: min(90vw, 500px); height: min(90vw, 500px); margin: var(--space-lg) auto; position: relative; background: radial-gradient(circle, rgba(10,10,26,0.9), rgba(30,30,46,1)); border: 2px solid var(--color-primary); box-shadow: var(--glow-primary); display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); }
                .ludo-cell { border: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 10px; position: relative; }
                .ludo-home { background: rgba(139, 92, 246, 0.3); }
                .ludo-path { background: rgba(0, 212, 255, 0.1); }
                .ludo-safe { background: rgba(0, 255, 100, 0.2); }
                .ludo-token { width: 80%; height: 80%; border-radius: 50%; box-shadow: 0 0 10px currentColor; animation: pulse 2s infinite; position: absolute; z-index: 10; cursor: pointer; }
                .ludo-token.blue { background: radial-gradient(circle at 30% 30%, #00D4FF, #0080FF); }
                .ludo-token.red { background: radial-gradient(circle at 30% 30%, #EC4899, #C00060); }
                .ludo-token.green { background: radial-gradient(circle at 30% 30%, #00FF66, #00AA44); }
                .ludo-token.yellow { background: radial-gradient(circle at 30% 30%, #FFD700, #FFA500); }
                .ludo-token.active { transform: scale(1.2); box-shadow: 0 0 15px white; }
                .ludo-token.selectable { animation: pulse-bright 1.5s infinite; }
                @keyframes pulse-bright { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
                #ludo-dice { font-size: 48px; text-align: center; margin: var(--space-md) 0; cursor: pointer; user-select: none; }
                #ludo-dice:hover { transform: scale(1.1); }
                .ludo-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; }
                .ludo-message { text-align: center; margin: var(--space-md) 0; min-height: 24px; color: var(--color-primary); font-weight: bold; }
                .ludo-base { border: 2px solid; border-radius: 8px; }
                .ludo-base.blue { border-color: #00D4FF; background: rgba(0, 212, 255, 0.2); }
                .ludo-base.red { border-color: #EC4899; background: rgba(236, 72, 153, 0.2); }
                .ludo-base.green { border-color: #00FF66; background: rgba(0, 255, 102, 0.2); }
                .ludo-base.yellow { border-color: #FFD700; background: rgba(255, 215, 0, 0.2); }
                .ludo-finish { background: rgba(255, 255, 255, 0.2); }
            </style>
            <div class="ludo-stats">
                <div style="color: #00D4FF;"><strong>Blue (You)</strong></div>
                <div><strong>Dice:</strong> <span id="ludo-dice-value">-</span></div>
                <div style="color: #EC4899;"><strong>AI Players: 3</strong></div>
            </div>
            <div class="ludo-message" id="ludo-message"></div>
            <div id="ludo-board"></div>
            <div id="ludo-dice"> Roll Dice</div>
            <div style="text-align: center;"><button id="ludo-new" class="tool-button">New Game</button></div>
        `;
        a.toolContent.innerHTML = html;

        // Game state
        let tokens = {
            blue: [-1, -1, -1, -1],  // -1 means in base, 0-56 is path position
            red: [-1, -1, -1, -1],
            green: [-1, -1, -1, -1],
            yellow: [-1, -1, -1, -1]
        };
        let currentPlayer = 'blue';
        let diceValue = 0;
        let canMove = false;
        let selectedToken = null;
        let gameOver = false;
        
        // Path definitions
        const startPositions = {
            blue: 0,
            red: 14,
            green: 28,
            yellow: 42
        };
        
        const homePositions = {
            blue: [57, 58, 59, 60],
            red: [61, 62, 63, 64],
            green: [65, 66, 67, 68],
            yellow: [69, 70, 71, 72]
        };
        
        // Board cell coordinates
        const pathCells = [
            // Main path (56 cells)
            [7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8], [7, 7],
            [6, 7], [5, 7], [4, 7], [3, 7], [2, 7], [1, 7], [0, 7],
            [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0],
            [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0],
            [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [8, 7],
            [9, 7], [10, 7], [11, 7], [12, 7], [13, 7], [14, 7], [14, 8],
            [14, 9], [14, 10], [14, 11], [14, 12], [14, 13], [14, 14], [13, 14],
            [12, 14], [11, 14], [10, 14], [9, 14], [8, 14], [7, 14], [7, 13]
        ];
        
        // Home paths
        const homePaths = {
            blue: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9]],
            red: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7]],
            green: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5]],
            yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7]]
        };
        
        // Base positions
        const basePositions = {
            blue: [[2, 2], [2, 4], [4, 2], [4, 4]],
            red: [[2, 10], [2, 12], [4, 10], [4, 12]],
            green: [[10, 2], [10, 4], [12, 2], [12, 4]],
            yellow: [[10, 10], [10, 12], [12, 10], [12, 12]]
        };
        
        // Safe cells
        const safeCells = [
            [7, 1], [7, 8], [1, 7], [8, 7], [7, 13], [13, 7], [7, 6], [6, 7]
        ];

        function initGame() {
            tokens = {
                blue: [-1, -1, -1, -1],
                red: [-1, -1, -1, -1],
                green: [-1, -1, -1, -1],
                yellow: [-1, -1, -1, -1]
            };
            currentPlayer = 'blue';
            diceValue = 0;
            canMove = false;
            selectedToken = null;
            gameOver = false;
            
            renderBoard();
            document.getElementById('ludo-message').textContent = 'Roll the dice to start!';
        }

        function renderBoard() {
            const board = document.getElementById('ludo-board');
            board.innerHTML = '';
            
            // Create the grid
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 15; col++) {
                    const index = row * 15 + col;
                    const cell = document.createElement('div');
                    cell.className = 'ludo-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Mark path cells
                    if (isPathCell(row, col)) {
                        cell.classList.add('ludo-path');
                    }
                    
                    // Mark safe cells
                    if (isSafeCell(row, col)) {
                        cell.classList.add('ludo-safe');
                    }
                    
                    // Mark base areas
                    if (isBaseArea(row, col)) {
                        const color = getBaseColor(row, col);
                        cell.classList.add('ludo-base', color);
                    }
                    
                    // Mark finish cells
                    if (isFinishCell(row, col)) {
                        cell.classList.add('ludo-finish');
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            // Place tokens
            placeTokens();
            
            // Update dice display
            document.getElementById('ludo-dice-value').textContent = diceValue || '-';
        }
        
        function isPathCell(row, col) {
            return pathCells.some(cell => cell[0] === col && cell[1] === row) || 
                   Object.values(homePaths).flat().some(cell => cell[0] === col && cell[1] === row);
        }
        
        function isSafeCell(row, col) {
            return safeCells.some(cell => cell[0] === col && cell[1] === row);
        }
        
        function isBaseArea(row, col) {
            return (row < 5 && col < 5) || // Blue base
                   (row < 5 && col > 9) || // Red base
                   (row > 9 && col < 5) || // Green base
                   (row > 9 && col > 9);   // Yellow base
        }
        
        function getBaseColor(row, col) {
            if (row < 5 && col < 5) return 'blue';
            if (row < 5 && col > 9) return 'red';
            if (row > 9 && col < 5) return 'green';
            if (row > 9 && col > 9) return 'yellow';
            return '';
        }
        
        function isFinishCell(row, col) {
            return (col === 7 && row === 7);
        }
        
        function placeTokens() {
            // Clear existing tokens
            const existingTokens = document.querySelectorAll('.ludo-token');
            existingTokens.forEach(token => token.remove());
            
            // Place tokens for each player
            ['blue', 'red', 'green', 'yellow'].forEach(color => {
                tokens[color].forEach((position, tokenIndex) => {
                    const token = document.createElement('div');
                    token.className = `ludo-token ${color}`;
                    token.dataset.color = color;
                    token.dataset.index = tokenIndex;
                    
                    // Position the token
                    if (position === -1) {
                        // Token is in base
                        const basePos = basePositions[color][tokenIndex];
                        const cell = document.querySelector(`.ludo-cell[data-row="${basePos[1]}"][data-col="${basePos[0]}"]`);
                        if (cell) cell.appendChild(token);
                    } else if (position >= 0 && position < 56) {
                        // Token is on the main path
                        const adjustedPosition = (startPositions[color] + position) % 56;
                        const cellPos = pathCells[adjustedPosition];
                        const cell = document.querySelector(`.ludo-cell[data-row="${cellPos[1]}"][data-col="${cellPos[0]}"]`);
                        if (cell) cell.appendChild(token);
                    } else {
                        // Token is in home path or finished
                        const homeIndex = position - 56;
                        if (homeIndex >= 0 && homeIndex < 5) {
                            const cellPos = homePaths[color][homeIndex];
                            const cell = document.querySelector(`.ludo-cell[data-row="${cellPos[1]}"][data-col="${cellPos[0]}"]`);
                            if (cell) cell.appendChild(token);
                        } else if (homeIndex === 5) {
                            // Token has reached the center/finish
                            const cell = document.querySelector(`.ludo-cell[data-row="7"][data-col="7"]`);
                            if (cell) cell.appendChild(token);
                        }
                    }
                    
                    // Add click event for player's tokens
                    if (color === 'blue') {
                        token.addEventListener('click', () => selectToken(tokenIndex));
                        
                        // Highlight selectable tokens
                        if (currentPlayer === 'blue' && canMove) {
                            if (isTokenMovable(color, tokenIndex, diceValue)) {
                                token.classList.add('selectable');
                            }
                        }
                    }
                });
            });
        }
        
        function isTokenMovable(color, tokenIndex, dice) {
            const position = tokens[color][tokenIndex];
            
            // Can't move if game is over
            if (gameOver) return false;
            
            // If token is in base, need a 6 to move out
            if (position === -1) {
                return dice === 6;
            }
            
            // If token is on the board
            if (position >= 0) {
                // Check if the move would exceed the finish line
                if (position + dice > 61) {
                    return false;
                }
                return true;
            }
            
            return false;
        }
        
        function selectToken(tokenIndex) {
            if (currentPlayer !== 'blue' || !canMove || gameOver) return;
            
            if (!isTokenMovable('blue', tokenIndex, diceValue)) {
                document.getElementById('ludo-message').textContent = 'This token cannot move!';
                return;
            }
            
            // Move the token
            moveToken('blue', tokenIndex, diceValue);
            
            // Reset selection state
            canMove = false;
            selectedToken = null;
            
            // Check for win
            if (checkWin('blue')) {
                document.getElementById('ludo-message').textContent = 'You Win! ';
                gameOver = true;
                return;
            }
            
            // AI's turn
            document.getElementById('ludo-message').textContent = "AI's turn...";
            setTimeout(() => {
                currentPlayer = 'red';
                aiTurn();
            }, 1000);
        }
        
        function moveToken(color, tokenIndex, steps) {
            let position = tokens[color][tokenIndex];
            
            // If token is in base and dice is 6, move to start position
            if (position === -1 && steps === 6) {
                tokens[color][tokenIndex] = 0;
                renderBoard();
                return;
            }
            
            // Move token on the path
            tokens[color][tokenIndex] = position + steps;
            
            // Check for captures (only on main path)
            if (tokens[color][tokenIndex] < 56) {
                const adjustedPosition = (startPositions[color] + tokens[color][tokenIndex]) % 56;
                
                // Check if there are opponent tokens at this position
                ['blue', 'red', 'green', 'yellow'].forEach(opponentColor => {
                    if (opponentColor !== color) {
                        tokens[opponentColor].forEach((opponentPosition, opponentIndex) => {
                            if (opponentPosition >= 0 && opponentPosition < 56) {
                                const opponentAdjustedPosition = (startPositions[opponentColor] + opponentPosition) % 56;
                                
                                // If opponent token is at the same position and not on a safe cell
                                if (opponentAdjustedPosition === adjustedPosition && !isSafeCell(pathCells[adjustedPosition][1], pathCells[adjustedPosition][0])) {
                                    // Send opponent token back to base
                                    tokens[opponentColor][opponentIndex] = -1;
                                    document.getElementById('ludo-message').textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} captured ${opponentColor}!`;
                                }
                            }
                        });
                    }
                });
            }
            
            renderBoard();
        }
        
        function checkWin(color) {
            // Check if all tokens have reached the finish (position 61)
            return tokens[color].every(position => position === 61);
        }

        function rollDice() {
            if (currentPlayer !== 'blue' || gameOver) return;
            
            diceValue = Math.floor(Math.random() * 6) + 1;
            document.getElementById('ludo-dice-value').textContent = diceValue;
            document.getElementById('ludo-message').textContent = `You rolled a ${diceValue}!`;
            
            // Check if player has any movable tokens
            const hasMovableTokens = tokens.blue.some((position, index) => isTokenMovable('blue', index, diceValue));
            
            if (hasMovableTokens) {
                canMove = true;
                renderBoard(); // Re-render to highlight movable tokens
            } else {
                document.getElementById('ludo-message').textContent = 'No moves available!';
                setTimeout(() => {
                    currentPlayer = 'red';
                    aiTurn();
                }, 1500);
            }
        }

        function aiTurn() {
            if (gameOver) return;
            
            const aiColors = ['red', 'green', 'yellow'];
            
            function playAI(colorIndex) {
                if (colorIndex >= aiColors.length) {
                    // All AI players have played, back to player
                    currentPlayer = 'blue';
                    document.getElementById('ludo-message').textContent = 'Your turn! Roll the dice.';
                    return;
                }
                
                const color = aiColors[colorIndex];
                diceValue = Math.floor(Math.random() * 6) + 1;
                document.getElementById('ludo-dice-value').textContent = diceValue;
                document.getElementById('ludo-message').textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} rolled a ${diceValue}!`;
                
                setTimeout(() => {
                    // Find a movable token
                    const movableTokens = tokens[color].map((position, index) => ({position, index}))
                                                      .filter(({position, index}) => isTokenMovable(color, index, diceValue));
                    
                    if (movableTokens.length > 0) {
                        // Choose a random movable token
                        const {index} = movableTokens[Math.floor(Math.random() * movableTokens.length)];
                        moveToken(color, index, diceValue);
                        
                        // Check for win
                        if (checkWin(color)) {
                            document.getElementById('ludo-message').textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} Wins!`;
                            gameOver = true;
                            return;
                        }
                    }
                    
                    // Move to next AI player
                    setTimeout(() => playAI(colorIndex + 1), 1000);
                }, 1000);
            }
            
            // Start AI turns
            playAI(0);
        }

        document.getElementById('ludo-dice').addEventListener('click', rollDice);
        document.getElementById('ludo-new').addEventListener('click', initGame);
        
        initGame();
        initGame();
    }

    function renderBackgammonMasters() {
        const html = `
            <style>
                #backgammon-board { width: min(90vw, 600px); height: min(60vw, 400px); margin: var(--space-lg) auto; background: linear-gradient(135deg, #2A1810, #4A2820); border: 8px solid #6B4423; box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: grid; grid-template-columns: repeat(12, 1fr); position: relative; }
                .bg-point { position: relative; display: flex; flex-direction: column; align-items: center; padding: 4px; }
                .bg-point:nth-child(odd) { background: linear-gradient(180deg, #8B4513 0%, transparent 50%); }
                .bg-point:nth-child(even) { background: linear-gradient(180deg, #DEB887 0%, transparent 50%); }
                .bg-checker { width: 32px; height: 32px; border-radius: 50%; margin: 2px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
                .bg-checker.white { background: radial-gradient(circle at 30% 30%, #FFFFFF, #CCCCCC); }
                .bg-checker.black { background: radial-gradient(circle at 30% 30%, #333333, #000000); }
                #bg-dice { text-align: center; margin: var(--space-md) 0; font-size: 24px; }
                .bg-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
            </style>
            <div class="bg-stats">
                <div><strong>You (White)</strong></div>
                <div><strong>Dice:</strong> <span id="bg-dice-value">- -</span></div>
                <div><strong>AI (Black)</strong></div>
            </div>
            <div id="backgammon-board"></div>
            <div id="bg-dice">
                <button id="bg-roll" class="tool-button">Roll Dice</button>
            </div>
            <div style="text-align: center;"><button id="bg-new" class="tool-button tool-button-secondary">New Game</button></div>
        `;
        a.toolContent.innerHTML = html;

        let board = Array(24).fill(null).map(() => []);
        let dice = [0, 0], currentPlayer = 'white';

        function initGame() {
            board = Array(24).fill(null).map(() => []);
            board[0] = ['black', 'black'];
            board[5] = ['white', 'white', 'white', 'white', 'white'];
            board[7] = ['white', 'white', 'white'];
            board[11] = ['black', 'black', 'black', 'black', 'black'];
            board[12] = ['white', 'white', 'white', 'white', 'white'];
            board[16] = ['black', 'black', 'black'];
            board[18] = ['black', 'black', 'black', 'black', 'black'];
            board[23] = ['white', 'white'];
            dice = [0, 0];
            currentPlayer = 'white';
            renderBoard();
        }

        function renderBoard() {
            const boardEl = document.getElementById('backgammon-board');
            boardEl.innerHTML = '';
            for (let i = 0; i < 24; i++) {
                const point = document.createElement('div');
                point.className = 'bg-point';
                board[i].forEach(checker => {
                    const checkerEl = document.createElement('div');
                    checkerEl.className = `bg-checker ${checker}`;
                    point.appendChild(checkerEl);
                });
                boardEl.appendChild(point);
            }
            document.getElementById('bg-dice-value').textContent = dice[0] ? `${dice[0]} ${dice[1]}` : '- -';
        }

        document.getElementById('bg-roll').addEventListener('click', () => {
            dice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
            renderBoard();
            if (currentPlayer === 'white') {
                setTimeout(() => { currentPlayer = 'black'; setTimeout(aiMove, 1000); }, 2000);
            }
        });

        function aiMove() {
            dice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
            renderBoard();
            setTimeout(() => { currentPlayer = 'white'; }, 1500);
        }

        document.getElementById('bg-new').addEventListener('click', initGame);
        initGame();
    }

    function renderReversiStrategy() {
        const html = `
            <style>
                #reversi-board { display: grid; grid-template-columns: repeat(8, 1fr); gap: 1px; width: min(90vw, 480px); height: min(90vw, 480px); margin: var(--space-lg) auto; background: rgba(255,255,255,0.1); padding: 2px; box-shadow: 0 0 20px var(--color-primary); }
                .reversi-cell { aspect-ratio: 1; background: #000; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
                .reversi-cell:hover { background: rgba(0, 212, 255, 0.1); }
                .reversi-disc { width: 85%; height: 85%; border-radius: 50%; transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
                .reversi-disc.black { background: radial-gradient(circle at 30% 30%, #333, #000); box-shadow: 0 0 10px #000; }
                .reversi-disc.white { background: radial-gradient(circle at 30% 30%, #FFF, #CCC); box-shadow: 0 0 15px var(--color-primary); }
                .reversi-disc.flip { animation: flip 0.4s ease-in-out; }
                @keyframes flip { 0%, 100% { transform: rotateY(0deg); } 50% { transform: rotateY(90deg); } }
                .reversi-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
            </style>
            <div class="reversi-stats">
                <div><strong>White (You):</strong> <span id="reversi-white">2</span></div>
                <div><strong>Black (AI):</strong> <span id="reversi-black">2</span></div>
            </div>
            <div id="reversi-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="reversi-new" class="tool-button">New Game</button>
                <button id="reversi-hint" class="tool-button tool-button-secondary">Hint</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], currentPlayer = 'white', aiLevel = 3;

        function initGame() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            board[3][3] = 'white';
            board[3][4] = 'black';
            board[4][3] = 'black';
            board[4][4] = 'white';
            currentPlayer = 'white';
            renderBoard();
            updateScore();
        }

        function renderBoard() {
            const boardEl = document.getElementById('reversi-board');
            boardEl.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'reversi-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (board[r][c]) {
                        const disc = document.createElement('div');
                        disc.className = `reversi-disc ${board[r][c]}`;
                        cell.appendChild(disc);
                    }
                    cell.addEventListener('click', () => handleClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }

        function handleClick(r, c) {
            if (currentPlayer !== 'white' || board[r][c]) return;
            const flips = getFlips(r, c, 'white');
            if (flips.length === 0) return;
            board[r][c] = 'white';
            flips.forEach(([fr, fc]) => { board[fr][fc] = 'white'; });
            renderBoard();
            updateScore();
            if (checkGameOver()) return;
            currentPlayer = 'black';
            setTimeout(aiMove, 800);
        }

        function getFlips(r, c, player) {
            if (board[r][c]) return [];
            const flips = [];
            const dirs = [[0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            dirs.forEach(([dr, dc]) => {
                const temp = [];
                let nr = r + dr, nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && board[nr][nc]) {
                    if (board[nr][nc] === player) {
                        flips.push(...temp);
                        break;
                    }
                    temp.push([nr, nc]);
                    nr += dr;
                    nc += dc;
                }
            });
            return flips;
        }

        function aiMove() {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const flips = getFlips(r, c, 'black');
                    if (flips.length > 0) moves.push({ r, c, flips });
                }
            }
            if (moves.length === 0) {
                currentPlayer = 'white';
                if (checkGameOver()) return;
                return;
            }
            moves.sort((a, b) => b.flips.length - a.flips.length);
            const move = moves[Math.floor(Math.random() * Math.min(aiLevel, moves.length))];
            board[move.r][move.c] = 'black';
            move.flips.forEach(([fr, fc]) => { board[fr][fc] = 'black'; });
            renderBoard();
            updateScore();
            currentPlayer = 'white';
            checkGameOver();
        }

        function updateScore() {
            let white = 0, black = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === 'white') white++;
                    if (board[r][c] === 'black') black++;
                }
            }
            document.getElementById('reversi-white').textContent = white;
            document.getElementById('reversi-black').textContent = black;
        }

        function checkGameOver() {
            let hasWhiteMove = false, hasBlackMove = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (getFlips(r, c, 'white').length > 0) hasWhiteMove = true;
                    if (getFlips(r, c, 'black').length > 0) hasBlackMove = true;
                }
            }
            if (!hasWhiteMove && !hasBlackMove) {
                const white = parseInt(document.getElementById('reversi-white').textContent);
                const black = parseInt(document.getElementById('reversi-black').textContent);
                setTimeout(() => alert(white > black ? 'You Win!' : white < black ? 'AI Wins!' : 'Draw!'), 100);
                return true;
            }
            return false;
        }

        document.getElementById('reversi-new').addEventListener('click', initGame);
        document.getElementById('reversi-hint').addEventListener('click', () => {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (getFlips(r, c, 'white').length > 0) {
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        cell.style.animation = 'pulse 0.5s ease-in-out 3';
                        return;
                    }
                }
            }
        });

        initGame();
    }

    function renderConnectFour() {
        const html = `
            <style>
                #c4-board { display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; width: min(90vw, 500px); margin: var(--space-lg) auto; background: rgba(0, 212, 255, 0.1); padding: var(--space-md); border: 2px solid var(--color-primary); box-shadow: var(--glow-primary); border-radius: var(--radius-lg); }
                .c4-column { display: flex; flex-direction: column-reverse; gap: 8px; cursor: pointer; }
                .c4-column:hover { opacity: 0.8; }
                .c4-cell { aspect-ratio: 1; border-radius: 50%; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; position: relative; }
                .c4-disc { width: 85%; height: 85%; border-radius: 50%; animation: drop 0.4s ease-in; }
                .c4-disc.player { background: radial-gradient(circle at 30% 30%, var(--color-primary), #0080FF); box-shadow: 0 0 15px var(--color-primary); }
                .c4-disc.ai { background: radial-gradient(circle at 30% 30%, var(--color-accent), #C00060); box-shadow: 0 0 15px var(--color-accent); }
                @keyframes drop { from { transform: translateY(-300px); } to { transform: translateY(0); } }
                .c4-stats { text-align: center; margin: var(--space-md) 0; font-size: 18px; }
            </style>
            <div class="c4-stats">
                <div><strong>Status:</strong> <span id="c4-status">Your Turn</span></div>
            </div>
            <div id="c4-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="c4-new" class="tool-button">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], currentPlayer = 'player', gameOver = false;

        function initGame() {
            board = Array(6).fill(null).map(() => Array(7).fill(null));
            currentPlayer = 'player';
            gameOver = false;
            renderBoard();
            updateStatus('Your Turn');
        }

        function renderBoard() {
            const boardEl = document.getElementById('c4-board');
            boardEl.innerHTML = '';
            for (let c = 0; c < 7; c++) {
                const column = document.createElement('div');
                column.className = 'c4-column';
                column.dataset.col = c;
                for (let r = 0; r < 6; r++) {
                    const cell = document.createElement('div');
                    cell.className = 'c4-cell';
                    if (board[r][c]) {
                        const disc = document.createElement('div');
                        disc.className = `c4-disc ${board[r][c]}`;
                        cell.appendChild(disc);
                    }
                    column.appendChild(cell);
                }
                column.addEventListener('click', () => handleColumnClick(c));
                boardEl.appendChild(column);
            }
        }

        function handleColumnClick(col) {
            if (gameOver || currentPlayer !== 'player') return;
            const row = getAvailableRow(col);
            if (row === -1) return;
            board[row][col] = 'player';
            renderBoard();
            if (checkWin(row, col, 'player')) {
                gameOver = true;
                updateStatus('You Win!');
                return;
            }
            if (isBoardFull()) {
                gameOver = true;
                updateStatus('Draw!');
                return;
            }
            currentPlayer = 'ai';
            updateStatus('AI Thinking...');
            setTimeout(aiMove, 600);
        }

        function getAvailableRow(col) {
            for (let r = 0; r < 6; r++) {
                if (!board[r][col]) return r;
            }
            return -1;
        }

        function aiMove() {
            const moves = [];
            for (let c = 0; c < 7; c++) {
                const r = getAvailableRow(c);
                if (r !== -1) {
                    let score = Math.random();
                    board[r][c] = 'ai';
                    if (checkWin(r, c, 'ai')) score += 1000;
                    board[r][c] = 'player';
                    if (checkWin(r, c, 'player')) score += 500;
                    board[r][c] = null;
                    moves.push({ col: c, row: r, score });
                }
            }
            moves.sort((a, b) => b.score - a.score);
            const move = moves[0];
            board[move.row][move.col] = 'ai';
            renderBoard();
            if (checkWin(move.row, move.col, 'ai')) {
                gameOver = true;
                updateStatus('AI Wins!');
                return;
            }
            if (isBoardFull()) {
                gameOver = true;
                updateStatus('Draw!');
                return;
            }
            currentPlayer = 'player';
            updateStatus('Your Turn');
        }

        function checkWin(row, col, player) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            return dirs.some(([dr, dc]) => {
                let count = 1;
                for (let d of [1, -1]) {
                    let r = row + dr * d, c = col + dc * d;
                    while (r >= 0 && r < 6 && c >= 0 && c < 7 && board[r][c] === player) {
                        count++;
                        r += dr * d;
                        c += dc * d;
                    }
                }
                return count >= 4;
            });
        }

        function isBoardFull() {
            return board.every(row => row.every(cell => cell !== null));
        }

        function updateStatus(msg) {
            document.getElementById('c4-status').textContent = msg;
        }

        document.getElementById('c4-new').addEventListener('click', initGame);
        initGame();
    }

    function renderGoAncient() {
        const html = `
            <style>
                #go-container { background: linear-gradient(135deg, #8B7355, #D2B48C); padding: var(--space-lg); border-radius: var(--radius-lg); max-width: 600px; margin: 0 auto; }
                #go-board { display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); gap: 0; width: min(85vw, 450px); height: min(85vw, 450px); margin: var(--space-lg) auto; background: #D2B48C; position: relative; border: 2px solid #8B7355; }
                .go-intersection { position: relative; display: flex; align-items: center; justify-content: center; cursor: pointer; border-right: 1px solid #8B7355; border-bottom: 1px solid #8B7355; }
                .go-intersection:hover::after { content: ''; width: 70%; height: 70%; border-radius: 50%; background: rgba(0,0,0,0.2); position: absolute; }
                .go-stone { width: 75%; height: 75%; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); animation: placeStone 0.3s ease-out; }
                .go-stone.black { background: radial-gradient(circle at 35% 35%, #4A4A4A, #000); }
                .go-stone.white { background: radial-gradient(circle at 35% 35%, #FFF, #E0E0E0); }
                @keyframes placeStone { from { transform: scale(0); } to { transform: scale(1); } }
                .go-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; color: #2C1810; font-weight: 600; }
            </style>
            <div id="go-container">
                <div class="go-stats">
                    <div>Black (You): <span id="go-black-captures">0</span></div>
                    <div>White (AI): <span id="go-white-captures">0</span></div>
                </div>
                <div id="go-board"></div>
                <div style="text-align: center; margin-top: var(--space-md);">
                    <button id="go-pass" class="tool-button">Pass</button>
                    <button id="go-new" class="tool-button tool-button-secondary">New Game</button>
                </div>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const size = 9;
        let board = [], currentPlayer = 'black', passCount = 0, captures = { black: 0, white: 0 };

        function initGame() {
            board = Array(size).fill(null).map(() => Array(size).fill(null));
            currentPlayer = 'black';
            passCount = 0;
            captures = { black: 0, white: 0 };
            renderBoard();
            updateCaptures();
        }

        function renderBoard() {
            const boardEl = document.getElementById('go-board');
            boardEl.innerHTML = '';
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'go-intersection';
                    intersection.dataset.row = r;
                    intersection.dataset.col = c;
                    if (board[r][c]) {
                        const stone = document.createElement('div');
                        stone.className = `go-stone ${board[r][c]}`;
                        intersection.appendChild(stone);
                    }
                    intersection.addEventListener('click', () => handleClick(r, c));
                    boardEl.appendChild(intersection);
                }
            }
        }

        function handleClick(r, c) {
            if (currentPlayer !== 'black' || board[r][c]) return;
            board[r][c] = 'black';
            removeCaptures('white');
            passCount = 0;
            renderBoard();
            updateCaptures();
            currentPlayer = 'white';
            setTimeout(aiMove, 800);
        }

        function aiMove() {
            const moves = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (!board[r][c]) moves.push({ r, c, score: Math.random() });
                }
            }
            if (moves.length === 0 || Math.random() < 0.1) {
                passCount++;
                if (passCount >= 2) {
                    alert('Game Over');
                    return;
                }
                currentPlayer = 'black';
                return;
            }
            const move = moves[Math.floor(Math.random() * Math.min(5, moves.length))];
            board[move.r][move.c] = 'white';
            removeCaptures('black');
            passCount = 0;
            renderBoard();
            updateCaptures();
            currentPlayer = 'black';
        }

        function removeCaptures(color) {
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c] === color && !hasLiberties(r, c, color, new Set())) {
                        board[r][c] = null;
                        captures[color === 'black' ? 'white' : 'black']++;
                    }
                }
            }
        }

        function hasLiberties(r, c, color, visited) {
            const key = `${r},${c}`;
            if (visited.has(key)) return false;
            visited.add(key);
            const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
            for (const [dr, dc] of dirs) {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                    if (!board[nr][nc]) return true;
                    if (board[nr][nc] === color && hasLiberties(nr, nc, color, visited)) return true;
                }
            }
            return false;
        }

        function updateCaptures() {
            document.getElementById('go-black-captures').textContent = captures.black;
            document.getElementById('go-white-captures').textContent = captures.white;
        }

        document.getElementById('go-pass').addEventListener('click', () => {
            passCount++;
            if (passCount >= 2) { alert('Game Over'); return; }
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            if (currentPlayer === 'white') setTimeout(aiMove, 800);
        });

        document.getElementById('go-new').addEventListener('click', initGame);
        initGame();
    }

    function renderScrabbleMaster() {
        const html = `
            <style>
                #scrabble-board { display: grid; grid-template-columns: repeat(15, 1fr); gap: 2px; width: min(90vw, 600px); height: min(90vw, 600px); margin: var(--space-lg) auto; background: #0A1520; padding: 4px; }
                .scrabble-cell { aspect-ratio: 1; background: #1A2530; border: 1px solid #2A3540; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #AAA; position: relative; }
                .scrabble-cell.dw { background: rgba(255, 140, 0, 0.3); }
                .scrabble-cell.tw { background: rgba(255, 0, 0, 0.3); }
                .scrabble-cell.dl { background: rgba(0, 212, 255, 0.3); }
                .scrabble-cell.tl { background: rgba(139, 92, 246, 0.3); }
                .scrabble-tile { width: 90%; height: 90%; background: linear-gradient(135deg, #F5E6D3, #E0D0B0); border: 1px solid #C0A070; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 700; color: #2C1810; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
                #scrabble-rack { display: flex; gap: var(--space-xs); justify-content: center; margin: var(--space-lg) 0; }
                .rack-tile { width: 50px; height: 50px; background: linear-gradient(135deg, #F5E6D3, #E0D0B0); border: 2px solid #C0A070; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; color: #2C1810; cursor: pointer; box-shadow: 0 3px 6px rgba(0,0,0,0.3); transition: transform 0.2s; }
                .rack-tile:hover { transform: translateY(-4px); }
                .rack-tile.selected { border: 2px solid var(--color-primary); box-shadow: 0 0 10px var(--color-primary); }
                .scrabble-stats { text-align: center; margin: var(--space-md) 0; font-size: 18px; }
                .scrabble-points { position: absolute; bottom: 2px; right: 2px; font-size: 8px; color: #AAA; }
                .scrabble-message { text-align: center; margin: var(--space-sm) 0; font-size: 16px; color: var(--color-primary); min-height: 24px; }
            </style>
            <div class="scrabble-stats">
                <div><strong>Your Score:</strong> <span id="scrabble-score">0</span> | <strong>AI Score:</strong> <span id="scrabble-ai-score">0</span></div>
            </div>
            <div class="scrabble-message" id="scrabble-message"></div>
            <div id="scrabble-board"></div>
            <div id="scrabble-rack"></div>
            <div style="text-align: center;">
                <button id="scrabble-play" class="tool-button">Play Word</button>
                <button id="scrabble-shuffle" class="tool-button tool-button-secondary">Shuffle</button>
                <button id="scrabble-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], rack = [], score = 0, aiScore = 0;
        let selectedTileIndex = -1;
        let placedTiles = [];
        const letterPoints = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
            'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
            'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };
        const letters = 'AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOPPQRRRRRRSSSSTTTTTTUUUUVVWWXYYZ'.split('');
        const aiWords = ['QUIZ', 'JAZZ', 'ZINC', 'VIBE', 'WOKE', 'FLUX', 'APEX', 'MYTH', 'LYNX', 'GLYPH', 'FJORD', 'PIXEL', 'JUMBO', 'QUACK', 'WALTZ'];

        function initGame() {
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            rack = [];
            for (let i = 0; i < 7; i++) rack.push(letters[Math.floor(Math.random() * letters.length)]);
            score = 0;
            aiScore = 0;
            selectedTileIndex = -1;
            placedTiles = [];
            renderBoard();
            renderRack();
            updateScore();
            document.getElementById('scrabble-message').textContent = '';
        }

        function renderBoard() {
            const boardEl = document.getElementById('scrabble-board');
            boardEl.innerHTML = '';
            const specials = { 
                '0,0': 'tw', '0,7': 'tw', '0,14': 'tw', 
                '7,0': 'tw', '7,14': 'tw', 
                '14,0': 'tw', '14,7': 'tw', '14,14': 'tw',
                '1,1': 'dw', '2,2': 'dw', '3,3': 'dw', '4,4': 'dw',
                '1,13': 'dw', '2,12': 'dw', '3,11': 'dw', '4,10': 'dw',
                '10,4': 'dw', '11,3': 'dw', '12,2': 'dw', '13,1': 'dw',
                '10,10': 'dw', '11,11': 'dw', '12,12': 'dw', '13,13': 'dw',
                '1,5': 'tl', '1,9': 'tl', '5,1': 'tl', '5,5': 'tl', '5,9': 'tl', '5,13': 'tl',
                '9,1': 'tl', '9,5': 'tl', '9,9': 'tl', '9,13': 'tl', '13,5': 'tl', '13,9': 'tl',
                '0,3': 'dl', '0,11': 'dl', '2,6': 'dl', '2,8': 'dl', '3,0': 'dl', '3,7': 'dl', '3,14': 'dl',
                '6,2': 'dl', '6,6': 'dl', '6,8': 'dl', '6,12': 'dl', '7,3': 'dl', '7,11': 'dl',
                '8,2': 'dl', '8,6': 'dl', '8,8': 'dl', '8,12': 'dl', '11,0': 'dl', '11,7': 'dl', '11,14': 'dl',
                '12,6': 'dl', '12,8': 'dl', '14,3': 'dl', '14,11': 'dl'
            };
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const cell = document.createElement('div');
                    cell.className = `scrabble-cell ${specials[`${r},${c}`] || ''}`;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (board[r][c]) {
                        const tile = document.createElement('div');
                        tile.className = 'scrabble-tile';
                        tile.textContent = board[r][c];
                        
                        const points = document.createElement('span');
                        points.className = 'scrabble-points';
                        points.textContent = letterPoints[board[r][c]];
                        tile.appendChild(points);
                        
                        cell.appendChild(tile);
                    } else if (specials[`${r},${c}`]) {
                        cell.textContent = specials[`${r},${c}`].toUpperCase();
                    }
                    
                    cell.addEventListener('click', () => {
                        if (selectedTileIndex !== -1 && !board[r][c]) {
                            const letter = rack[selectedTileIndex];
                            board[r][c] = letter;
                            placedTiles.push({row: r, col: c, letter: letter});
                            rack.splice(selectedTileIndex, 1);
                            selectedTileIndex = -1;
                            renderBoard();
                            renderRack();
                        }
                    });
                    
                    boardEl.appendChild(cell);
                }
            }
        }

        function renderRack() {
            const rackEl = document.getElementById('scrabble-rack');
            rackEl.innerHTML = '';
            rack.forEach((letter, index) => {
                const tile = document.createElement('div');
                tile.className = `rack-tile ${index === selectedTileIndex ? 'selected' : ''}`;
                tile.textContent = letter;
                
                const points = document.createElement('span');
                points.className = 'scrabble-points';
                points.textContent = letterPoints[letter];
                tile.appendChild(points);
                
                tile.addEventListener('click', () => {
                    selectedTileIndex = index === selectedTileIndex ? -1 : index;
                    renderRack();
                });
                
                rackEl.appendChild(tile);
            });
        }

        function updateScore() {
            document.getElementById('scrabble-score').textContent = score;
            document.getElementById('scrabble-ai-score').textContent = aiScore;
        }

        function calculateWordScore() {
            if (placedTiles.length === 0) return 0;
            
            let wordScore = 0;
            let wordMultiplier = 1;
            
            placedTiles.forEach(tile => {
                const {row, col, letter} = tile;
                let letterScore = letterPoints[letter];
                const cell = document.querySelector(`.scrabble-cell[data-row="${row}"][data-col="${col}"]`);
                
                if (cell.classList.contains('dl')) {
                    letterScore *= 2;
                } else if (cell.classList.contains('tl')) {
                    letterScore *= 3;
                }
                
                if (cell.classList.contains('dw')) {
                    wordMultiplier *= 2;
                } else if (cell.classList.contains('tw')) {
                    wordMultiplier *= 3;
                }
                
                wordScore += letterScore;
            });
            
            return wordScore * wordMultiplier;
        }

        function aiPlayWord() {
            const aiWord = aiWords[Math.floor(Math.random() * aiWords.length)];
            const row = 7;
            let col = Math.floor(Math.random() * (15 - aiWord.length));
            
            // Check if the word can be placed
            let canPlace = true;
            for (let i = 0; i < aiWord.length; i++) {
                if (board[row][col + i] !== null) {
                    canPlace = false;
                    break;
                }
            }
            
            if (canPlace) {
                let wordScore = 0;
                let wordMultiplier = 1;
                const specials = { 
                    '0,0': 'tw', '0,7': 'tw', '0,14': 'tw', 
                    '7,0': 'tw', '7,14': 'tw', 
                    '14,0': 'tw', '14,7': 'tw', '14,14': 'tw',
                    '1,1': 'dw', '2,2': 'dw', '3,3': 'dw', '4,4': 'dw',
                    '1,13': 'dw', '2,12': 'dw', '3,11': 'dw', '4,10': 'dw',
                    '10,4': 'dw', '11,3': 'dw', '12,2': 'dw', '13,1': 'dw',
                    '10,10': 'dw', '11,11': 'dw', '12,12': 'dw', '13,13': 'dw'
                };
                
                for (let i = 0; i < aiWord.length; i++) {
                    const letter = aiWord[i];
                    board[row][col + i] = letter;
                    
                    let letterScore = letterPoints[letter];
                    if (specials[`${row},${col + i}`] === 'dl') letterScore *= 2;
                    if (specials[`${row},${col + i}`] === 'tl') letterScore *= 3;
                    if (specials[`${row},${col + i}`] === 'dw') wordMultiplier *= 2;
                    if (specials[`${row},${col + i}`] === 'tw') wordMultiplier *= 3;
                    
                    wordScore += letterScore;
                }
                
                aiScore += wordScore * wordMultiplier;
                document.getElementById('scrabble-message').textContent = `AI played "${aiWord}" for ${wordScore * wordMultiplier} points!`;
            } else {
                // If can't place horizontally, try vertically
                const col = 7;
                let row = Math.floor(Math.random() * (15 - aiWord.length));
                
                let canPlaceVertical = true;
                for (let i = 0; i < aiWord.length; i++) {
                    if (board[row + i][col] !== null) {
                        canPlaceVertical = false;
                        break;
                    }
                }
                
                if (canPlaceVertical) {
                    let wordScore = 0;
                    let wordMultiplier = 1;
                    
                    for (let i = 0; i < aiWord.length; i++) {
                        const letter = aiWord[i];
                        board[row + i][col] = letter;
                        
                        let letterScore = letterPoints[letter];
                        const specials = { 
                            '0,0': 'tw', '0,7': 'tw', '0,14': 'tw', 
                            '7,0': 'tw', '7,14': 'tw', 
                            '14,0': 'tw', '14,7': 'tw', '14,14': 'tw',
                            '1,1': 'dw', '2,2': 'dw', '3,3': 'dw', '4,4': 'dw',
                            '1,13': 'dw', '2,12': 'dw', '3,11': 'dw', '4,10': 'dw',
                            '10,4': 'dw', '11,3': 'dw', '12,2': 'dw', '13,1': 'dw',
                            '10,10': 'dw', '11,11': 'dw', '12,12': 'dw', '13,13': 'dw'
                        };
                        
                        if (specials[`${row + i},${col}`] === 'dl') letterScore *= 2;
                        if (specials[`${row + i},${col}`] === 'tl') letterScore *= 3;
                        if (specials[`${row + i},${col}`] === 'dw') wordMultiplier *= 2;
                        if (specials[`${row + i},${col}`] === 'tw') wordMultiplier *= 3;
                        
                        wordScore += letterScore;
                    }
                    
                    aiScore += wordScore * wordMultiplier;
                    document.getElementById('scrabble-message').textContent = `AI played "${aiWord}" for ${wordScore * wordMultiplier} points!`;
                } else {
                    // If can't place anywhere, just add random points
                    const randomScore = Math.floor(Math.random() * 15) + 10;
                    aiScore += randomScore;
                    document.getElementById('scrabble-message').textContent = `AI played a word for ${randomScore} points!`;
                }
            }
            
            renderBoard();
            updateScore();
        }

        document.getElementById('scrabble-play').addEventListener('click', () => {
            if (placedTiles.length === 0) {
                document.getElementById('scrabble-message').textContent = 'Place some tiles on the board first!';
                return;
            }
            
            const wordScore = calculateWordScore();
            score += wordScore;
            document.getElementById('scrabble-message').textContent = `You scored ${wordScore} points!`;
            
            // Refill rack
            while (rack.length < 7 && letters.length > 0) {
                rack.push(letters[Math.floor(Math.random() * letters.length)]);
            }
            
            placedTiles = [];
            renderRack();
            updateScore();
            
            // AI's turn
            setTimeout(aiPlayWord, 1000);
        });

        document.getElementById('scrabble-shuffle').addEventListener('click', () => {
            rack.sort(() => Math.random() - 0.5);
            selectedTileIndex = -1;
            renderRack();
        });

        document.getElementById('scrabble-new').addEventListener('click', initGame);
        initGame();
    }

    function renderMahjongDeluxe() {
        const html = `
            <style>
                #mahjong-container { perspective: 1000px; max-width: 800px; margin: 0 auto; }
                #mahjong-board { display: grid; grid-template-columns: repeat(14, 1fr); gap: 4px; margin: var(--space-lg) auto; padding: var(--space-md); background: radial-gradient(circle, rgba(139, 92, 246, 0.1), rgba(10, 10, 26, 0.9)); border-radius: var(--radius-lg); }
                .mahjong-tile { aspect-ratio: 3/4; background: linear-gradient(135deg, #F5F5DC, #E8E8D0); border: 2px solid #8B7355; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: clamp(16px, 3vw, 24px); cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transform-style: preserve-3d; }
                .mahjong-tile:hover { transform: translateY(-8px) rotateX(10deg); box-shadow: 0 8px 16px rgba(0,0,0,0.4); }
                .mahjong-tile.selected { border-color: var(--color-primary); box-shadow: 0 0 20px var(--color-primary); transform: translateY(-8px) scale(1.05); }
                .mahjong-tile.matched { opacity: 0; pointer-events: none; transition: opacity 0.5s; }
                .mahjong-stats { text-align: center; margin: var(--space-md) 0; font-size: 18px; }
            </style>
            <div id="mahjong-container">
                <div class="mahjong-stats">
                    <div><strong>Matches:</strong> <span id="mahjong-matches">0</span> | <strong>Remaining:</strong> <span id="mahjong-remaining">72</span></div>
                </div>
                <div id="mahjong-board"></div>
                <div style="text-align: center; margin-top: var(--space-md);">
                    <button id="mahjong-hint" class="tool-button">Hint</button>
                    <button id="mahjong-shuffle" class="tool-button tool-button-secondary">Shuffle</button>
                    <button id="mahjong-new" class="tool-button tool-button-secondary">New Layout</button>
                </div>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let tiles = [], selected = null, matches = 0;
        const symbols = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];

        function initGame() {
            tiles = [];
            const layout = Array(72).fill(null).map((_, i) => symbols[Math.floor(i / 2) % symbols.length]);
            layout.sort(() => Math.random() - 0.5);
            for (let i = 0; i < 72; i++) {
                tiles.push({ symbol: layout[i], matched: false, index: i });
            }
            selected = null;
            matches = 0;
            renderBoard();
            updateStats();
        }

        function renderBoard() {
            const boardEl = document.getElementById('mahjong-board');
            boardEl.innerHTML = '';
            tiles.forEach((tile, i) => {
                if (tile.matched) return;
                const tileEl = document.createElement('div');
                tileEl.className = 'mahjong-tile';
                tileEl.textContent = tile.symbol;
                tileEl.dataset.index = i;
                if (selected === i) tileEl.classList.add('selected');
                tileEl.addEventListener('click', () => handleClick(i));
                boardEl.appendChild(tileEl);
            });
        }

        function handleClick(index) {
            if (tiles[index].matched) return;
            if (selected === null) {
                selected = index;
                renderBoard();
            } else if (selected === index) {
                selected = null;
                renderBoard();
            } else {
                if (tiles[selected].symbol === tiles[index].symbol) {
                    tiles[selected].matched = true;
                    tiles[index].matched = true;
                    matches++;
                    selected = null;
                    renderBoard();
                    updateStats();
                    if (matches === 36) {
                        setTimeout(() => alert('You Win!'), 500);
                    }
                } else {
                    selected = index;
                    renderBoard();
                }
            }
        }

        function updateStats() {
            document.getElementById('mahjong-matches').textContent = matches;
            document.getElementById('mahjong-remaining').textContent = 72 - (matches * 2);
        }

        document.getElementById('mahjong-hint').addEventListener('click', () => {
            for (let i = 0; i < tiles.length; i++) {
                if (tiles[i].matched) continue;
                for (let j = i + 1; j < tiles.length; j++) {
                    if (!tiles[j].matched && tiles[i].symbol === tiles[j].symbol) {
                        const tile1 = document.querySelector(`[data-index="${i}"]`);
                        const tile2 = document.querySelector(`[data-index="${j}"]`);
                        if (tile1 && tile2) {
                            tile1.style.animation = 'pulse 0.5s ease-in-out 3';
                            tile2.style.animation = 'pulse 0.5s ease-in-out 3';
                        }
                        return;
                    }
                }
            }
        });

        document.getElementById('mahjong-shuffle').addEventListener('click', () => {
            const unmatched = tiles.filter(t => !t.matched).map(t => t.symbol);
            unmatched.sort(() => Math.random() - 0.5);
            let idx = 0;
            tiles.forEach(t => { if (!t.matched) { t.symbol = unmatched[idx++]; } });
            selected = null;
            renderBoard();
        });

        document.getElementById('mahjong-new').addEventListener('click', initGame);
        initGame();
    }

    function renderBattleshipCommand() {
        const html = `
            <style>
                .battleship-grids { display: flex; gap: var(--space-lg); justify-content: center; flex-wrap: wrap; margin: var(--space-lg) 0; }
                .battleship-grid-container { text-align: center; }
                .battleship-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; width: min(45vw, 300px); height: min(45vw, 300px); background: rgba(0, 100, 200, 0.1); padding: 4px; border: 2px solid var(--color-primary); box-shadow: var(--glow-primary); }
                .battleship-cell { aspect-ratio: 1; background: rgba(0, 50, 100, 0.5); border: 1px solid rgba(0, 212, 255, 0.3); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: all 0.2s; }
                .battleship-cell:hover { background: rgba(0, 212, 255, 0.3); }
                .battleship-cell.ship { background: rgba(100, 100, 100, 0.5); }
                .battleship-cell.hit { background: radial-gradient(circle, rgba(255, 69, 0, 0.8), rgba(255, 140, 0, 0.4)); animation: explosion 0.5s ease-out; }
                .battleship-cell.hit::after { content: ''; }
                .battleship-cell.miss { background: rgba(100, 150, 200, 0.3); }
                .battleship-cell.miss::after { content: ''; }
                @keyframes explosion { from { transform: scale(0); } 50% { transform: scale(1.3); } to { transform: scale(1); } }
                .battleship-stats { text-align: center; margin: var(--space-md) 0; font-size: 16px; }
            </style>
            <div class="battleship-stats">
                <div><strong>Status:</strong> <span id="battleship-status">Place your ships!</span></div>
            </div>
            <div class="battleship-grids">
                <div class="battleship-grid-container">
                    <h3>Your Fleet</h3>
                    <div id="battleship-player-grid" class="battleship-grid"></div>
                </div>
                <div class="battleship-grid-container">
                    <h3>Enemy Waters</h3>
                    <div id="battleship-enemy-grid" class="battleship-grid"></div>
                </div>
            </div>
            <div style="text-align: center;">
                <button id="battleship-auto-place" class="tool-button">Auto-Place Ships</button>
                <button id="battleship-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let playerBoard = [], enemyBoard = [], playerShips = [], enemyShips = [], gameStarted = false, currentPlayer = 'player';

        function initGame() {
            playerBoard = Array(10).fill(null).map(() => Array(10).fill(null));
            enemyBoard = Array(10).fill(null).map(() => Array(10).fill(null));
            playerShips = [];
            enemyShips = [];
            gameStarted = false;
            currentPlayer = 'player';
            renderGrids();
            updateStatus('Place your ships!');
        }

        function renderGrids() {
            renderGrid('battleship-player-grid', playerBoard, true);
            renderGrid('battleship-enemy-grid', enemyBoard, false);
        }

        function renderGrid(id, board, showShips) {
            const gridEl = document.getElementById(id);
            gridEl.innerHTML = '';
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'battleship-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    const state = board[r][c];
                    if (state === 'ship' && showShips) cell.classList.add('ship');
                    if (state === 'hit') cell.classList.add('hit');
                    if (state === 'miss') cell.classList.add('miss');
                    if (id === 'battleship-enemy-grid' && gameStarted) {
                        cell.addEventListener('click', () => handleAttack(r, c));
                    }
                    gridEl.appendChild(cell);
                }
            }
        }

        function placeShipsRandomly(board, ships) {
            const sizes = [5, 4, 3, 3, 2];
            sizes.forEach(size => {
                let placed = false;
                while (!placed) {
                    const horizontal = Math.random() < 0.5;
                    const r = Math.floor(Math.random() * 10);
                    const c = Math.floor(Math.random() * 10);
                    if (canPlaceShip(board, r, c, size, horizontal)) {
                        for (let i = 0; i < size; i++) {
                            const nr = horizontal ? r : r + i;
                            const nc = horizontal ? c + i : c;
                            board[nr][nc] = 'ship';
                        }
                        ships.push({ size, hits: 0 });
                        placed = true;
                    }
                }
            });
        }

        function canPlaceShip(board, r, c, size, horizontal) {
            for (let i = 0; i < size; i++) {
                const nr = horizontal ? r : r + i;
                const nc = horizontal ? c + i : c;
                if (nr >= 10 || nc >= 10 || board[nr][nc]) return false;
            }
            return true;
        }

        function handleAttack(r, c) {
            if (currentPlayer !== 'player' || !gameStarted) return;
            if (enemyBoard[r][c] === 'hit' || enemyBoard[r][c] === 'miss') return;
            if (enemyBoard[r][c] === 'ship') {
                enemyBoard[r][c] = 'hit';
                updateStatus('Hit! ');
                if (checkWin(enemyShips, enemyBoard)) {
                    updateStatus('You Win! ');
                    gameStarted = false;
                    return;
                }
            } else {
                enemyBoard[r][c] = 'miss';
                updateStatus('Miss!');
            }
            renderGrids();
            currentPlayer = 'ai';
            setTimeout(aiAttack, 1000);
        }

        function aiAttack() {
            let r, c;
            do {
                r = Math.floor(Math.random() * 10);
                c = Math.floor(Math.random() * 10);
            } while (playerBoard[r][c] === 'hit' || playerBoard[r][c] === 'miss');
            if (playerBoard[r][c] === 'ship') {
                playerBoard[r][c] = 'hit';
                updateStatus('Enemy Hit! ');
                if (checkWin(playerShips, playerBoard)) {
                    updateStatus('AI Wins!');
                    gameStarted = false;
                    renderGrids();
                    return;
                }
            } else {
                playerBoard[r][c] = 'miss';
                updateStatus('Enemy Miss!');
            }
            renderGrids();
            currentPlayer = 'player';
        }

        function checkWin(ships, board) {
            let totalHits = 0;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    if (board[r][c] === 'hit') totalHits++;
                }
            }
            return totalHits === ships.reduce((sum, s) => sum + s.size, 0);
        }

        function updateStatus(msg) {
            document.getElementById('battleship-status').textContent = msg;
        }

        document.getElementById('battleship-auto-place').addEventListener('click', () => {
            playerBoard = Array(10).fill(null).map(() => Array(10).fill(null));
            enemyBoard = Array(10).fill(null).map(() => Array(10).fill(null));
            playerShips = [];
            enemyShips = [];
            placeShipsRandomly(playerBoard, playerShips);
            placeShipsRandomly(enemyBoard, enemyShips);
            gameStarted = true;
            renderGrids();
            updateStatus('Game Started! Attack enemy waters.');
        });

        document.getElementById('battleship-new').addEventListener('click', initGame);
        initGame();
    }

    function renderCatanUniverse() {
        const html = `
            <style>
                #catan-board { width: min(90vw, 500px); height: min(90vw, 500px); margin: var(--space-lg) auto; position: relative; background: radial-gradient(circle, #2A5A3A 0%, #1A3A2A 100%); border-radius: 50%; box-shadow: 0 0 30px rgba(0, 212, 255, 0.3); display: flex; align-items: center; justify-content: center; overflow: hidden; }
                .catan-hex { position: absolute; width: 80px; height: 92px; background: linear-gradient(135deg, #6B8E23 0%, #556B2F 100%); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #FFF; text-shadow: 0 2px 4px rgba(0,0,0,0.5); transition: all 0.3s; cursor: pointer; }
                .catan-hex:hover { transform: scale(1.1); box-shadow: 0 0 20px var(--color-primary); }
                .catan-hex.forest { background: linear-gradient(135deg, #228B22 0%, #006400 100%); }
                .catan-hex.hills { background: linear-gradient(135deg, #D2691E 0%, #8B4513 100%); }
                .catan-hex.wheat { background: linear-gradient(135deg, #FFD700 0%, #DAA520 100%); }
                .catan-hex.mountain { background: linear-gradient(135deg, #708090 0%, #2F4F4F 100%); }
                .catan-hex.pasture { background: linear-gradient(135deg, #9ACD32 0%, #6B8E23 100%); }
                .catan-settlement { position: absolute; width: 20px; height: 20px; background: var(--color-primary); border: 2px solid #FFF; border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
                #catan-dice { text-align: center; margin: var(--space-md) 0; font-size: 32px; }
                .catan-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
                .catan-resource { padding: var(--space-xs); background: var(--color-glass-bg); border-radius: 8px; font-size: 14px; }
            </style>
            <div class="catan-stats">
                <div class="catan-resource"> Wood: <span id="catan-wood">0</span></div>
                <div class="catan-resource"> Brick: <span id="catan-brick">0</span></div>
                <div class="catan-resource"> Wheat: <span id="catan-wheat">0</span></div>
                <div class="catan-resource"> Sheep: <span id="catan-sheep">0</span></div>
                <div class="catan-resource"> Ore: <span id="catan-ore">0</span></div>
            </div>
            <div id="catan-board"></div>
            <div id="catan-dice"> Roll Dice</div>
            <div style="text-align: center;">
                <button id="catan-new" class="tool-button">New Game</button>
                <button id="catan-build" class="tool-button tool-button-secondary">Build Settlement</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const resources = { wood: 0, brick: 0, wheat: 0, sheep: 0, ore: 0 };
        const hexTypes = ['forest', 'hills', 'wheat', 'mountain', 'pasture'];
        const resourceMap = { forest: 'wood', hills: 'brick', wheat: 'wheat', mountain: 'ore', pasture: 'sheep' };

        function initGame() {
            Object.keys(resources).forEach(r => resources[r] = 0);
            renderBoard();
            updateResources();
        }

        function renderBoard() {
            const board = document.getElementById('catan-board');
            board.innerHTML = '';
            const positions = [
                {x: 50, y: 30}, {x: 100, y: 60}, {x: 150, y: 30},
                {x: 75, y: 90}, {x: 125, y: 90}, {x: 50, y: 150},
                {x: 100, y: 120}, {x: 150, y: 150}
            ];
            positions.forEach((pos, i) => {
                const hex = document.createElement('div');
                const type = hexTypes[Math.floor(Math.random() * hexTypes.length)];
                const number = Math.floor(Math.random() * 6) + 2;
                hex.className = `catan-hex ${type}`;
                hex.textContent = number;
                hex.style.left = pos.x + 'px';
                hex.style.top = pos.y + 'px';
                hex.dataset.type = type;
                hex.dataset.number = number;
                board.appendChild(hex);
            });
        }

        function rollDice() {
            const dice1 = Math.floor(Math.random() * 6) + 1;
            const dice2 = Math.floor(Math.random() * 6) + 1;
            const total = dice1 + dice2;
            document.getElementById('catan-dice').textContent = ` ${dice1} + ${dice2} = ${total}`;

            document.querySelectorAll('.catan-hex').forEach(hex => {
                if (parseInt(hex.dataset.number) === total) {
                    hex.style.animation = 'pulse 0.5s ease-in-out 2';
                    const resource = resourceMap[hex.dataset.type];
                    if (resource) resources[resource]++;
                }
            });
            updateResources();
        }

        function updateResources() {
            document.getElementById('catan-wood').textContent = resources.wood;
            document.getElementById('catan-brick').textContent = resources.brick;
            document.getElementById('catan-wheat').textContent = resources.wheat;
            document.getElementById('catan-sheep').textContent = resources.sheep;
            document.getElementById('catan-ore').textContent = resources.ore;
        }

        document.getElementById('catan-dice').addEventListener('click', rollDice);
        document.getElementById('catan-new').addEventListener('click', initGame);
        document.getElementById('catan-build').addEventListener('click', () => {
            if (resources.wood >= 1 && resources.brick >= 1 && resources.wheat >= 1 && resources.sheep >= 1) {
                resources.wood--; resources.brick--; resources.wheat--; resources.sheep--;
                updateResources();
                alert('Settlement Built! ');
            } else {
                alert('Not enough resources!');
            }
        });

        initGame();
    }

    function renderTicketToRide() {
        const html = `
            <style>
                #ttr-map { width: min(90vw, 600px); height: min(60vw, 400px); margin: var(--space-lg) auto; background: linear-gradient(135deg, #F5E6D3 0%, #E8D4B8 100%); border: 4px solid #8B4513; box-shadow: 0 0 20px rgba(0,0,0,0.3); position: relative; overflow: hidden; border-radius: var(--radius-lg); }
                .ttr-city { position: absolute; width: 30px; height: 30px; background: radial-gradient(circle, var(--color-primary), var(--color-secondary)); border-radius: 50%; border: 2px solid #FFF; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #FFF; cursor: pointer; transition: all 0.3s; }
                .ttr-city:hover { transform: scale(1.2); box-shadow: 0 0 15px var(--color-primary); }
                .ttr-route { position: absolute; height: 8px; background: var(--color-accent); transform-origin: left center; cursor: pointer; transition: all 0.3s; border-radius: 4px; }
                .ttr-route:hover { background: var(--color-primary); height: 12px; }
                .ttr-route.claimed { background: rgba(0, 255, 100, 0.6); }
                .ttr-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
                .ttr-card { padding: var(--space-xs); background: var(--color-glass-bg); border-radius: 8px; min-width: 80px; }
            </style>
            <div class="ttr-stats">
                <div class="ttr-card"> Trains: <span id="ttr-trains">45</span></div>
                <div class="ttr-card"> Cards: <span id="ttr-cards">4</span></div>
                <div class="ttr-card"> Score: <span id="ttr-score">0</span></div>
            </div>
            <div id="ttr-map"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="ttr-draw" class="tool-button">Draw Card</button>
                <button id="ttr-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let trains = 45, cards = 4, score = 0, routes = [];

        function initGame() {
            trains = 45; cards = 4; score = 0; routes = [];
            renderMap();
            updateStats();
        }

        function renderMap() {
            const map = document.getElementById('ttr-map');
            map.innerHTML = '';
            const cities = [
                {name: 'NY', x: 85, y: 30}, {name: 'LA', x: 15, y: 60},
                {name: 'SF', x: 5, y: 35}, {name: 'CHI', x: 60, y: 40},
                {name: 'MIA', x: 80, y: 80}, {name: 'SEA', x: 10, y: 15}
            ];
            cities.forEach(city => {
                const cityEl = document.createElement('div');
                cityEl.className = 'ttr-city';
                cityEl.textContent = city.name;
                cityEl.style.left = city.x + '%';
                cityEl.style.top = city.y + '%';
                map.appendChild(cityEl);
            });

            const routeData = [
                {from: {x: 10, y: 15}, to: {x: 5, y: 35}, length: 80},
                {from: {x: 5, y: 35}, to: {x: 15, y: 60}, length: 90},
                {from: {x: 60, y: 40}, to: {x: 85, y: 30}, length: 100}
            ];
            routeData.forEach((route, i) => {
                const routeEl = document.createElement('div');
                routeEl.className = 'ttr-route';
                const angle = Math.atan2(route.to.y - route.from.y, route.to.x - route.from.x);
                routeEl.style.left = route.from.x + '%';
                routeEl.style.top = route.from.y + '%';
                routeEl.style.width = route.length + 'px';
                routeEl.style.transform = `rotate(${angle}rad)`;
                routeEl.dataset.index = i;
                routeEl.addEventListener('click', () => claimRoute(i, routeEl));
                map.appendChild(routeEl);
            });
        }

        function claimRoute(index, el) {
            if (routes.includes(index)) return;
            const cost = 3;
            if (cards >= cost && trains >= cost) {
                cards -= cost;
                trains -= cost;
                score += cost * 2;
                routes.push(index);
                el.classList.add('claimed');
                updateStats();
                alert(`Route claimed! +${cost * 2} points `);
            } else {
                alert('Not enough cards or trains!');
            }
        }

        function updateStats() {
            document.getElementById('ttr-trains').textContent = trains;
            document.getElementById('ttr-cards').textContent = cards;
            document.getElementById('ttr-score').textContent = score;
        }

        document.getElementById('ttr-draw').addEventListener('click', () => {
            cards += 2;
            updateStats();
        });
        document.getElementById('ttr-new').addEventListener('click', initGame);

        initGame();
    }

    function renderUnoQuantum() {
        const html = `
            <style>
                #uno-play-area { width: min(90vw, 500px); height: min(70vw, 350px); margin: var(--space-lg) auto; background: radial-gradient(circle, rgba(139, 92, 246, 0.3), rgba(0, 212, 255, 0.2)); border-radius: 50%; display: flex; align-items: center; justify-content: center; position: relative; box-shadow: 0 0 40px var(--color-primary); }
                .uno-card { width: 80px; height: 120px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #FFF; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.3); position: absolute; }
                .uno-card:hover { transform: scale(1.1) translateY(-10px); box-shadow: 0 8px 16px rgba(0,0,0,0.4); }
                .uno-card.red { background: linear-gradient(135deg, #FF4444 0%, #CC0000 100%); }
                .uno-card.blue { background: linear-gradient(135deg, #4444FF 0%, #0000CC 100%); }
                .uno-card.green { background: linear-gradient(135deg, #44FF44 0%, #00CC00 100%); }
                .uno-card.yellow { background: linear-gradient(135deg, #FFFF44 0%, #CCCC00 100%); }
                .uno-card.wild { background: linear-gradient(135deg, #FF00FF 0%, #00FFFF 50%, #FFFF00 100%); animation: colorShift 3s infinite; }
                @keyframes colorShift { 0%, 100% { filter: hue-rotate(0deg); } 50% { filter: hue-rotate(180deg); } }
                .uno-center-pile { width: 120px; height: 180px; border-radius: 12px; background: rgba(0, 0, 0, 0.5); border: 3px dashed var(--color-primary); display: flex; align-items: center; justify-content: center; }
                .uno-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
                .uno-player-hand { position: absolute; bottom: -50px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
                .uno-player-card { width: 60px; height: 90px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #FFF; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
                .uno-player-card:hover { transform: translateY(-15px); }
                .uno-message { text-align: center; margin: var(--space-md) 0; min-height: 24px; color: var(--color-primary); font-weight: bold; }
                .uno-special { font-size: 16px; position: absolute; bottom: 10px; width: 100%; text-align: center; }
            </style>
            <div class="uno-stats">
                <div><strong>Your Cards:</strong> <span id="uno-player-count">7</span></div>
                <div><strong>Current Color:</strong> <span id="uno-color"> Red</span></div>
                <div><strong>AI Cards:</strong> <span id="uno-ai-count">7</span></div>
            </div>
            <div class="uno-message" id="uno-message"></div>
            <div id="uno-play-area">
                <div class="uno-center-pile uno-card" id="uno-pile"></div>
                <div class="uno-player-hand" id="uno-player-hand"></div>
            </div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="uno-draw" class="tool-button">Draw Card</button>
                <button id="uno-button" class="tool-button" style="background: gold; color: #000;">UNO!</button>
                <button id="uno-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const colors = ['red', 'blue', 'green', 'yellow'];
        const cardTypes = [
            { type: 'number', value: 0 },
            { type: 'number', value: 1 },
            { type: 'number', value: 2 },
            { type: 'number', value: 3 },
            { type: 'number', value: 4 },
            { type: 'number', value: 5 },
            { type: 'number', value: 6 },
            { type: 'number', value: 7 },
            { type: 'number', value: 8 },
            { type: 'number', value: 9 },
            { type: 'skip', value: '' },
            { type: 'reverse', value: '' },
            { type: 'draw2', value: '+2' },
            { type: 'wild', value: '' },
            { type: 'wild4', value: '+4' }
        ];
        
        let playerHand = [];
        let aiCards = 7;
        let currentCard = { color: 'red', type: 'number', value: 5 };
        let gameDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        let unoCalled = false;
        let gameOver = false;

        function initGame() {
            playerHand = [];
            for (let i = 0; i < 7; i++) {
                playerHand.push(generateRandomCard());
            }
            aiCards = 7;
            currentCard = { color: colors[Math.floor(Math.random() * colors.length)], type: 'number', value: Math.floor(Math.random() * 10) };
            gameDirection = 1;
            unoCalled = false;
            gameOver = false;
            
            renderPlayArea();
            renderPlayerHand();
            updateStats();
            document.getElementById('uno-message').textContent = '';
        }

        function generateRandomCard() {
            const cardType = cardTypes[Math.floor(Math.random() * cardTypes.length)];
            const color = cardType.type === 'wild' || cardType.type === 'wild4' ? 'wild' : colors[Math.floor(Math.random() * colors.length)];
            return { color, type: cardType.type, value: cardType.value };
        }

        function renderPlayArea() {
            const pile = document.getElementById('uno-pile');
            pile.className = `uno-center-pile uno-card ${currentCard.color}`;
            pile.innerHTML = `${currentCard.value}`;
            
            if (currentCard.type !== 'number') {
                const special = document.createElement('div');
                special.className = 'uno-special';
                special.textContent = getSpecialText(currentCard.type);
                pile.appendChild(special);
            }
        }

        function getSpecialText(type) {
            switch(type) {
                case 'skip': return 'Skip';
                case 'reverse': return 'Reverse';
                case 'draw2': return 'Draw 2';
                case 'wild': return 'Wild';
                case 'wild4': return 'Wild Draw 4';
                default: return '';
            }
        }

        function renderPlayerHand() {
            const handEl = document.getElementById('uno-player-hand');
            handEl.innerHTML = '';
            
            playerHand.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = `uno-player-card ${card.color}`;
                cardEl.textContent = card.value;
                
                if (card.type !== 'number') {
                    const special = document.createElement('div');
                    special.className = 'uno-special';
                    special.textContent = getSpecialText(card.type);
                    cardEl.appendChild(special);
                }
                
                cardEl.addEventListener('click', () => playCard(index));
                handEl.appendChild(cardEl);
            });
        }

        function canPlayCard(card) {
            if (card.color === 'wild') return true;
            if (card.color === currentCard.color) return true;
            if (card.type === 'number' && card.value === currentCard.value) return true;
            if (card.type === currentCard.type && card.type !== 'number') return true;
            return false;
        }

        function playCard(index) {
            if (gameOver) return;
            
            const card = playerHand[index];
            
            if (!canPlayCard(card)) {
                document.getElementById('uno-message').textContent = 'Cannot play this card!';
                return;
            }
            
            // Remove the card from player's hand
            playerHand.splice(index, 1);
            
            // Handle special cards
            if (card.type === 'wild' || card.type === 'wild4') {
                // Choose a random color for simplicity
                card.color = colors[Math.floor(Math.random() * colors.length)];
                
                if (card.type === 'wild4') {
                    aiCards += 4;
                    document.getElementById('uno-message').textContent = 'AI draws 4 cards!';
                }
            } else if (card.type === 'draw2') {
                aiCards += 2;
                document.getElementById('uno-message').textContent = 'AI draws 2 cards!';
            } else if (card.type === 'skip') {
                document.getElementById('uno-message').textContent = 'AI turn skipped!';
                renderPlayerHand();
                updateStats();
                currentCard = card;
                renderPlayArea();
                checkWinCondition();
                return; // Skip AI turn
            } else if (card.type === 'reverse') {
                gameDirection *= -1;
                document.getElementById('uno-message').textContent = 'Direction reversed!';
                renderPlayerHand();
                updateStats();
                currentCard = card;
                renderPlayArea();
                checkWinCondition();
                return; // Skip AI turn in 2-player game when reversed
            }
            
            currentCard = card;
            renderPlayArea();
            renderPlayerHand();
            updateStats();
            
            if (checkWinCondition()) return;
            
            // AI's turn
            setTimeout(aiTurn, 800);
        }

        function aiTurn() {
            if (gameOver) return;
            
            // AI plays a random card
            aiCards--;
            
            // Generate a valid card for AI
            const aiCard = generateRandomCard();
            if (aiCard.type === 'wild' || aiCard.type === 'wild4') {
                aiCard.color = colors[Math.floor(Math.random() * colors.length)];
                
                if (aiCard.type === 'wild4') {
                    playerHand.push(generateRandomCard());
                    playerHand.push(generateRandomCard());
                    playerHand.push(generateRandomCard());
                    playerHand.push(generateRandomCard());
                    document.getElementById('uno-message').textContent = 'You draw 4 cards!';
                }
            } else if (aiCard.type === 'draw2') {
                playerHand.push(generateRandomCard());
                playerHand.push(generateRandomCard());
                document.getElementById('uno-message').textContent = 'You draw 2 cards!';
            } else if (aiCard.type === 'skip') {
                document.getElementById('uno-message').textContent = 'Your turn skipped!';
                currentCard = aiCard;
                renderPlayArea();
                renderPlayerHand();
                updateStats();
                setTimeout(aiTurn, 800); // AI gets another turn
                return;
            } else if (aiCard.type === 'reverse') {
                gameDirection *= -1;
                document.getElementById('uno-message').textContent = 'Direction reversed!';
                currentCard = aiCard;
                renderPlayArea();
                renderPlayerHand();
                updateStats();
                setTimeout(aiTurn, 800); // AI gets another turn in 2-player game when reversed
                return;
            }
            
            currentCard = aiCard;
            renderPlayArea();
            renderPlayerHand();
            updateStats();
            
            if (aiCards === 1) {
                document.getElementById('uno-message').textContent = 'AI says UNO!';
            }
            
            checkWinCondition();
        }

        function checkWinCondition() {
            if (playerHand.length === 0) {
                document.getElementById('uno-message').textContent = 'You Win! ';
                gameOver = true;
                return true;
            } else if (aiCards === 0) {
                document.getElementById('uno-message').textContent = 'AI Wins!';
                gameOver = true;
                return true;
            }
            return false;
        }

        function updateStats() {
            document.getElementById('uno-player-count').textContent = playerHand.length;
            document.getElementById('uno-ai-count').textContent = aiCards;
            const colorEmoji = {'red': '', 'blue': '', 'green': '', 'yellow': '', 'wild': ''}[currentCard.color];
            document.getElementById('uno-color').textContent = `${colorEmoji} ${currentCard.color.charAt(0).toUpperCase() + currentCard.color.slice(1)}`;
        }

        document.getElementById('uno-draw').addEventListener('click', () => { 
            if (gameOver) return;
            playerHand.push(generateRandomCard()); 
            renderPlayerHand();
            updateStats(); 
            document.getElementById('uno-message').textContent = 'You drew a card';
        });
        
        document.getElementById('uno-button').addEventListener('click', () => { 
            if (playerHand.length === 1 && !unoCalled) {
                unoCalled = true;
                document.getElementById('uno-message').textContent = 'UNO called! ';
            } else if (playerHand.length !== 1) {
                document.getElementById('uno-message').textContent = 'You can only call UNO when you have 1 card left!';
            }
        });
        
        document.getElementById('uno-new').addEventListener('click', initGame);

        initGame();
    }

    function renderClueMansion() {
        const html = `
            <style>
                #clue-mansion { width: min(90vw, 600px); height: min(80vw, 500px); margin: var(--space-lg) auto; background: linear-gradient(135deg, #4A1A1A 0%, #2A0A0A 100%); border: 4px solid #8B4513; box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; padding: 4px; position: relative; }
                .clue-room { background: rgba(139, 69, 19, 0.3); border: 2px solid #654321; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #FFD700; cursor: pointer; transition: all 0.3s; position: relative; text-align: center; padding: 8px; }
                .clue-room:hover { background: rgba(255, 215, 0, 0.2); transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
                .clue-room.selected { background: rgba(255, 215, 0, 0.3); box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.5); }
                .clue-suspects { display: flex; flex-wrap: wrap; gap: var(--space-xs); justify-content: center; margin: var(--space-md) 0; }
                .clue-suspect-btn { padding: var(--space-xs) var(--space-sm); background: var(--color-glass-bg); border: 1px solid var(--color-border); border-radius: 8px; cursor: pointer; transition: all 0.2s; font-size: 12px; }
                .clue-suspect-btn:hover, .clue-suspect-btn.selected { background: var(--color-primary); color: var(--color-bg-primary); }
                #clue-info { text-align: center; margin: var(--space-md) 0; font-size: 16px; color: var(--color-accent); }
            </style>
            <div id="clue-info">Explore the mansion to find clues...</div>
            <div class="clue-suspects">
                <div class="clue-suspect-btn" data-suspect="scarlet">Miss Scarlet</div>
                <div class="clue-suspect-btn" data-suspect="plum">Prof. Plum</div>
                <div class="clue-suspect-btn" data-suspect="peacock">Mrs. Peacock</div>
                <div class="clue-suspect-btn" data-suspect="green">Mr. Green</div>
                <div class="clue-suspect-btn" data-suspect="mustard">Col. Mustard</div>
                <div class="clue-suspect-btn" data-suspect="white">Mrs. White</div>
            </div>
            <div id="clue-mansion"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="clue-accuse" class="tool-button">Make Accusation</button>
                <button id="clue-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const rooms = ['Library', 'Ballroom', 'Conservatory', 'Dining Room', 'Hall', 'Study', 'Kitchen', 'Lounge', 'Billiard Room'];
        const weapons = ['Candlestick', 'Knife', 'Rope', 'Revolver', 'Wrench', 'Lead Pipe'];
        const suspects = ['scarlet', 'plum', 'peacock', 'green', 'mustard', 'white'];
        let solution = {}, selectedSuspect = null, cluesFound = 0;

        function initGame() {
            solution = {
                room: rooms[Math.floor(Math.random() * rooms.length)],
                weapon: weapons[Math.floor(Math.random() * weapons.length)],
                suspect: suspects[Math.floor(Math.random() * suspects.length)]
            };
            selectedSuspect = null;
            cluesFound = 0;
            renderMansion();
            document.querySelectorAll('.clue-suspect-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('clue-info').textContent = 'Explore the mansion to find clues...';
        }

        function renderMansion() {
            const mansion = document.getElementById('clue-mansion');
            mansion.innerHTML = '';
            rooms.forEach((room, i) => {
                const roomEl = document.createElement('div');
                roomEl.className = 'clue-room';
                roomEl.textContent = room;
                roomEl.dataset.room = room;
                roomEl.addEventListener('click', () => exploreRoom(room, roomEl));
                mansion.appendChild(roomEl);
            });
        }

        function exploreRoom(room, el) {
            el.classList.add('selected');
            cluesFound++;
            if (room === solution.room) {
                document.getElementById('clue-info').textContent = ` Clue found! The crime happened here!`;
            } else {
                document.getElementById('clue-info').textContent = `Nothing suspicious in the ${room}...`;
            }
        }

        document.querySelectorAll('.clue-suspect-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.clue-suspect-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedSuspect = btn.dataset.suspect;
            });
        });

        document.getElementById('clue-accuse').addEventListener('click', () => {
            const selectedRoom = document.querySelector('.clue-room.selected');
            if (!selectedRoom || !selectedSuspect) {
                alert('Select a suspect and explore a room first!');
                return;
            }
            if (selectedRoom.dataset.room === solution.room && selectedSuspect === solution.suspect) {
                alert(` Correct! It was ${selectedSuspect} in the ${solution.room} with the ${solution.weapon}!`);
            } else {
                alert(` Wrong! The answer was ${solution.suspect} in the ${solution.room} with the ${solution.weapon}.`);
            }
        });

        document.getElementById('clue-new').addEventListener('click', initGame);

        initGame();
    }

    function renderStrategoTactical() {
        const html = `
            <style>
                #stratego-board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; width: min(90vw, 500px); height: min(90vw, 500px); margin: var(--space-lg) auto; background: linear-gradient(135deg, #556B2F 0%, #3D5A21 100%); padding: 4px; border: 3px solid #8B4513; box-shadow: 0 0 20px rgba(0,0,0,0.3); }
                .stratego-cell { aspect-ratio: 1; background: rgba(107, 142, 35, 0.3); border: 1px solid rgba(139, 69, 19, 0.5); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; }
                .stratego-cell:hover { background: rgba(255, 215, 0, 0.2); }
                .stratego-cell.water { background: rgba(0, 100, 200, 0.4); cursor: not-allowed; }
                .stratego-piece { width: 80%; height: 80%; background: radial-gradient(circle, var(--color-primary), var(--color-secondary)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #FFF; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
                .stratego-piece.ai { background: radial-gradient(circle, var(--color-accent), #C00060); }
                .stratego-piece.flag::after { content: ''; font-size: 20px; }
                .stratego-piece.bomb::after { content: ''; font-size: 20px; }
                .stratego-stats { text-align: center; margin: var(--space-md) 0; }
            </style>
            <div class="stratego-stats">
                <div><strong>Status:</strong> <span id="stratego-status">Place your army!</span></div>
            </div>
            <div id="stratego-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="stratego-setup" class="tool-button">Auto-Setup</button>
                <button id="stratego-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], gameStarted = false, selectedPiece = null;

        function initGame() {
            board = Array(10).fill(null).map(() => Array(10).fill(null));
            gameStarted = false;
            selectedPiece = null;
            renderBoard();
            document.getElementById('stratego-status').textContent = 'Place your army!';
        }

        function renderBoard() {
            const boardEl = document.getElementById('stratego-board');
            boardEl.innerHTML = '';
            const waterCells = [[4,2],[4,3],[5,2],[5,3],[4,6],[4,7],[5,6],[5,7]];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'stratego-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    if (waterCells.some(([wr, wc]) => wr === r && wc === c)) {
                        cell.classList.add('water');
                    }

                    const piece = board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `stratego-piece ${piece.player}`;
                        if (piece.type === 'flag') pieceEl.classList.add('flag');
                        else if (piece.type === 'bomb') pieceEl.classList.add('bomb');
                        else if (piece.player === 'player') pieceEl.textContent = piece.rank || '?';
                        else pieceEl.textContent = '?';
                        cell.appendChild(pieceEl);
                    }

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }

        function setupArmy() {
            for (let r = 6; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const rand = Math.random();
                    if (rand < 0.02) board[r][c] = { player: 'player', type: 'flag' };
                    else if (rand < 0.1) board[r][c] = { player: 'player', type: 'bomb' };
                    else if (rand < 0.5) board[r][c] = { player: 'player', rank: Math.floor(Math.random() * 9) + 1 };
                }
            }
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 10; c++) {
                    const rand = Math.random();
                    if (rand < 0.02) board[r][c] = { player: 'ai', type: 'flag' };
                    else if (rand < 0.1) board[r][c] = { player: 'ai', type: 'bomb' };
                    else if (rand < 0.5) board[r][c] = { player: 'ai', rank: Math.floor(Math.random() * 9) + 1 };
                }
            }
            gameStarted = true;
            renderBoard();
            document.getElementById('stratego-status').textContent = 'Battle begins! Attack enemy pieces!';
        }

        function handleCellClick(r, c) {
            if (!gameStarted) return;
            const piece = board[r][c];

            if (selectedPiece) {
                if (piece && piece.player === 'ai') {
                    const attacker = board[selectedPiece.r][selectedPiece.c];
                    if (piece.type === 'bomb') {
                        board[selectedPiece.r][selectedPiece.c] = null;
                        alert('Your piece hit a bomb! ');
                    } else if (piece.type === 'flag') {
                        alert('You found the flag! You Win! ');
                        gameStarted = false;
                    } else {
                        const attackerRank = attacker.rank || 0;
                        const defenderRank = piece.rank || 0;
                        if (attackerRank > defenderRank) {
                            board[r][c] = attacker;
                            board[selectedPiece.r][selectedPiece.c] = null;
                            alert('You won the battle!');
                        } else {
                            board[selectedPiece.r][selectedPiece.c] = null;
                            alert('You lost the battle!');
                        }
                    }
                } else if (!piece) {
                    board[r][c] = board[selectedPiece.r][selectedPiece.c];
                    board[selectedPiece.r][selectedPiece.c] = null;
                }
                selectedPiece = null;
                renderBoard();
            } else if (piece && piece.player === 'player' && piece.type !== 'flag' && piece.type !== 'bomb') {
                selectedPiece = { r, c };
            }
        }

        document.getElementById('stratego-setup').addEventListener('click', setupArmy);
        document.getElementById('stratego-new').addEventListener('click', initGame);

        initGame();
    }

    function renderChineseCheckers() {
        const html = `
            <style>
                #cc-board { width: min(90vw, 500px); height: min(90vw, 500px); margin: var(--space-lg) auto; background: radial-gradient(circle, rgba(10, 10, 50, 0.9), rgba(5, 5, 25, 1)); border-radius: 50%; box-shadow: 0 0 40px var(--color-primary); position: relative; display: flex; align-items: center; justify-content: center; }
                .cc-star { position: absolute; width: 100%; height: 100%; }
                .cc-point { position: absolute; width: 24px; height: 24px; background: rgba(255, 255, 255, 0.1); border-radius: 50%; border: 1px solid rgba(255, 255, 255, 0.3); cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
                .cc-point:hover { background: rgba(0, 212, 255, 0.3); transform: scale(1.2); }
                .cc-marble { width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 0 10px currentColor, inset 0 2px 4px rgba(255, 255, 255, 0.4); animation: pulse 2s infinite; }
                .cc-marble.player { background: radial-gradient(circle at 30% 30%, var(--color-primary), #0080FF); }
                .cc-marble.ai { background: radial-gradient(circle at 30% 30%, var(--color-accent), #C00060); }
                .cc-point.selected { background: rgba(0, 255, 100, 0.4); transform: scale(1.3); }
                .cc-stats { text-align: center; margin: var(--space-md) 0; }
            </style>
            <div class="cc-stats">
                <div><strong>Status:</strong> <span id="cc-status">Your turn - Hop to the opposite corner!</span></div>
            </div>
            <div id="cc-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="cc-hint" class="tool-button">Hint</button>
                <button id="cc-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let points = [], selectedPoint = null, currentPlayer = 'player';

        function initGame() {
            points = [];
            const center = 250;
            for (let i = 0; i < 17; i++) {
                const angle = (i / 17) * 2 * Math.PI;
                const radius = 120 + Math.random() * 80;
                points.push({
                    x: center + Math.cos(angle) * radius,
                    y: center + Math.sin(angle) * radius,
                    marble: i < 4 ? 'player' : i < 8 ? 'ai' : null
                });
            }
            selectedPoint = null;
            currentPlayer = 'player';
            renderBoard();
        }

        function renderBoard() {
            const board = document.getElementById('cc-board');
            board.innerHTML = '<div class="cc-star"></div>';
            const star = board.querySelector('.cc-star');

            points.forEach((point, i) => {
                const pointEl = document.createElement('div');
                pointEl.className = 'cc-point';
                pointEl.style.left = point.x + 'px';
                pointEl.style.top = point.y + 'px';
                pointEl.dataset.index = i;

                if (point.marble) {
                    const marble = document.createElement('div');
                    marble.className = `cc-marble ${point.marble}`;
                    pointEl.appendChild(marble);
                }

                if (selectedPoint === i) {
                    pointEl.classList.add('selected');
                }

                pointEl.addEventListener('click', () => handlePointClick(i));
                star.appendChild(pointEl);
            });
        }

        function handlePointClick(index) {
            if (currentPlayer !== 'player') return;

            if (selectedPoint === null) {
                if (points[index].marble === 'player') {
                    selectedPoint = index;
                    renderBoard();
                }
            } else {
                if (!points[index].marble) {
                    points[index].marble = points[selectedPoint].marble;
                    points[selectedPoint].marble = null;
                    selectedPoint = null;
                    renderBoard();
                    checkWin();
                    currentPlayer = 'ai';
                    setTimeout(aiTurn, 1000);
                } else {
                    selectedPoint = null;
                    renderBoard();
                }
            }
        }

        function aiTurn() {
            const aiPoints = points.map((p, i) => p.marble === 'ai' ? i : -1).filter(i => i >= 0);
            if (aiPoints.length === 0) return;

            const fromIndex = aiPoints[Math.floor(Math.random() * aiPoints.length)];
            const emptyPoints = points.map((p, i) => !p.marble ? i : -1).filter(i => i >= 0);
            if (emptyPoints.length > 0) {
                const toIndex = emptyPoints[Math.floor(Math.random() * emptyPoints.length)];
                points[toIndex].marble = 'ai';
                points[fromIndex].marble = null;
            }

            currentPlayer = 'player';
            renderBoard();
            checkWin();
        }

        function checkWin() {
            const playerInGoal = points.slice(13, 17).filter(p => p.marble === 'player').length;
            const aiInGoal = points.slice(0, 4).filter(p => p.marble === 'ai').length;

            if (playerInGoal === 4) {
                alert('You Win! ');
                document.getElementById('cc-status').textContent = 'You Win!';
            } else if (aiInGoal === 4) {
                alert('AI Wins!');
                document.getElementById('cc-status').textContent = 'AI Wins!';
            }
        }

        document.getElementById('cc-hint').addEventListener('click', () => {
            alert('Try to hop over marbles to move faster!');
        });
        document.getElementById('cc-new').addEventListener('click', initGame);

        initGame();
    }

    function renderAbalone() {
        const html = `
            <style>
                #abalone-board { width: min(90vw, 500px); height: min(90vw, 500px); margin: var(--space-lg) auto; background: radial-gradient(circle, #1A1A1A 0%, #000 100%); border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 0 30px rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: center; position: relative; }
                .abalone-hex-grid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 4px; width: 90%; height: 90%; }
                .abalone-hole { width: 100%; aspect-ratio: 1; border-radius: 50%; background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.1); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s; }
                .abalone-hole:hover { background: rgba(0, 212, 255, 0.2); border-color: var(--color-primary); }
                .abalone-marble { width: 85%; height: 85%; border-radius: 50%; box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.3); transition: all 0.3s; }
                .abalone-marble.white { background: radial-gradient(circle at 30% 30%, #FFF, #CCC); }
                .abalone-marble.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
                .abalone-hole.selected { background: rgba(0, 255, 100, 0.3); }
                .abalone-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; }
            </style>
            <div class="abalone-stats">
                <div><strong>White (You):</strong> <span id="abalone-white">14</span></div>
                <div><strong>Black (AI):</strong> <span id="abalone-black">14</span></div>
            </div>
            <div id="abalone-board">
                <div class="abalone-hex-grid" id="abalone-grid"></div>
            </div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="abalone-new" class="tool-button">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let board = [], selected = [], whiteCount = 14, blackCount = 14;

        function initGame() {
            board = Array(9).fill(null).map(() => Array(9).fill(null));
            for (let i = 0; i < 5; i++) {
                for (let j = 2; j < 7; j++) {
                    if (i < 2) board[i][j] = 'black';
                    if (i > 6) board[i][j] = 'white';
                }
            }
            selected = [];
            whiteCount = 14;
            blackCount = 14;
            renderBoard();
            updateStats();
        }

        function renderBoard() {
            const grid = document.getElementById('abalone-grid');
            grid.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const hole = document.createElement('div');
                    hole.className = 'abalone-hole';
                    hole.dataset.row = r;
                    hole.dataset.col = c;

                    if (board[r][c]) {
                        const marble = document.createElement('div');
                        marble.className = `abalone-marble ${board[r][c]}`;
                        hole.appendChild(marble);
                    }

                    if (selected.some(s => s.r === r && s.c === c)) {
                        hole.classList.add('selected');
                    }

                    hole.addEventListener('click', () => handleClick(r, c));
                    grid.appendChild(hole);
                }
            }
        }

        function handleClick(r, c) {
            if (selected.length === 0) {
                if (board[r][c] === 'white') {
                    selected.push({r, c});
                    renderBoard();
                }
            } else {
                if (!board[r][c]) {
                    board[r][c] = 'white';
                    board[selected[0].r][selected[0].c] = null;
                    selected = [];
                    renderBoard();
                    setTimeout(aiTurn, 800);
                } else {
                    selected = [];
                    renderBoard();
                }
            }
        }

        function aiTurn() {
            const aiMarbles = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 'black') aiMarbles.push({r, c});
                }
            }
            if (aiMarbles.length === 0) return;

            const from = aiMarbles[Math.floor(Math.random() * aiMarbles.length)];
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1]];
            const dir = dirs[Math.floor(Math.random() * dirs.length)];
            const nr = from.r + dir[0];
            const nc = from.c + dir[1];

            if (nr >= 0 && nr < 9 && nc >= 0 && nc < 9 && !board[nr][nc]) {
                board[nr][nc] = 'black';
                board[from.r][from.c] = null;
            }

            renderBoard();
        }

        function updateStats() {
            document.getElementById('abalone-white').textContent = whiteCount;
            document.getElementById('abalone-black').textContent = blackCount;
        }

        document.getElementById('abalone-new').addEventListener('click', initGame);

        initGame();
    }

    function renderNineMensMorris() {
        const html = `
            <style>
                #morris-container { background: linear-gradient(135deg, #8B7355, #654321); padding: var(--space-lg); border-radius: var(--radius-lg); max-width: 550px; margin: 0 auto; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
                #morris-board { width: 100%; aspect-ratio: 1; margin: var(--space-lg) auto; background: linear-gradient(135deg, #D2B48C, #C4A582); border: 4px solid #5D4E37; box-shadow: inset 0 0 20px rgba(0,0,0,0.3); position: relative; border-radius: 8px; }
                .morris-line { position: absolute; background: rgba(93, 78, 55, 0.4); }
                .morris-point { position: absolute; width: 32px; height: 32px; background: rgba(139, 115, 85, 0.5); border: 3px solid #5D4E37; border-radius: 50%; transform: translate(-50%, -50%); cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
                .morris-point:hover { background: rgba(0, 212, 255, 0.3); border-color: var(--color-primary); transform: translate(-50%, -50%) scale(1.2); }
                .morris-stone { width: 24px; height: 24px; border-radius: 50%; box-shadow: 0 3px 6px rgba(0,0,0,0.4); animation: placeStone 0.4s ease-out; }
                .morris-stone.player { background: radial-gradient(circle at 35% 35%, #E0E0E0, #A0A0A0); }
                .morris-stone.ai { background: radial-gradient(circle at 35% 35%, #4A4A4A, #1A1A1A); }
                @keyframes placeStone { from { transform: scale(0); } to { transform: scale(1); } }
                .morris-stats { display: flex; justify-content: space-around; margin: var(--space-md) 0; text-align: center; color: #2C1810; font-weight: 600; }
            </style>
            <div id="morris-container">
                <div class="morris-stats">
                    <div>Your Stones: <span id="morris-player">9</span></div>
                    <div>AI Stones: <span id="morris-ai">9</span></div>
                </div>
                <div id="morris-board"></div>
                <div style="text-align: center; margin-top: var(--space-md);">
                    <button id="morris-new" class="tool-button">New Game</button>
                </div>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const positions = [
            [12.5, 12.5], [50, 12.5], [87.5, 12.5],
            [25, 25], [50, 25], [75, 25],
            [37.5, 37.5], [50, 37.5], [62.5, 37.5],
            [12.5, 50], [25, 50], [37.5, 50], [62.5, 50], [75, 50], [87.5, 50],
            [37.5, 62.5], [50, 62.5], [62.5, 62.5],
            [25, 75], [50, 75], [75, 75],
            [12.5, 87.5], [50, 87.5], [87.5, 87.5]
        ];

        let board = Array(24).fill(null), playerStones = 9, aiStones = 9, phase = 'placing', selected = null;

        function initGame() {
            board = Array(24).fill(null);
            playerStones = 9;
            aiStones = 9;
            phase = 'placing';
            selected = null;
            renderBoard();
            updateStats();
        }

        function renderBoard() {
            const boardEl = document.getElementById('morris-board');
            boardEl.innerHTML = '';

            positions.forEach((pos, i) => {
                const point = document.createElement('div');
                point.className = 'morris-point';
                point.style.left = pos[0] + '%';
                point.style.top = pos[1] + '%';
                point.dataset.index = i;

                if (board[i]) {
                    const stone = document.createElement('div');
                    stone.className = `morris-stone ${board[i]}`;
                    point.appendChild(stone);
                }

                point.addEventListener('click', () => handlePointClick(i));
                boardEl.appendChild(point);
            });
        }

        function handlePointClick(index) {
            if (phase === 'placing' && !board[index] && playerStones > 0) {
                board[index] = 'player';
                playerStones--;
                updateStats();
                renderBoard();

                if (checkMill(index, 'player')) {
                    alert('Mill formed! Remove an opponent stone!');
                }

                setTimeout(aiPlace, 800);
            }
        }

        function aiPlace() {
            if (aiStones <= 0) return;

            const empty = board.map((b, i) => b === null ? i : -1).filter(i => i >= 0);
            if (empty.length > 0) {
                const index = empty[Math.floor(Math.random() * empty.length)];
                board[index] = 'ai';
                aiStones--;
                updateStats();
                renderBoard();

                if (checkMill(index, 'ai')) {
                    const playerStones = board.map((b, i) => b === 'player' ? i : -1).filter(i => i >= 0);
                    if (playerStones.length > 0) {
                        const remove = playerStones[Math.floor(Math.random() * playerStones.length)];
                        board[remove] = null;
                        renderBoard();
                    }
                }
            }
        }

        function checkMill(index, player) {
            const mills = [
                [0,1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14], [15,16,17], [18,19,20], [21,22,23],
                [0,9,21], [3,10,18], [6,11,15], [1,4,7], [16,19,22], [8,12,17], [5,13,20], [2,14,23]
            ];

            return mills.some(mill =>
                mill.includes(index) &&
                mill.every(i => board[i] === player)
            );
        }

        function updateStats() {
            document.getElementById('morris-player').textContent = playerStones;
            document.getElementById('morris-ai').textContent = aiStones;
        }

        document.getElementById('morris-new').addEventListener('click', initGame);

        initGame();
    }

    function renderTheDuke() {
        const html = `
            <style>
                #duke-board { display: grid; grid-template-columns: repeat(6, 1fr); gap: 2px; width: min(90vw, 480px); height: min(90vw, 480px); margin: var(--space-lg) auto; background: linear-gradient(135deg, #8B4513, #654321); padding: 8px; border: 4px solid #D2691E; box-shadow: 0 0 20px rgba(0,0,0,0.4); }
                .duke-cell { aspect-ratio: 1; background: rgba(210, 180, 140, 0.3); border: 1px solid rgba(139, 69, 19, 0.5); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
                .duke-cell:hover { background: rgba(255, 215, 0, 0.2); }
                .duke-tile { width: 85%; height: 85%; background: linear-gradient(135deg, #F5DEB3, #DEB887); border: 2px solid #8B4513; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #2C1810; box-shadow: 0 3px 6px rgba(0,0,0,0.3); transition: all 0.3s; position: relative; }
                .duke-tile:hover { transform: scale(1.05); }
                .duke-tile.player { border-color: var(--color-primary); }
                .duke-tile.ai { border-color: var(--color-accent); background: linear-gradient(135deg, #D8BFD8, #DDA0DD); }
                .duke-tile::after { content: attr(data-unit); font-size: 16px; margin-top: 4px; }
                .duke-stats { text-align: center; margin: var(--space-md) 0; }
            </style>
            <div class="duke-stats">
                <div><strong>Status:</strong> <span id="duke-status">Place your Duke!</span></div>
            </div>
            <div id="duke-board"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="duke-draw" class="tool-button">Draw Tile</button>
                <button id="duke-new" class="tool-button tool-button-secondary">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        const units = ['', '', '', '', '', ''];
        let board = [], bag = [...units, ...units, ...units], currentPlayer = 'player', selected = null;

        function initGame() {
            board = Array(6).fill(null).map(() => Array(6).fill(null));
            board[5][2] = { player: 'player', unit: '', flipped: false };
            board[0][3] = { player: 'ai', unit: '', flipped: false };
            bag = [...units, ...units, ...units];
            currentPlayer = 'player';
            selected = null;
            renderBoard();
            document.getElementById('duke-status').textContent = 'Your turn!';
        }

        function renderBoard() {
            const boardEl = document.getElementById('duke-board');
            boardEl.innerHTML = '';

            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'duke-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    const tile = board[r][c];
                    if (tile) {
                        const tileEl = document.createElement('div');
                        tileEl.className = `duke-tile ${tile.player}`;
                        tileEl.dataset.unit = tile.unit;
                        tileEl.textContent = tile.flipped ? '' : '';
                        cell.appendChild(tileEl);
                    }

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }

        function handleCellClick(r, c) {
            if (currentPlayer !== 'player') return;

            const tile = board[r][c];

            if (selected) {
                if (!tile || tile.player === 'ai') {
                    if (tile && tile.player === 'ai' && tile.unit === '') {
                        alert('You captured the Duke! You Win! ');
                        return;
                    }
                    board[r][c] = board[selected.r][selected.c];
                    board[r][c].flipped = !board[r][c].flipped;
                    board[selected.r][selected.c] = null;
                    selected = null;
                    renderBoard();
                    currentPlayer = 'ai';
                    setTimeout(aiTurn, 1000);
                }
            } else if (tile && tile.player === 'player') {
                selected = { r, c };
            }
        }

        function aiTurn() {
            const aiTiles = [];
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    if (board[r][c] && board[r][c].player === 'ai') {
                        aiTiles.push({r, c});
                    }
                }
            }

            if (aiTiles.length > 0) {
                const from = aiTiles[Math.floor(Math.random() * aiTiles.length)];
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                const nr = from.r + dir[0];
                const nc = from.c + dir[1];

                if (nr >= 0 && nr < 6 && nc >= 0 && nc < 6) {
                    if (!board[nr][nc] || board[nr][nc].player === 'player') {
                        if (board[nr][nc] && board[nr][nc].unit === '') {
                            alert('AI captured your Duke! AI Wins!');
                            return;
                        }
                        board[nr][nc] = board[from.r][from.c];
                        board[nr][nc].flipped = !board[nr][nc].flipped;
                        board[from.r][from.c] = null;
                    }
                }
            }

            currentPlayer = 'player';
            renderBoard();
        }

        document.getElementById('duke-draw').addEventListener('click', () => {
            if (bag.length > 0 && currentPlayer === 'player') {
                const unit = bag.splice(Math.floor(Math.random() * bag.length), 1)[0];
                alert(`Drew: ${unit} - Place it on the board!`);
            }
        });

        document.getElementById('duke-new').addEventListener('click', initGame);

        initGame();
    }

    function renderHiveEmpire() {
        const html = `
            <style>
                #hive-play-area { width: min(90vw, 600px); height: min(70vw, 400px); margin: var(--space-lg) auto; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 235, 59, 0.05)); position: relative; border-radius: var(--radius-lg); box-shadow: 0 0 30px rgba(255, 193, 7, 0.3); overflow: hidden; }
                .hive-hex { position: absolute; width: 60px; height: 69px; clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); background: rgba(255, 193, 7, 0.2); border: 2px solid rgba(255, 193, 7, 0.4); display: flex; align-items: center; justify-content: center; font-size: 28px; cursor: pointer; transition: all 0.3s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
                .hive-hex:hover { transform: scale(1.1); background: rgba(255, 193, 7, 0.4); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
                .hive-hex.player { border-color: var(--color-primary); }
                .hive-hex.ai { border-color: var(--color-accent); }
                .hive-hex.queen::after { content: ''; }
                .hive-hex.ant::after { content: ''; }
                .hive-hex.beetle::after { content: ''; }
                .hive-hex.spider::after { content: ''; }
                .hive-hex.grasshopper::after { content: ''; }
                .hive-pieces { display: flex; gap: var(--space-xs); justify-content: center; margin: var(--space-md) 0; flex-wrap: wrap; }
                .hive-piece-btn { padding: var(--space-xs) var(--space-sm); background: var(--color-glass-bg); border: 1px solid var(--color-border); border-radius: 8px; cursor: pointer; font-size: 24px; transition: all 0.2s; }
                .hive-piece-btn:hover { background: var(--color-primary); transform: scale(1.1); }
            </style>
            <div class="hive-pieces">
                <div class="hive-piece-btn" data-piece="queen"> Queen</div>
                <div class="hive-piece-btn" data-piece="ant"> Ant</div>
                <div class="hive-piece-btn" data-piece="beetle"> Beetle</div>
                <div class="hive-piece-btn" data-piece="spider"> Spider</div>
                <div class="hive-piece-btn" data-piece="grasshopper"> Hopper</div>
            </div>
            <div id="hive-play-area"></div>
            <div style="text-align: center; margin-top: var(--space-md);">
                <button id="hive-new" class="tool-button">New Game</button>
            </div>
        `;
        a.toolContent.innerHTML = html;

        let hexes = [], selectedPiece = null, turnCount = 0;

        function initGame() {
            hexes = [];
            selectedPiece = null;
            turnCount = 0;
            renderHive();
        }

        function renderHive() {
            const area = document.getElementById('hive-play-area');
            area.innerHTML = '';

            if (hexes.length === 0) {
                const centerHex = createHex(300, 200, 'player', 'queen');
                area.appendChild(centerHex);
                hexes.push({x: 300, y: 200, player: 'player', type: 'queen'});
            } else {
                hexes.forEach(hex => {
                    const hexEl = createHex(hex.x, hex.y, hex.player, hex.type);
                    area.appendChild(hexEl);
                });
            }
        }

        function createHex(x, y, player, type) {
            const hex = document.createElement('div');
            hex.className = `hive-hex ${player} ${type}`;
            hex.style.left = x + 'px';
            hex.style.top = y + 'px';
            hex.addEventListener('click', () => handleHexClick(x, y));
            return hex;
        }

        function handleHexClick(x, y) {
            if (selectedPiece) {
                const adjacent = hexes.some(h =>
                    Math.abs(h.x - x) < 80 && Math.abs(h.y - y) < 80
                );

                if (adjacent && !hexes.some(h => h.x === x && h.y === y)) {
                    hexes.push({x, y, player: 'player', type: selectedPiece});
                    selectedPiece = null;
                    renderHive();
                    checkWin();
                    turnCount++;
                    setTimeout(aiTurn, 1000);
                }
            }
        }

        function aiTurn() {
            if (hexes.length === 0) return;

            const types = ['ant', 'beetle', 'spider', 'grasshopper'];
            const type = types[Math.floor(Math.random() * types.length)];
            const baseHex = hexes[Math.floor(Math.random() * hexes.length)];
            const angle = Math.random() * 2 * Math.PI;
            const x = baseHex.x + Math.cos(angle) * 70;
            const y = baseHex.y + Math.sin(angle) * 70;

            hexes.push({x, y, player: 'ai', type});
            renderHive();
            checkWin();
        }

        function checkWin() {
            const playerQueen = hexes.find(h => h.player === 'player' && h.type === 'queen');
            const aiQueen = hexes.find(h => h.player === 'ai' && h.type === 'queen');

            if (playerQueen) {
                const surrounded = hexes.filter(h =>
                    Math.abs(h.x - playerQueen.x) < 80 &&
                    Math.abs(h.y - playerQueen.y) < 80 &&
                    h !== playerQueen
                ).length;

                if (surrounded >= 6) {
                    alert('Your Queen is surrounded! AI Wins!');
                }
            }
        }

        document.querySelectorAll('.hive-piece-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedPiece = btn.dataset.piece;
                alert(`Selected ${btn.textContent}. Click near an existing hex to place it.`);
            });
        });

        document.getElementById('hive-new').addEventListener('click', initGame);

        initGame();
    }


    // --- VIEW & NAVIGATION LOGIC ---

    function cleanUpTool() {
        if (currentToolInterval) {
            if (typeof currentToolInterval === 'function') {
                currentToolInterval(); // It's a cleanup function
            } else {
                clearInterval(currentToolInterval);
            }
            currentToolInterval = null;
        }
        // Specific cleanup for audio context
        if (audioContext) {
            audioContext.close();
            audioContext = null;
        }
        if (soundMeter.stream) {
            soundMeter.stream.getTracks().forEach(track => track.stop());
            soundMeter.stream = null;
            cancelAnimationFrame(soundMeter.animationFrameId);
        }
    }

    function openTool(toolId) {
      cleanUpTool();
      
      // Save current position before opening tool
      localStorage.setItem('infinity-tool-hub-last-category', state.categoryFilter);
      localStorage.setItem('infinity-tool-hub-last-scroll', a.dashboardView.scrollTop);
      
      const tool = tools.find(t => t.id === toolId);
      if (!tool || !a.toolTitle || !a.toolContent) return;
      a.toolTitle.textContent = tool.name;

      switch (toolId) {
        // Time & Date
        case 'digital-clock': renderDigitalClock(); break;
        case 'world-clock': renderWorldClock(); break;
        case 'countdown-timer': renderCountdownTimer(); break;
        case 'stopwatch': renderStopwatch(); break;
        case 'pomodoro-timer': renderPomodoroTimer(); break;
        case 'age-calculator': renderAgeCalculator(); break;
        case 'date-difference': renderDateDifference(); break;
        case 'calendar-generator': renderCalendarGenerator(); break;
        // Converters
        case 'length-converter': renderGenericConverter('length'); break;
        case 'weight-converter': renderGenericConverter('weight'); break;
        case 'temp-converter': renderGenericConverter('temp'); break;
        case 'currency-converter': renderGenericConverter('currency'); break;
        case 'speed-converter': renderGenericConverter('speed'); break;
        case 'area-converter': renderGenericConverter('area'); break;
        case 'volume-converter': renderGenericConverter('volume'); break;
        // Math & Finance
        case 'calculator': renderNormalCalculator(); break;
        case 'scientific-calculator': renderScientificCalculator(); break;
        case 'loan-calculator': renderLoanCalculator(); break;
        case 'compound-interest-calculator': renderCompoundInterestCalculator(); break;
        case 'savings-calculator': renderSavingsCalculator(); break;
        case 'roi-calculator': renderRoiCalculator(); break;
        case 'tip-calculator': renderTipCalculator(); break;
        case 'percentage-calculator': renderPercentageCalculator(); break;
        case 'number-base-converter': renderNumberBaseConverter(); break;
        case 'bmi-calculator': renderBmiCalculator(); break;
        // Text & Writing
        case 'word-counter': renderWordCounter(); break;
        case 'password-generator': renderPasswordGenerator(); break;
        case 'qr-code-generator': renderQrCodeGenerator(); break;
        case 'markdown-previewer': renderMarkdownPreviewer(); break;
        case 'case-converter': renderCaseConverter(); break;
        case 'lorem-ipsum-generator': renderLoremIpsumGenerator(); break;
        case 'text-reverser': renderTextReverser(); break;
        case 'text-sorter': renderTextSorter(); break;
        case 'base64-coder': renderBase64Coder(); break;
        case 'url-coder': renderUrlCoder(); break;
        case 'slugify-text': renderSlugifyText(); break;
        // Internet & Networking
        case 'ip-finder': renderIpFinder(); break;
        case 'ping-tool': renderPingTool(); break;
        case 'port-scanner': renderPortScanner(); break;
        case 'whois-lookup': renderWhoisLookup(); break;
        case 'url-shortener': renderUrlShortener(); break;
        case 'base32-coder': renderBase32Coder(); break;
        case 'morse-code': renderMorseCode(); break;
        case 'text-encrypt': renderTextEncrypt(); break;
        case 'hash-generator': renderHashGenerator(); break;
        // Utilities
        case 'unit-converter-hub': renderUnitConverterHub(); break;
        case 'battery-status': renderBatteryStatus(); break;
        case 'clipboard-manager': renderClipboardManager(); break;
        case 'notes-app': renderNotesApp(); break;
        case 'todo-list': renderTodoList(); break;
        case 'reminder-app': renderReminderApp(); break;
        case 'weather-app': renderWeatherApp(); break;
        case 'sound-meter': renderSoundMeter(); break;
        case 'compass': renderCompass(); break;
        case 'screen-light': renderScreenLight(); break;
        // Device Tools
        case 'device-info-viewer': renderDeviceInfoViewer(); break;
        case 'storage-check': renderStorageCheck(); break;
        case 'speed-test': renderSpeedTest(); break;
        case 'screen-ruler': renderScreenRuler(); break;
        case 'color-picker': renderColorPicker(); break;
        case 'screen-splitter': renderScreenSplitter(); break;
        case 'clipboard-viewer': renderClipboardViewer(); break;
        case 'theme-detector': renderThemeDetector(); break;
        case 'mic-tester': renderMicTester(); break;
        case 'camera-preview': renderCameraPreview(); break;
        // Puzzle Games
        case 'sudoku': renderSudoku(); break;
        case 'crossword': renderCrossword(); break;
        case 'word-search': renderWordSearch(); break;
        case 'math-quiz': renderMathQuiz(); break;
        case 'memory-match': renderMemoryMatch(); break;
        case 'pattern-lock-puzzle': renderPatternLockPuzzle(); break;
        case 'logic-riddles': renderLogicRiddles(); break;
        case 'hangman': renderHangman(); break;
        case 'typing-test': renderTypingTest(); break;
        case 'spelling-bee': renderSpellingBee(); break;

        // Mini Games
        case 'snake-classic': renderSnakeClassic(); break;
        case 'neon-flappy': renderNeonFlappy(); break;
        case '2048-fusion': render2048Fusion(); break;
        case 'laser-breaker': renderLaserBreaker(); break;
        case 'cosmic-defender': renderCosmicDefender(); break;
        case 'pixel-sweeper': renderPixelSweeper(); break;
        case 'pacman-neon': renderPacmanNeon(); break;
        case 'tetris-dimension': renderTetrisDimension(); break;
        case 'pong-evolution': renderPongEvolution(); break;
        case 'fruit-slash': renderFruitSlash(); break;

        // Board Games
        case 'quantum-chess': renderQuantumChess(); break;
        case 'neon-checkers': renderNeonCheckers(); break;
        case 'ludo-legacy': renderLudoLegacy(); break;
        case 'backgammon-masters': renderBackgammonMasters(); break;
        case 'reversi-strategy': renderReversiStrategy(); break;
        case 'connect-four': renderConnectFour(); break;
        case 'go-ancient': renderGoAncient(); break;
        case 'scrabble-master': renderScrabbleMaster(); break;
        case 'mahjong-deluxe': renderMahjongDeluxe(); break;
        case 'battleship-command': renderBattleshipCommand(); break;
        case 'catan-universe': renderCatanUniverse(); break;
        case 'ticket-to-ride': renderTicketToRide(); break;
        case 'uno-quantum': renderUnoQuantum(); break;
        case 'clue-mansion': renderClueMansion(); break;
        case 'stratego-tactical': renderStrategoTactical(); break;
        case 'chinese-checkers': renderChineseCheckers(); break;
        case 'abalone-force': renderAbalone(); break;
        case 'nine-mens-morris': renderNineMensMorris(); break;
        case 'the-duke': renderTheDuke(); break;
        case 'hive-empire': renderHiveEmpire(); break;

        default:
          if(a.toolContent) a.toolContent.innerHTML = `<p>This tool is under construction.</p>`;
          break;
      }

      a.dashboardView?.classList.remove('active');
      a.toolView?.classList.add('active');
    }

    function showDashboard() {
      cleanUpTool();
      a.toolView?.classList.remove('active');
      a.dashboardView?.classList.add('active');
      a.body.classList.remove('tool-fullscreen');
      a.searchInput.value = '';
      state.textFilter = '';
      
      // Restore last category and position
      const lastCategory = localStorage.getItem('infinity-tool-hub-last-category') || 'All';
      state.categoryFilter = lastCategory;
      renderCategoryFilters();
      renderDashboard();
      
      // Restore scroll position after rendering
      setTimeout(() => {
        const lastScroll = localStorage.getItem('infinity-tool-hub-last-scroll');
        if (lastScroll) {
          a.dashboardView.scrollTop = parseInt(lastScroll, 10);
        }
      }, 100);
    }

    // --- THEME MANAGEMENT ---
    function applyTheme(theme) {
      if (!a.body) return;
      a.body.className = '';
      a.body.classList.add(theme);
      localStorage.setItem('infinity-tool-hub-theme', theme);
      if (a.themeSelect) a.themeSelect.value = theme;
    }

    // --- TOOL CONTROLS ---
    function toggleToolFullscreen() {
        a.body.classList.toggle('tool-fullscreen');
    }

    // --- PARTICLE BACKGROUND ANIMATION ---
    function runParticleAnimation() {
      if (!a.particleCanvas) return;
      const canvas = a.particleCanvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      let particles = [];

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      const particleCount = Math.floor(canvas.width / 30);

      class Particle {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.size = Math.random() * 2 + 1;
          this.speedX = Math.random() * 1 - 0.5;
          this.speedY = Math.random() * 1 - 0.5;
        }
        update() {
          this.x += this.speedX;
          this.y += this.speedY;

          if (this.size > 0.1) this.size -= 0.01;
          if (this.x > canvas.width || this.x < 0) this.speedX *= -1;
          if (this.y > canvas.height || this.y < 0) this.speedY *= -1;
        }
        draw() {
          if(!ctx) return;
          const style = getComputedStyle(document.body);
          const primaryColor = style.getPropertyValue('--color-primary');
          ctx.fillStyle = primaryColor + '80'; // 50% opacity
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
        }
      }

      function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          particles.push(new Particle());
        }
      }

      function animate() {
        if(!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (const particle of particles) {
          particle.update();
          particle.draw();
        }
        requestAnimationFrame(animate);
      }

      initParticles();
      animate();
    }


    // --- INITIALIZATION ---
    function init() {
      const savedTheme = localStorage.getItem('infinity-tool-hub-theme') || 'theme-neon-nights';
      applyTheme(savedTheme);
      
      state.favorites = JSON.parse(localStorage.getItem('infinity-tool-hub-favorites')) || [];

      renderDashboard();
      renderNavigation();
      renderCategoryFilters();

      a.themeSelect?.addEventListener('change', (e) => applyTheme(e.target.value));
      a.searchInput?.addEventListener('input', (e) => {
        state.textFilter = e.target.value;
        renderDashboard();
      });
      a.backButton?.addEventListener('click', showDashboard);
      a.logoLink?.addEventListener('click', (e) => {
          e.preventDefault();
          showDashboard();
      });
      a.toolExpandBtn?.addEventListener('click', toggleToolFullscreen);
      
      runParticleAnimation();
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
